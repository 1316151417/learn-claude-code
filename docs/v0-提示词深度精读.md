# v0_bash_agent_glm.py 提示词深度精读

**解析 Bash Agent 的提示词工程艺术**

---

## 目录

1. [提示词全景](#1-提示词全景)
2. [工具描述分析](#2-工具描述分析)
3. [System Prompt 分析](#3-system-prompt-分析)
4. [提示词设计原则](#4-提示词设计原则)
5. [提示词工程技巧](#5-提示词工程技巧)
6. [对比实验](#6-对比实验)
7. [优化建议](#7-优化建议)

---

## 1. 提示词全景

### 完整提示词结构

```
┌─────────────────────────────────────────────────────────────┐
│                    v0 Agent 提示词                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              工具描述 (TOOL.description)              │   │
│  │  教 AI：bash 工具是什么、怎么用、何时用              │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              System Prompt (SYSTEM)                  │   │
│  │  定义 AI 的角色、规则、决策逻辑                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              用户消息 (User Message)                 │   │
│  │  具体的任务请求                                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 运行时的完整 Prompt

```python
# 实际发送给 LLM 的完整消息
messages = [
    {
        "role": "system",
        "content": """你是一个位于 /Users/jiezhou/... 的 CLI 代理。使用 bash 命令解决问题。

规则：
- 优先使用工具而非文字。先行动，后简要解释。
- 读文件: cat, grep, find, rg, ls, head, tail
- 写文件: echo '...' > file, sed -i, 或 cat << 'EOF' > file
- 子代理：对于复杂的子任务，生成子代理以保持上下文干净：
  python3 v0_bash_agent_glm.py "探索 src/ 并总结架构"

何时使用子代理：
- 任务需要读取很多文件（隔离探索过程）
- 任务是独立且自包含的
- 你希望避免用中间细节污染当前对话

子代理在隔离中运行，仅返回最终摘要。"""
    },
    {
        "role": "user",
        "content": "列出当前目录的 Python 文件"
    }
]

tools = [{
    "type": "function",
    "function": {
        "name": "bash",
        "description": """执行 shell 命令。常用模式：
- 读取: cat/head/tail, grep/find/rg/ls, wc -l
- 写入: echo 'content' > file, sed -i 's/old/new/g' file
- 子代理: python3 v0_bash_agent_glm.py 'task description' (生成独立代理，返回摘要)""",
        "parameters": {...}
    }
}]
```

---

## 2. 工具描述分析

### 2.1 完整工具描述

```python
TOOL = {
    "type": "function",
    "function": {
        "name": "bash",
        "description": """执行 shell 命令。常用模式：
- 读取: cat/head/tail, grep/find/rg/ls, wc -l
- 写入: echo 'content' > file, sed -i 's/old/new/g' file
- 子代理: python3 v0_bash_agent_glm.py 'task description' (生成独立代理，返回摘要)""",
        "parameters": {
            "type": "object",
            "properties": {
                "command": {
                    "type": "string",
                    "description": "要执行的 shell 命令"
                }
            },
            "required": ["command"]
        }
    }
}
```

### 2.2 描述的结构分析

```
┌─────────────────────────────────────────────────────────────┐
│                  工具描述的三层结构                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  第 1 层：功能定义                                           │
│  "执行 shell 命令"                                          │
│         ↓                                                   │
│  回答：这个工具是干什么的？                                  │
│                                                             │
│  第 2 层：常用模式                                           │
│  "- 读取: cat, grep, find"                                  │
│  "- 写入: echo, sed"                                        │
│         ↓                                                   │
│  回答：怎么用这个工具？                                      │
│                                                             │
│  第 3 层：高级能力                                           │
│  "- 子代理: python3 self.py 'task'"                         │
│         ↓                                                   │
│  回答：有什么隐藏能力？                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 逐句解析

#### 第 1 句：功能定义

```python
"执行 shell 命令。"
```

**设计分析：**

| 要素 | 分析 |
|------|------|
| **简洁性** | 6 个字，直击核心 |
| **明确性** | "shell 命令" 是技术术语，无歧义 |
| **完整性** | 虽短但涵盖了所有可能操作 |

**为什么这样写？**

```
❌ 不好的写法：
"这个工具可以帮你执行各种命令"
      ↑ 太模糊

"执行 Unix/Linux shell 命令，包括但不限于..."
      ↑ 太啰嗦

✅ 好的写法：
"执行 shell 命令。"
      ↑ 简洁、准确、专业
```

#### 第 2 句：读取模式

```python
"- 读取: cat/head/tail, grep/find/rg/ls, wc -l"
```

**命令选择的原因：**

| 命令 | 用途 | 为什么包含 |
|------|------|-----------|
| `cat` | 查看完整文件 | 最常用的读命令 |
| `head/tail` | 查看文件头部/尾部 | 快速预览 |
| `grep` | 搜索文本 | 代码搜索必备 |
| `find` | 查找文件 | 文件定位 |
| `rg` | 更快的 grep | 现代替代品 |
| `ls` | 列出目录 | 基础命令 |
| `wc -l` | 统计行数 | 代码度量 |

**为什么列出这些命令？**

1. **减少尝试**：AI 不需要猜测用什么命令
2. **提高效率**：直接使用最佳工具
3. **展示能力边界**：暗示 bash 可以做这些事

#### 第 3 句：写入模式

```python
"- 写入: echo 'content' > file, sed -i 's/old/new/g' file"
```

**模式分析：**

```
echo 'content' > file
    ↑             ↑
  创建/覆盖     重定向

sed -i 's/old/new/g' file
      ↑           ↑
    就地编辑    替换所有匹配
```

**为什么这两个模式？**

```
写入操作的两种典型场景：

1. 完全写入
   echo '内容' > file
   → 新建文件或完全覆盖

2. 部分修改
   sed -i 's/旧/新/g' file
   → 保留文件内容，只修改部分
```

#### 第 4 句：子代理能力

```python
"- 子代理: python3 v0_bash_agent_glm.py 'task description' (生成独立代理，返回摘要)"
```

**这是最关键的一句！**

```
┌─────────────────────────────────────────────────────────────┐
│              子代理调用的完整信息                            │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────┐   │
│  │  调用方式                                            │   │
│  │  python3 v0_bash_agent_glm.py 'task description'    │   │
│  │           ↑                                         │   │
│  │      调用自身！递归！                               │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  行为说明                                            │   │
│  │  (生成独立代理，返回摘要)                            │   │
│  │      ↑                                              │   │
│  │  告诉 AI 结果是什么                                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**为什么这样设计？**

1. **明确的调用方式**：给出完整的命令模板
2. **结果预期**："返回摘要" 让 AI 知道会得到什么
3. **递归能力**：通过 bash 调用自身，无需额外的 Task 工具

### 2.4 描述中的提示词技巧

#### 技巧 1：分类组织

```python
"- 读取: ..."
"- 写入: ..."
"- 子代理: ..."
```

**好处：**
- 结构清晰，易于理解
- AI 按类别检索，效率更高
- 方便后续扩展

#### 技巧 2：命令枚举

```python
"cat/head/tail, grep/find/rg/ls"
```

**为什么枚举而不是泛泛而谈？**

```
❌ 模糊描述：
"读取文件的各种命令"
     ↑
   AI 需要猜测

✅ 明确枚举：
"cat, grep, find"
     ↑
   直接使用
```

#### 技巧 3：示例驱动

```python
"echo 'content' > file"
"sed -i 's/old/new/g' file"
"python3 v0_bash_agent_glm.py 'task description'"
```

**示例是最好的文档：**
- 展示语法格式
- 提供可复制的模板
- 降低学习成本

---

## 3. System Prompt 分析

### 3.1 完整 System Prompt

```python
SYSTEM = f"""你是一个位于 {os.getcwd()} 的 CLI 代理。使用 bash 命令解决问题。

规则：
- 优先使用工具而非文字。先行动，后简要解释。
- 读文件: cat, grep, find, rg, ls, head, tail
- 写文件: echo '...' > file, sed -i, 或 cat << 'EOF' > file
- 子代理：对于复杂的子任务，生成子代理以保持上下文干净：
  python3 v0_bash_agent_glm.py "探索 src/ 并总结架构"

何时使用子代理：
- 任务需要读取很多文件（隔离探索过程）
- 任务是独立且自包含的
- 你希望避免用中间细节污染当前对话

子代理在隔离中运行，仅返回最终摘要。"""
```

### 3.2 结构分解

```
┌─────────────────────────────────────────────────────────────┐
│                  System Prompt 的五个层次                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  1. 角色定义                                         │   │
│  │  "你是一个位于 {cwd} 的 CLI 代理"                    │   │
│  │  → AI 知道自己是谁、在哪里                           │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  2. 核心任务                                         │   │
│  │  "使用 bash 命令解决问题"                            │   │
│  │  → AI 知道要做什么                                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  3. 行为规则                                         │   │
│  │  "优先使用工具...先行动，后解释"                     │   │
│  │  → AI 知道怎么做                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  4. 能力清单                                         │   │
│  │  "读文件: cat, grep..."                              │   │
│  │  "写文件: echo, sed..."                              │   │
│  │  → AI 知道能做什么                                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  5. 决策指导                                         │   │
│  │  "何时使用子代理：- 需要读很多文件..."               │   │
│  │  → AI 知道何时用高级功能                             │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3.3 逐段解析

#### 第 1 段：角色定义

```python
"你是一个位于 {os.getcwd()} 的 CLI 代理。"
```

**元素分析：**

| 元素 | 作用 | 示例值 |
|------|------|--------|
| `你` | 人称，建立对话关系 | - |
| `是一个` | 身份断言 | 明确性 |
| `位于 {cwd}` | 上下文定位 | `/Users/jiezhou/project` |
| `CLI 代理` | 角色类型 | 命令行界面助手 |

**动态上下文的价值：**

```python
# 不同目录下，prompt 自动适应

# 在 /home/user/project
"你是一个位于 /home/user/project 的 CLI 代理。"
     ↑
   AI 知道这是项目目录

# 在 /etc
"你是一个位于 /etc 的 CLI 代理。"
     ↑
   AI 知道这是系统配置目录
```

#### 第 2 段：核心任务

```python
"使用 bash 命令解决问题。"
```

**简洁而有力：**

```
使用      → 方法
bash 命令 → 工具
解决问题  → 目标
```

**为什么不说"请帮助用户做各种事情"？**

```
❌ 太模糊：
"请帮助用户完成各种任务"
     ↑
   AI 可能不知道该用什么方法

✅ 明确方法：
"使用 bash 命令解决问题"
     ↑
   AI 知道必须通过 bash
```

#### 第 3 段：行为规则

```python
"- 优先使用工具而非文字。先行动，后简要解释。"
```

**两个关键原则：**

```
┌─────────────────────────────────────────────────────────────┐
│  原则 1：工具优先                                           │
├─────────────────────────────────────────────────────────────┤
│  "优先使用工具而非文字"                                      │
│                                                             │
│  User: "有多少个 Python 文件？"                              │
│                                                             │
│  ❌ 不好的响应：                                             │
│  "我来帮你检查..."  (纯文字)                                │
│                                                             │
│  ✅ 好的响应：                                              │
│  $ ls *.py  (先执行工具)                                    │
│  "有 3 个 Python 文件"  (后解释)                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│  原则 2：行动优先                                           │
├─────────────────────────────────────────────────────────────┤
│  "先行动，后简要解释"                                        │
│                                                             │
│  行动：$ cat file.py                                        │
│  解释："这是 file.py 的内容"  ← 简短                        │
│                                                             │
│  而不是：                                                   │
│  解释："我将使用 cat 命令来查看 file.py 文件的内容..."  ← 啰嗦│
│  行动：$ cat file.py                                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 第 4 段：能力清单

```python
"- 读文件: cat, grep, find, rg, ls, head, tail"
"- 写文件: echo '...' > file, sed -i, 或 cat << 'EOF' > file"
```

**与工具描述的关系：**

```
┌─────────────────────────────────────────────────────────────┐
│  工具描述 vs System Prompt                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  工具描述 (TOOL.description)                                │
│  "读取: cat/head/tail, grep/find/rg/ls, wc -l"              │
│  ↓                                                            │
│  作用：让 AI 知道 bash 工具的能力                            │
│  触发：AI 决定调用 bash 时参考                               │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  System Prompt                                              │
│  "- 读文件: cat, grep, find, rg, ls, head, tail"           │
│  ↓                                                            │
│  作用：让 AI 知道整体工作方式                                │
│  触发：AI 思考如何响应时参考                                 │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  两者协同：                                                 │
│  1. System Prompt 告诉 AI"可以用 cat 读取"                  │
│  2. 工具描述告诉 AI"调用 bash 时参数是 cat file.py"         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 第 5 段：子代理说明

```python
"- 子代理：对于复杂的子任务，生成子代理以保持上下文干净：
  python3 v0_bash_agent_glm.py '探索 src/ 并总结架构'"
```

**完整的信息结构：**

```
┌─────────────────────────────────────────────────────────────┐
│  子代理说明的三层信息                                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  第 1 层：用途                                              │
│  "对于复杂的子任务"                                         │
│      ↓                                                      │
│  回答：什么时候用？                                         │
│                                                             │
│  第 2 层：好处                                              │
│  "保持上下文干净"                                           │
│      ↓                                                      │
│  回答：为什么用？                                           │
│                                                             │
│  第 3 层：方法                                              │
│  "python3 v0_bash_agent_glm.py '...'"                       │
│      ↓                                                      │
│  回答：怎么用？                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 第 6 段：决策指导

```python
"何时使用子代理：
- 任务需要读取很多文件（隔离探索过程）
- 任务是独立且自包含的
- 你希望避免用中间细节污染当前对话"
```

**决策树形式化：**

```
用户请求
    │
    ├─ 是简单任务？
    │   └─ Yes → 直接处理
    │
    ├─ 需要读很多文件？
    │   └─ Yes → 使用子代理
    │
    ├─ 任务是独立且自包含？
    │   └─ Yes → 使用子代理
    │
    └─ 需要避免中间细节污染？
        └─ Yes → 使用子代理
```

**每个条件的分析：**

| 条件 | 原因 | 示例 |
|------|------|------|
| 需要读很多文件 | 保持主对话简洁 | "分析整个项目结构" |
| 任务独立且自包含 | 可以隔离处理 | "统计代码行数" |
| 避免中间细节 | 减少噪音 | "总结所有错误日志" |

#### 第 7 段：结果预期

```python
"子代理在隔离中运行，仅返回最终摘要。"
```

**关键信息：**

```
┌─────────────────────────────────────────────────────────────┐
│  "仅返回最终摘要" 的含义                                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  用户：分析 src/ 目录                                       │
│     ↓                                                       │
│  主代理：生成子代理                                          │
│     $ python3 v0_bash_agent.py "分析 src/"                  │
│           ↓                                                 │
│  子代理：$ find src/ -name "*.py"                           │
│         $ cat src/main.py                                   │
│         $ cat src/utils.py                                 │
│         $ cat src/api.py                                   │
│         ... (执行了很多命令)                                │
│           ↓                                                 │
│  子代理返回："src/ 目录包含 3 个文件：main.py 是入口..."    │
│                  ↑                                          │
│            最终摘要（不是所有中间输出）                      │
│           ↓                                                 │
│  主代理接收：简洁的摘要，不是 100 行命令输出                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. 提示词设计原则

### 4.1 简洁原则

```python
✅ 好的提示词：
"使用 bash 命令解决问题。"

❌ 不好的提示词：
"你应该利用 bash 命令行工具来帮助用户解决他们在使用计算机过程中遇到的各种问题和挑战..."
```

**简洁的好处：**
- 减少 token 消耗
- 降低理解难度
- 提高响应速度

### 4.2 明确原则

```python
✅ 明确：
"- 优先使用工具而非文字"

❌ 模糊：
"- 你应该尽量多用工具"
```

### 4.3 示例原则

```python
✅ 带示例：
"echo 'content' > file"

❌ 无示例：
"向文件写入内容"
```

### 4.4 结构化原则

```python
✅ 结构化：
"规则：
- 读文件: cat, grep, find
- 写文件: echo, sed
- 子代理: python3 ..."

❌ 非结构化：
"你可以读取文件，使用 cat 或 grep 等命令，也可以写文件，用 echo，或者生成子代理..."
```

---

## 5. 提示词工程技巧

### 5.1 动态上下文注入

```python
SYSTEM = f"""你是一个位于 {os.getcwd()} 的 CLI 代理..."""
                               ↑
                        运行时动态计算
```

**价值：**
- 每个目录下有不同的上下文
- AI 能理解当前工作环境
- 支持相对路径操作

### 5.2 分层提示

```
System Prompt (高层规则)
    ↓
Tool Description (工具细节)
    ↓
User Message (具体任务)
```

**分层的好处：**
- 每层职责清晰
- 便于单独优化
- 减少 prompt 长度

### 5.3 Few-Shot 示例

虽然没有显式的 few-shot，但工具描述中的示例起到了类似作用：

```python
"python3 v0_bash_agent_glm.py '探索 src/ 并总结架构'"
                     ↑
                提供了具体的调用示例
```

### 5.4 约束描述

```python
"仅返回最终摘要"
   ↑
 明确约束，防止 AI 返回过多信息
```

---

## 6. 对比实验

### 实验 1：有无子代理指导

| 版本 | Prompt | 任务：分析项目 |
|------|--------|----------------|
| A | 无子代理说明 | 直接读取所有文件，主对话混乱 |
| B | 有子代理说明 | 生成子代理，主对话简洁 |

### 实验 2：有无示例

| 版本 | 工具描述 | AI 行为 |
|------|----------|---------|
| A | "读取文件" | 尝试各种命令，效率低 |
| B | "读取: cat, grep, find" | 直接使用合适命令 |

### 实验 3：有无决策指导

| 版本 | 决策说明 | 子代理调用 |
|------|----------|-----------|
| A | 无 | 随机，有时过度使用 |
| B | 明确条件 | 准确，只在需要时使用 |

---

## 7. 优化建议

### 建议 1：添加错误处理指导

```python
# 当前版本没有明确说明如何处理错误

# 建议添加：
"错误处理：
- 命令失败时，分析错误原因
- 尝试替代方案
- 向用户解释问题"
```

### 建议 2：添加输出格式

```python
# 建议添加：
"输出格式：
- 命令输出：直接显示
- 分析结果：简洁总结
- 错误信息：清晰说明"
```

### 建议 3：添加安全提示

```python
# 建议添加：
"安全注意：
- 避免破坏性操作（rm, mkfs 等）
- 确认危险命令前先说明
- 优先使用只读命令"
```

---

## 总结

### 提示词的核心要素

```
┌─────────────────────────────────────────────────────────────┐
│                  优秀提示词的要素                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 清晰的角色定义                                          │
│     "你是一个 CLI 代理"                                     │
│                                                             │
│  2. 明确的任务目标                                          │
│     "使用 bash 解决问题"                                    │
│                                                             │
│  3. 具体的行为规则                                          │
│     "优先工具，先行动后解释"                                │
│                                                             │
│  4. 完整的能力清单                                          │
│     "读: cat, grep | 写: echo, sed"                         │
│                                                             │
│  5. 清晰的决策指导                                          │
│     "何时使用子代理：需读很多文件"                          │
│                                                             │
│  6. 明确的结果预期                                          │
│     "子代理仅返回摘要"                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 关键洞察

1. **工具描述和 System Prompt 协同工作**
2. **示例是最好的文档**
3. **明确的约束比模糊的建议更有效**
4. **分层设计让提示词更清晰**
5. **动态上下文让 AI 更智能**

---

[← 返回 README](../README_zh.md) | [→ 代码精读](./v0-GLM版本代码精读.md)
