# v2 核心代码/核心能力解析

**一句话看懂 v2：让模型的"脑海中的计划"变成可见的任务列表**

---

## 什么是 v2？

```
v1: 模型在"脑子里"计划（你看不到）
v2: 模型把计划写在"白板"上（你能看到）

这个"白板"就是 TodoWrite 工具
```

---

## 核心能力：让计划可见

### 问题：v1 的"隐形计划"

```
用户: "重构认证、添加测试、更新文档"

v1 模型（内心独白）:
"我先做 A... 然后做 B... 然后做 C..."
      ↑
   你看不到！

10 轮工具调用后:
"等等，我做到哪了？"
```

### 解决：v2 的"显式计划"

```
用户: "重构认证、添加测试、更新文档"

v2 模型:
TodoWrite([
  {content: "重构认证模块", status: "in_progress"},
  {content: "添加单元测试", status: "pending"},
  {content: "更新文档", status: "pending"}
])
      ↑
   你能看到！
```

---

## 三个核心组件

### 1️⃣ TodoManager - 任务管理器

```python
class TodoManager:
    """管理任务列表"""

    def update(self, items):
        """
        验证并保存任务列表

        约束规则：
        - 最多 20 个任务
        - 只能有一个 in_progress
        - 每个任务必须有 content, status, activeForm
        """
        # 验证...
        self.items = validated
        return self.render()  # 返回可读文本

    def render(self):
        """
        渲染为人类可读格式

        [x] 已完成
        [>] 进行中 <- 正在做什么...
        [ ] 待办

        (1/3 已完成)
        """
```

### 2️⃣ TodoWrite 工具

```python
{
    "name": "TodoWrite",
    "description": "更新任务列表",
    "parameters": {
        "items": [
            {
                "content": "任务描述",      # 要做什么
                "status": "in_progress",   # pending/in_progress/completed
                "activeForm": "正在做..."  # 现在时态
            }
        ]
    }
}
```

### 3️⃣ 软提醒机制

```python
# 对话开始时
INITIAL_REMINDER = "请先规划，再执行"

# 10轮没更新todo时
NAG_REMINDER = "请更新你的任务列表"
```

---

## 核心代码流程

```python
# ==================== 完整流程 ====================

# 1. 初始化
TODO = TodoManager()  # 创建任务管理器

# 2. 模型调用 TodoWrite
TodoWrite(items=[
    {"content": "读取文件", "status": "in_progress", "activeForm": "正在读取文件"},
    {"content": "修改代码", "status": "pending", "activeForm": "准备修改代码"}
])

# 3. TodoManager 验证并渲染
TODO.update(items)
# → [>] 读取文件 <- 正在读取文件
# → [ ] 修改代码
# → (0/2 已完成)

# 4. 渲染结果返回给模型
# 模型看到自己的任务列表，继续执行

# 5. 完成第一个任务
TodoWrite(items=[
    {"content": "读取文件", "status": "completed", "activeForm": "已读取文件"},
    {"content": "修改代码", "status": "in_progress", "activeForm": "正在修改代码"}
])
# → [x] 读取文件
# → [>] 修改代码 <- 正在修改代码
# → (1/2 已完成)
```

---

## 实际运行示例

```
You: 帮我分析这个项目的结构

AI: 我来创建一个分析计划

> TodoWrite: [
    {"content": "列出目录文件", "status": "in_progress", "activeForm": "正在列出目录文件"},
    {"content": "读取主要文件", "status": "pending", "activeForm": "准备读取主要文件"},
    {"content": "总结架构", "status": "pending", "activeForm": "准备总结架构"}
  ]

[>] 列出目录文件 <- 正在列出目录文件
[ ] 读取主要文件
[ ] 总结架构

(0/3 已完成)

> bash: dir
  v0_bash_agent.py
  v1_basic_agent_glm.py
  ...

> TodoWrite: [
    {"content": "列出目录文件", "status": "completed", "activeForm": "已列出目录文件"},
    {"content": "读取主要文件", "status": "in_progress", "activeForm": "正在读取主要文件"},
    {"content": "总结架构", "status": "pending", "activeForm": "准备总结架构"}
  ]

[x] 列出目录文件
[>] 读取主要文件 <- 正在读取主要文件
[ ] 总结架构

(1/3 已完成)

> read_file: v1_basic_agent_glm.py
  ...文件内容...

> TodoWrite: [
    {"content": "列出目录文件", "status": "completed", ...},
    {"content": "读取主要文件", "status": "completed", ...},
    {"content": "总结架构", "status": "in_progress", "activeForm": "正在总结架构"}
  ]

[x] 列出目录文件
[x] 读取主要文件
[>] 总结架构 <- 正在总结架构

(2/3 已完成)

这个项目包含：
- v0: 极简 bash 代理
- v1: 四工具代理
- ...总结完成
```

---

## 三个关键约束

```python
# 约束 1: 最多 20 项
if len(items) > 20:
    raise ValueError("最多 20 个 todos")

# 约束 2: 只能一个 in_progress
in_progress_count = sum(1 for t in items if t["status"] == "in_progress")
if in_progress_count > 1:
    raise ValueError("一次只能有一个任务进行中")

# 约束 3: 必填字段
for item in items:
    if not item.get("content") or not item.get("activeForm"):
        raise ValueError("content 和 activeForm 是必需的")
```

### 为什么需要约束？

```
┌─────────────────────────────────────┐
│      约束不是限制，是脚手架           │
├─────────────────────────────────────┤
│                                     │
│  没有约束：                          │
│  - 模型可能创建 100 个任务           │
│  - 同时做 10 件事                    │
│  - 任务描述模糊                      │
│  → 混乱、不可控                     │
│                                     │
│  有约束：                            │
│  - 最多 20 项 → 计划聚焦             │
│  - 一个进行中 → 强制专注             │
│  - 必填字段 → 结构清晰               │
│  → 有序、可控                       │
│                                     │
└─────────────────────────────────────┘
```

---

## v1 vs v2 对比

| 方面 | v1 | v2 |
|------|----|----|
| **计划可见性** | ❌ 不可见 | ✅ 可见 |
| **进度跟踪** | ❌ 无 | ✅ 实时显示 |
| **任务数量** | 无限制 | 最多 20 个 |
| **并行任务** | 可能多个 | 强制单一 |
| **适用场景** | 简单任务 | 复杂任务 |

---

## 如何让模型做规划？

### 方式 1：简单提问（新版会自动规划）
```
You: 帮我分析这个项目
→ 模型自动创建 TodoWrite
```

### 方式 2：明确步骤
```
You: 帮我分析项目：1. 列出文件 2. 读取主要文件 3. 总结
→ 模型按你指定的步骤规划
```

### 方式 3：显式要求
```
You: 请先创建任务计划，然后分析项目
→ 模型先规划，再执行
```

---

## 核心代码片段

### TodoManager 的核心逻辑

```python
class TodoManager:
    def __init__(self):
        self.items = []  # 任务列表

    def update(self, items: list) -> str:
        """验证并更新任务列表"""
        validated = []
        in_progress = 0

        # 验证每个任务
        for i, item in enumerate(items):
            content = item.get("content", "").strip()
            status = item.get("status", "pending").lower()
            active = item.get("activeForm", "").strip()

            # 必填字段检查
            if not content or not active:
                raise ValueError(f"任务 {i}: 缺少必填字段")

            # 状态检查
            if status not in ["pending", "in_progress", "completed"]:
                raise ValueError(f"任务 {i}: 无效状态")

            # 统计进行中任务
            if status == "in_progress":
                in_progress += 1

            validated.append({"content": content, "status": status, "activeForm": active})

        # 全局约束
        if len(validated) > 20:
            raise ValueError("最多 20 个任务")
        if in_progress > 1:
            raise ValueError("只能有一个任务进行中")

        self.items = validated
        return self.render()

    def render(self) -> str:
        """渲染为可读文本"""
        if not self.items:
            return "没有任务"

        lines = []
        for item in self.items:
            if item["status"] == "completed":
                lines.append(f"[x] {item['content']}")
            elif item["status"] == "in_progress":
                lines.append(f"[>] {item['content']} <- {item['activeForm']}")
            else:
                lines.append(f"[ ] {item['content']}")

        completed = sum(1 for t in self.items if t["status"] == "completed")
        lines.append(f"\n({completed}/{len(self.items)} 已完成)")

        return "\n".join(lines)
```

### 提醒机制的核心逻辑

```python
# 全局计数器
rounds_without_todo = 0

def agent_loop(messages):
    global rounds_without_todo

    while True:
        # 调用模型...
        response = client.chat.completions.create(...)

        # 检查是否使用了 TodoWrite
        used_todo = any(tc.name == "TodoWrite" for tc in msg.tool_calls)

        # 更新计数器
        if used_todo:
            rounds_without_todo = 0  # 使用了，重置
        else:
            rounds_without_todo += 1  # 没使用，递增

        # 超过 10 轮没有使用，注入提醒
        if rounds_without_todo > 10:
            messages.append({"role": "user", "content": NAG_REMINDER})
```

---

## 为什么 v2 重要？

```
┌─────────────────────────────────────────┐
│        v2 解决的核心问题                 │
├─────────────────────────────────────────┤
│                                         │
│  问题 1: 上下文淡化                      │
│  → 解决：计划可见，模型知道自己在哪       │
│                                         │
│  问题 2: 任务遗忘                        │
│  → 解决：completed 标记，知道做了什么     │
│                                         │
│  问题 3: 缺乏聚焦                        │
│  → 解决：一个 in_progress，强制专注       │
│                                         │
│  问题 4: 进度不可见                      │
│  → 解决：render() 显示实时进度           │
│                                         │
└─────────────────────────────────────────┘
```

---

## 快速上手

```bash
# 运行 v2
python v2_todo_agent_glm.py

# 提问示例
You: 帮我分析这个项目

# 模型会自动：
# 1. 创建 TodoWrite 计划
# 2. 执行任务
# 3. 更新进度
# 4. 完成后总结
```

---

[← 返回 README](../README_zh.md) | [→ 完整代码精读](./v2-Todo版本代码精读.md)
