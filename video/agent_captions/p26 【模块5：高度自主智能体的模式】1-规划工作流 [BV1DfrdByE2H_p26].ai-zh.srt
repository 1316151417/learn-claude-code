1
00:00:00,060 --> 00:00:01,680
欢迎来到本模块的最后一部分

2
00:00:01,680 --> 00:00:07,250
在这里你将学习设计模式，让你能够构建高度自主的智能体

3
00:00:07,250 --> 00:00:09,510
无需预先硬编码具体步骤

4
00:00:09,510 --> 00:00:11,330
需要执行的步骤序列

5
00:00:11,330 --> 00:00:15,450
它们可以更灵活地自主决定所需采取的步骤

6
00:00:15,450 --> 00:00:16,920
以完成某项任务

7
00:00:16,920 --> 00:00:19,000
我们将讨论规划设计模式

8
00:00:19,000 --> 00:00:22,540
随后在本模块中讲解如何构建多智能体系统

9
00:00:22,540 --> 00:00:23,710
让我们开始探索

10
00:00:23,710 --> 00:00:26,570
假设你经营一家太阳镜零售店

11
00:00:26,570 --> 00:00:31,110
并拥有库存中太阳镜的信息

12
00:00:31,110 --> 00:00:32,709
存储在数据库中

13
00:00:32,709 --> 00:00:36,189
你可能需要客服智能体回答问题

14
00:00:36,189 --> 00:00:39,900
比如是否有库存的圆形太阳镜或价格低于一百美元

15
00:00:39,900 --> 00:00:41,820
这是一个较为复杂的查询

16
00:00:41,820 --> 00:00:46,480
因为需要浏览产品描述以确定相关太阳镜

17
00:00:46,480 --> 00:00:48,640
然后查看库存情况

18
00:00:48,640 --> 00:00:53,260
最后确认价格是否低于一百美元以告知客户

19
00:00:53,260 --> 00:00:53,680
是的

20
00:00:53,680 --> 00:00:55,540
我们有经典款太阳镜

21
00:00:55,540 --> 00:01:01,280
如何构建能够回答此类广泛客户查询的智能体

22
00:01:01,280 --> 00:01:03,680
以及处理许多其他类似查询

23
00:01:03,680 --> 00:01:08,730
我们将为语言模型提供一组工具，使其能够获取商品描述

24
00:01:08,730 --> 00:01:12,519
例如查询不同款式太阳镜、检查库存

25
00:01:12,519 --> 00:01:14,359
可能处理商品退货

26
00:01:14,359 --> 00:01:15,939
这在当前查询中并不需要

27
00:01:15,939 --> 00:01:17,679
但对其他查询是必需的

28
00:01:17,679 --> 00:01:18,859
获取商品价格

29
00:01:18,859 --> 00:01:20,410
查看历史交易记录

30
00:01:20,410 --> 00:01:22,160
处理商品销售

31
00:01:22,160 --> 00:01:23,200
等等

32
00:01:23,200 --> 00:01:28,580
为了让语言模型确定使用工具的正确顺序

33
00:01:28,580 --> 00:01:30,910
以响应客户请求

34
00:01:30,910 --> 00:01:33,680
你可能会编写如下提示

35
00:01:33,680 --> 00:01:35,400
你拥有以下工具

36
00:01:35,400 --> 00:01:38,560
然后为每个工具（如六个工具）提供描述

37
00:01:38,560 --> 00:01:40,870
或更多智能体可用的工具

38
00:01:40,870 --> 00:01:46,570
并指示其返回逐步执行用户请求的计划

39
00:01:46,570 --> 00:01:49,710
在此案例中回答特定查询

40
00:01:49,710 --> 00:01:52,490
一个合理的计划可能是

41
00:01:52,490 --> 00:01:57,460
首先使用获取商品描述检查不同描述

42
00:01:57,460 --> 00:01:59,080
以找到圆形太阳镜

43
00:01:59,080 --> 00:02:02,210
然后使用检查库存确认存在并停止

44
00:02:02,210 --> 00:02:06,270
使用获取商品价格确认价格是否低于一百美元

45
00:02:06,270 --> 00:02:10,519
当语言模型输出包含三个步骤的计划后

46
00:02:10,519 --> 00:02:14,099
接下来可以提取第一步文本

47
00:02:14,099 --> 00:02:18,250
即此处红色标注的文本传递给语言模型

48
00:02:18,250 --> 00:02:22,210
可能附加用户查询的工具信息

49
00:02:22,210 --> 00:02:27,270
结合背景上下文和任务指令执行第一步

50
00:02:27,270 --> 00:02:31,689
在此情况下希望智能体会调用获取商品描述

51
00:02:31,689 --> 00:02:34,130
为了获取物品的适当描述

52
00:02:34,130 --> 00:02:39,750
第一步的输出可以让它选择圆形太阳镜

53
00:02:39,750 --> 00:02:44,730
第一步的输出随后与第二步结合

54
00:02:44,730 --> 00:02:46,590
这些就是指令

55
00:02:46,590 --> 00:02:50,589
我在这里用蓝色标注给lm执行计划第二步

56
00:02:50,589 --> 00:02:55,540
希望它会调取上一张幻灯片找到的两副圆形太阳镜

57
00:02:55,540 --> 00:02:56,980
并检查库存

58
00:02:56,980 --> 00:03:02,330
第二步的输出随后用于另一个lm调用

59
00:03:02,330 --> 00:03:04,030
包含第二步的输出结果

60
00:03:04,030 --> 00:03:06,850
以及第三步的执行指令

61
00:03:06,850 --> 00:03:08,530
传递给lm使其

62
00:03:08,530 --> 00:03:09,630
获取物品价格

63
00:03:09,630 --> 00:03:16,090
最终这个输出再次反馈生成最终用户答案

64
00:03:16,090 --> 00:03:16,950
在本张幻灯片中

65
00:03:16,950 --> 00:03:19,350
我简化了很多细节

66
00:03:19,350 --> 00:03:24,340
lm实际编写的计划比简单指令更详细

67
00:03:24,340 --> 00:03:26,760
但基本流程是让lm

68
00:03:26,760 --> 00:03:28,480
写出多步骤计划

69
00:03:28,480 --> 00:03:31,840
然后执行计划的每个步骤

70
00:03:31,840 --> 00:03:36,170
并结合任务相关上下文

71
00:03:36,170 --> 00:03:38,460
可用工具等信息

72
00:03:38,460 --> 00:03:42,440
使用elm进行这种规划的亮点

73
00:03:42,440 --> 00:03:45,490
是我们无需预先决定

74
00:03:45,490 --> 00:03:48,490
工具调用的顺序

75
00:03:48,490 --> 00:03:52,190
以回答较为复杂的客户请求

76
00:03:52,190 --> 00:03:55,070
如果客户提出不同请求

77
00:03:55,070 --> 00:04:00,170
例如我想退购之前购买的金框眼镜

78
00:04:00,170 --> 00:04:02,200
但不是金属框的

79
00:04:02,200 --> 00:04:06,920
可以想象lm同样能制定不同计划

80
00:04:06,920 --> 00:04:09,760
根据之前购买记录判断

81
00:04:09,760 --> 00:04:11,380
用户购买了哪些眼镜

82
00:04:11,380 --> 00:04:14,800
基于获取金框眼镜的描述

83
00:04:14,800 --> 00:04:17,339
然后可能调用处理退货流程

84
00:04:17,339 --> 00:04:19,420
因此具备此类规划能力的代理

85
00:04:19,420 --> 00:04:24,829
可执行更广泛的任务并调用多种工具

86
00:04:24,829 --> 00:04:26,129
在不同顺序下

87
00:04:26,129 --> 00:04:27,729
另一个规划示例

88
00:04:27,729 --> 00:04:29,929
让我们看看邮件助手

89
00:04:29,929 --> 00:04:31,920
如果你想让我告诉助手

90
00:04:31,920 --> 00:04:34,920
请回复来自纽约鲍勃的邮件邀请

91
00:04:34,920 --> 00:04:36,620
十点十刻并归档他的邮件

92
00:04:36,620 --> 00:04:40,800
邮件助手可能拥有搜索邮件工具

93
00:04:40,800 --> 00:04:41,440
移动邮件

94
00:04:41,440 --> 00:04:43,220
删除邮件和发送邮件

95
00:04:43,220 --> 00:04:46,500
系统提示可能说明你拥有以下工具

96
00:04:46,500 --> 00:04:48,600
再次请返回分步计划

97
00:04:48,600 --> 00:04:49,320
在此案例中

98
00:04:49,320 --> 00:04:53,260
代理可能会说步骤是使用搜索邮件

99
00:04:53,260 --> 00:04:56,820
找到来自鲍勃提及晚餐和纽约的邮件

100
00:04:56,820 --> 00:04:59,840
然后生成并发送确认出席的邮件

101
00:04:59,840 --> 00:05:02,840
然后最后将这封邮件移动到存档文件夹

102
00:05:02,840 --> 00:05:03,660
基于此计划

103
00:05:03,660 --> 00:05:04,900
这看起来是一个合理的方案

104
00:05:04,900 --> 00:05:09,490
接下来你需要分步执行这个计划

105
00:05:09,490 --> 00:05:12,730
因此这里红色显示的第一步文本

106
00:05:12,730 --> 00:05:15,460
将被输入LMS并附加背景上下文

107
00:05:15,460 --> 00:05:17,480
然后希望你的触发搜索邮件

108
00:05:17,480 --> 00:05:20,560
然后可以将该输出结果提供给

109
00:05:20,560 --> 00:05:25,740
现在我又回到第二步指令，发送恰当的回复

110
00:05:25,740 --> 00:05:28,600
然后最后假设邮件发送成功

111
00:05:28,600 --> 00:05:31,200
你可以将该输出结果执行

112
00:05:31,200 --> 00:05:35,789
第三步将邮件从Bob移动到存档文件夹

113
00:05:35,789 --> 00:05:42,209
规划设计模式已在许多高效编码系统中成功应用

114
00:05:42,209 --> 00:05:47,340
如果你让它编写构建某个复杂应用的软件

115
00:05:47,340 --> 00:05:50,320
它可能会制定一个构建该组件的计划

116
00:05:50,320 --> 00:05:51,100
构建这个组件

117
00:05:51,100 --> 00:05:53,409
构建这个组件以形成类似清单

118
00:05:53,409 --> 00:05:54,669
然后依次执行这些步骤

119
00:05:54,669 --> 00:06:00,470
逐步构建许多其他应用的复杂软件

120
00:06:00,470 --> 00:06:04,070
规划的使用仍可能处于实验阶段

121
00:06:04,070 --> 00:06:06,240
尚未广泛普及

122
00:06:06,240 --> 00:06:08,930
规划的一个挑战是

123
00:06:08,930 --> 00:06:12,050
有时会让系统控制变得复杂

124
00:06:12,050 --> 00:06:13,390
作为开发者

125
00:06:13,390 --> 00:06:15,470
在运行时你并不清楚

126
00:06:15,470 --> 00:06:17,030
它会生成什么计划

127
00:06:17,030 --> 00:06:22,580
因此我认为在高度编码系统中效果显著

128
00:06:22,580 --> 00:06:25,909
规划在其他领域的采用仍在增长

129
00:06:25,909 --> 00:06:27,449
但这是一项令人兴奋的技术

130
00:06:27,449 --> 00:06:29,569
我相信它会不断改进

131
00:06:29,569 --> 00:06:32,200
并将出现在更多应用中

132
00:06:32,200 --> 00:06:35,360
构建能够自主规划的代理的酷处在于

133
00:06:35,360 --> 00:06:37,260
无需预先硬编码

134
00:06:37,260 --> 00:06:43,079
复杂任务的具体步骤序列

135
00:06:43,079 --> 00:06:46,919
我知道在这段视频中我已从较高层次讲解了规划过程

136
00:06:46,919 --> 00:06:48,819
输出步骤列表

137
00:06:48,819 --> 00:06:50,720
然后让LMS执行

138
00:06:50,720 --> 00:06:54,150
分步执行计划中的步骤

139
00:06:54,150 --> 00:06:57,270
但实际是如何运作的呢？下个视频见

140
00:06:57,270 --> 00:06:58,690
我们将深入探讨

141
00:06:58,690 --> 00:07:03,500
进一步了解这些计划的实际结构

142
00:07:03,500 --> 00:07:04,920
以及如何整合它们

143
00:07:04,920 --> 00:07:07,829
让L计划并为你执行计划

144
00:07:07,829 --> 00:07:10,049
让我们在下一视频中查看

