1
00:00:00,100 --> 00:00:02,380
在几个我参与的项目中

2
00:00:02,380 --> 00:00:05,680
我提供了编写代码的选项

3
00:00:05,680 --> 00:00:06,860
然后执行任务

4
00:00:06,860 --> 00:00:07,780
我希望它能够

5
00:00:07,780 --> 00:00:09,470
现在我已经尝试过几次

6
00:00:09,470 --> 00:00:13,650
我对生成的代码解决方案的巧妙程度感到非常惊讶和欣喜

7
00:00:13,650 --> 00:00:17,960
为了完成各种任务而生成的代码

8
00:00:17,960 --> 00:00:20,740
如果你还没有经常使用代码执行功能

9
00:00:20,740 --> 00:00:26,820
你可能会对这个能让你的应用实现的功能感到惊喜和欣喜

10
00:00:26,820 --> 00:00:27,880
让我们看看

11
00:00:27,880 --> 00:00:32,879
让我们以构建一个能处理数学题的应用为例

12
00:00:32,879 --> 00:00:35,539
文字问题并为你解答

13
00:00:35,539 --> 00:00:37,979
你可能会创建加法工具

14
00:00:37,979 --> 00:00:38,739
减法工具

15
00:00:38,739 --> 00:00:40,920
乘法工具和定义数字工具

16
00:00:40,920 --> 00:00:43,640
如果有人要求请计算十三点二加十八点九

17
00:00:43,640 --> 00:00:45,220
就会触发加法工具

18
00:00:45,220 --> 00:00:47,020
然后得到正确答案

19
00:00:47,020 --> 00:00:48,680
但假如有人输入

20
00:00:48,680 --> 00:00:50,269
什么是√2的平方根

21
00:00:50,269 --> 00:00:50,649
嗯

22
00:00:50,649 --> 00:00:53,969
你可以编写一个新的平方根工具

23
00:00:53,969 --> 00:00:58,660
但可能还需要处理指数运算

24
00:00:58,660 --> 00:00:59,520
事实上

25
00:00:59,520 --> 00:01:03,540
观察现代科学计算器的按键数量

26
00:01:03,540 --> 00:01:06,460
需要为每个按键创建单独的工具

27
00:01:06,460 --> 00:01:10,370
以及我们想要进行的更多数学计算

28
00:01:10,370 --> 00:01:14,820
与其逐一实现这些功能

29
00:01:14,820 --> 00:01:20,650
另一种方法是让系统自动生成并执行代码来指导算法

30
00:01:20,650 --> 00:01:22,050
你可以这样编写提示

31
00:01:22,050 --> 00:01:24,150
编写代码解决用户的查询

32
00:01:24,150 --> 00:01:26,710
将答案作为Python代码返回

33
00:01:26,710 --> 00:01:30,779
用执行python和闭合标签包裹

34
00:01:30,779 --> 00:01:36,640
例如当用户询问√2的值时

35
00:01:36,640 --> 00:01:38,620
然后使用模式匹配

36
00:01:38,620 --> 00:01:39,180
例如

37
00:01:39,180 --> 00:01:42,530
用正则表达式查找起始和结束标签

38
00:01:42,530 --> 00:01:46,730
提取中间的代码

39
00:01:46,730 --> 00:01:50,310
这里可以看到绿色方框中的两行代码

40
00:01:50,310 --> 00:01:54,400
接着执行这段代码并获取结果

41
00:01:54,400 --> 00:01:56,020
在这种情况下得到1.4

42
00:01:56,020 --> 00:01:56,240
一

43
00:01:56,240 --> 00:01:56,800
四二

44
00:01:56,800 --> 00:01:57,680
依此类推

45
00:01:57,680 --> 00:01:58,509
最后

46
00:01:58,509 --> 00:02:01,989
这个数值结果会返回给主程序

47
00:02:01,989 --> 00:02:06,200
然后生成格式美观的答案

48
00:02:06,200 --> 00:02:09,620
代码执行步骤有多种实现方式

49
00:02:09,620 --> 00:02:13,520
一种方法是使用Python的exec函数

50
00:02:13,520 --> 00:02:15,200
这是Python内置函数

51
00:02:15,200 --> 00:02:17,910
将执行你传入的任何代码

52
00:02:17,910 --> 00:02:21,810
这对于编写自己的正确代码非常强大

53
00:02:21,810 --> 00:02:24,049
并让你执行这段代码

54
00:02:24,049 --> 00:02:28,980
尽管存在一些安全影响，我们稍后会在视频中看到

55
00:02:28,980 --> 00:02:29,480
然后

56
00:02:29,480 --> 00:02:34,640
还有一些工具可以让你在更安全的沙盒环境中运行代码

57
00:02:34,640 --> 00:02:35,120
而且

58
00:02:35,120 --> 00:02:35,560
当然

59
00:02:35,560 --> 00:02:38,360
平方根二是一个相对简单的例子

60
00:02:38,360 --> 00:02:41,210
我也能准确编写代码来

61
00:02:41,210 --> 00:02:41,770
例如

62
00:02:41,770 --> 00:02:48,340
进行利息计算并解决比这更复杂的数学问题

63
00:02:48,340 --> 00:02:49,980
这一理念的一个改进

64
00:02:49,980 --> 00:02:55,790
正如我们在反射部分看到的，如果代码执行失败

65
00:02:55,790 --> 00:02:57,210
所以如果出于某种原因

66
00:02:57,210 --> 00:02:59,870
生成的代码并不完全正确

67
00:02:59,870 --> 00:03:04,210
将错误信息返回给语言模型，让它进行反思

68
00:03:04,210 --> 00:03:07,530
并可能修改代码再试一两次

69
00:03:07,530 --> 00:03:12,030
这有时也能得到更准确的答案

70
00:03:12,030 --> 00:03:19,840
运行任意代码确实存在小概率引发问题

71
00:03:19,840 --> 00:03:24,500
最近我的团队成员使用了一个高度编码器

72
00:03:24,500 --> 00:03:30,120
它实际上选择删除了项目目录中的星号派

73
00:03:30,120 --> 00:03:31,700
确实有一个真实案例

74
00:03:31,700 --> 00:03:34,420
最终该解码器确实道歉了

75
00:03:34,420 --> 00:03:35,140
是的

76
00:03:35,140 --> 00:03:35,660
确实没错

77
00:03:35,660 --> 00:03:36,960
这真是个极其愚蠢的错误

78
00:03:36,960 --> 00:03:37,440
可能吧

79
00:03:37,440 --> 00:03:37,780
呃

80
00:03:37,780 --> 00:03:40,800
我很高兴这个代理解码器真的道歉了

81
00:03:40,800 --> 00:03:43,360
但我已经删除了很多Python文件

82
00:03:43,360 --> 00:03:46,120
不幸的是团队成员有GitHub仓库备份

83
00:03:46,120 --> 00:03:47,800
所以没有造成实际损害

84
00:03:47,800 --> 00:03:49,280
但这样会很糟糕

85
00:03:49,280 --> 00:03:49,860
如果这个

86
00:03:49,860 --> 00:03:50,200
你知道的

87
00:03:50,200 --> 00:03:51,570
任意代码

88
00:03:51,570 --> 00:03:56,440
因错误删除大量文件的代码被执行且没有备份

89
00:03:56,440 --> 00:04:01,220
代码执行的最佳实践是运行在沙盒环境中

90
00:04:01,220 --> 00:04:06,140
实际上单行代码的风险并不高

91
00:04:06,140 --> 00:04:07,600
如果我说实话

92
00:04:07,600 --> 00:04:11,620
许多开发者会未经仔细检查就执行来自语言模型的代码

93
00:04:11,620 --> 00:04:14,230
但如果你想更安全

94
00:04:14,230 --> 00:04:20,139
最佳实践是创建沙盒，以防语言模型生成的代码有误

95
00:04:20,139 --> 00:04:25,050
可降低数据丢失或敏感数据泄露等风险

96
00:04:25,050 --> 00:04:27,550
沙盒环境如Docker

97
00:04:27,550 --> 00:04:31,680
或e2b是轻量级沙盒环境

98
00:04:31,680 --> 00:04:35,600
可降低任意代码执行的风险

99
00:04:35,600 --> 00:04:39,340
避免损害系统或环境

100
00:04:39,340 --> 00:04:42,280
事实证明代码执行非常重要

101
00:04:42,280 --> 00:04:46,320
许多语言模型的训练师实际上在做特殊工作

102
00:04:46,320 --> 00:04:50,470
确保代码执行在其应用中运行良好

103
00:04:50,470 --> 00:04:51,790
但我希望

104
00:04:51,790 --> 00:04:56,730
当你将其作为另一个工具添加到可提供给

105
00:04:56,730 --> 00:05:01,520
或让你的应用程序变得远更强大

106
00:05:01,520 --> 00:05:02,800
而我们讨论的内容

107
00:05:02,800 --> 00:05:08,240
你需要创建工具并逐步将其提供给你的语言模型

108
00:05:08,240 --> 00:05:11,700
结果发现许多团队在构建类似的工具

109
00:05:11,700 --> 00:05:17,879
不得不完成构建函数并使其对应用可用的所有工作

110
00:05:17,879 --> 00:05:24,170
但最近出现了一个新标准，称为MCP模型上下文协议

111
00:05:24,170 --> 00:05:28,609
这让开发者更容易访问大量工具集

112
00:05:28,609 --> 00:05:29,969
供ELM使用

113
00:05:29,969 --> 00:05:36,450
这是一个越来越被团队采用的重要协议，用于开发基于语言模型的应用

114
00:05:36,450 --> 00:05:39,710
让我们在下一视频中学习MCP

