1
00:00:00,120 --> 00:00:03,300
通过代码执行进行规划的核心思想是

2
00:00:03,300 --> 00:00:07,740
与其让算法输出JSON格式的计划

3
00:00:07,740 --> 00:00:09,460
逐步执行每个步骤

4
00:00:09,460 --> 00:00:10,720
为什么不让机械臂

5
00:00:10,720 --> 00:00:12,080
直接尝试编写代码

6
00:00:12,080 --> 00:00:15,340
而这段代码可以涵盖计划的多个步骤

7
00:00:15,340 --> 00:00:16,360
比如调用这个函数

8
00:00:16,360 --> 00:00:18,490
然后调用这个函数和这个函数

9
00:00:18,490 --> 00:00:21,470
通过执行语言模型生成的代码

10
00:00:21,470 --> 00:00:24,350
我们实际上可以执行较为复杂的计划

11
00:00:24,350 --> 00:00:27,570
让我们看看何时需要使用这种技术

12
00:00:27,570 --> 00:00:32,509
假设要构建一个回答咖啡机销售问题的系统

13
00:00:32,509 --> 00:00:36,910
基于包含历史销售数据的电子表格

14
00:00:36,910 --> 00:00:41,810
可能有一个配备这些工具的语言模型，比如获取列最大值

15
00:00:41,810 --> 00:00:44,530
查看特定列并获取最大值

16
00:00:44,530 --> 00:00:50,430
这有助于回答最贵的咖啡或获取列平均值、过滤行

17
00:00:50,430 --> 00:00:51,330
获取列最小值

18
00:00:51,330 --> 00:00:52,310
获取列中位数

19
00:00:52,310 --> 00:00:53,350
某些行等等

20
00:00:53,350 --> 00:00:55,450
这些都是各类工具的示例

21
00:00:55,450 --> 00:00:58,829
可能让语言模型处理这个电子表格

22
00:00:58,829 --> 00:01:02,399
或以不同方式处理这些行列数据

23
00:01:02,399 --> 00:01:06,599
如果用户询问哪种热巧克力销量最高

24
00:01:06,599 --> 00:01:09,500
发现可以使用这些工具回答此问题

25
00:01:09,500 --> 00:01:11,020
但过程相当复杂

26
00:01:11,020 --> 00:01:16,560
需用过滤行提取1月热巧克力交易数据

27
00:01:16,560 --> 00:01:17,970
然后进行统计分析

28
00:01:17,970 --> 00:01:19,530
接着对2月重复操作

29
00:01:19,530 --> 00:01:20,790
计算该月统计结果

30
00:01:20,790 --> 00:01:21,670
接着对3月重复操作

31
00:01:21,670 --> 00:01:22,350
对4月重复操作

32
00:01:22,350 --> 00:01:24,170
对5月到12月全部重复

33
00:01:24,170 --> 00:01:25,290
然后取最大值

34
00:01:25,290 --> 00:01:30,480
因此可以结合这些工具完成复杂流程

35
00:01:30,480 --> 00:01:33,570
但这并非理想方案

36
00:01:33,570 --> 00:01:34,270
更糟糕的是

37
00:01:34,270 --> 00:01:38,040
若有人询问上周唯一交易量

38
00:01:38,040 --> 00:01:38,320
嗯

39
00:01:38,320 --> 00:01:40,480
这些工具无法获取答案

40
00:01:40,480 --> 00:01:42,420
可能需要创建新工具

41
00:01:42,420 --> 00:01:43,640
获取唯一条目

42
00:01:43,640 --> 00:01:45,829
或遇到另一个查询

43
00:01:45,829 --> 00:01:47,849
最后五笔交易的金额是多少

44
00:01:47,849 --> 00:01:53,130
则需创建新工具获取数据

45
00:01:53,130 --> 00:01:57,760
实际中团队遇到更多查询时

46
00:01:57,760 --> 00:02:00,420
会不断创建更多工具

47
00:02:00,420 --> 00:02:04,080
试图覆盖所有需求

48
00:02:04,080 --> 00:02:06,649
有人可能询问类似数据集

49
00:02:06,649 --> 00:02:09,609
这种方法易碎且低效

50
00:02:09,609 --> 00:02:15,220
我见过团队持续处理边界情况并创建新工具

51
00:02:15,220 --> 00:02:17,400
但事实证明还有更好的方法

52
00:02:17,400 --> 00:02:20,910
那就是提示lm生成代码

53
00:02:20,910 --> 00:02:23,230
请编写代码解决用户的查询

54
00:02:23,230 --> 00:02:25,370
并将答案以Python代码返回

55
00:02:25,370 --> 00:02:28,180
可能用这些开头和结尾包裹

56
00:02:28,180 --> 00:02:30,240
执行Python XML标签

57
00:02:30,240 --> 00:02:37,530
然后只需加载电子表格到数据处理库

58
00:02:37,530 --> 00:02:39,290
这里使用pandas库

59
00:02:39,290 --> 00:02:42,470
然后它实际上正在制定计划

60
00:02:42,470 --> 00:02:44,770
计划是在加载CSV后

61
00:02:44,770 --> 00:02:45,130
首先

62
00:02:45,130 --> 00:02:48,270
必须确保日期列以正确方式处理

63
00:02:48,270 --> 00:02:49,570
然后按日期排序

64
00:02:49,570 --> 00:02:51,269
选择最后五笔交易

65
00:02:51,269 --> 00:02:53,309
仅显示价格列等内容

66
00:02:53,309 --> 00:02:54,629
但这些就是步骤

67
00:02:54,629 --> 00:02:54,969
第一步

68
00:02:54,969 --> 00:02:55,309
第二步

69
00:02:55,309 --> 00:02:56,529
第三、第四和第五步

70
00:02:56,529 --> 00:02:57,950
说明这个计划

71
00:02:57,950 --> 00:03:00,650
因为像Python这样的编程语言

72
00:03:00,650 --> 00:03:02,030
在这个例子中

73
00:03:02,030 --> 00:03:05,510
同时导入了pandas数据处理库

74
00:03:05,510 --> 00:03:08,410
因为其中包含大量内置函数

75
00:03:08,410 --> 00:03:10,270
数百甚至数千个函数

76
00:03:10,270 --> 00:03:17,710
而且这些函数lm见过大量调用数据

77
00:03:17,710 --> 00:03:20,290
当让自己的模型编写代码时

78
00:03:20,290 --> 00:03:24,150
可以从数百或数千个相关函数中选择

79
00:03:24,150 --> 00:03:27,420
这些函数已有大量数据表明何时使用

80
00:03:27,420 --> 00:03:33,790
因此可以组合不同函数调用来自大型库

81
00:03:33,790 --> 00:03:38,799
从而为回答复杂查询制定计划

82
00:03:38,799 --> 00:03:39,519
就像这样

83
00:03:39,519 --> 00:03:40,959
再举一个例子

84
00:03:40,959 --> 00:03:44,399
如果有人询问上周有多少笔唯一交易

85
00:03:44,399 --> 00:03:45,179
嗯

86
00:03:45,179 --> 00:03:48,510
它可以制定读取CSV文件的计划

87
00:03:48,510 --> 00:03:49,570
处理日期列

88
00:03:49,570 --> 00:03:51,330
定义时间窗口过滤行

89
00:03:51,330 --> 00:03:52,570
删除重复行

90
00:03:52,570 --> 00:03:54,550
这些细节并不重要

91
00:03:54,550 --> 00:03:58,280
但希望从注释中可以看出

92
00:03:58,280 --> 00:04:02,060
lm正在制定四步计划

93
00:04:02,060 --> 00:04:06,620
并将每一步用可执行代码表达

94
00:04:06,620 --> 00:04:09,360
这样就能得到用户答案

95
00:04:09,360 --> 00:04:14,840
对于可通过编写代码完成的任务

96
00:04:14,840 --> 00:04:20,750
让算法用可执行代码表达计划

97
00:04:20,750 --> 00:04:24,800
对lm来说是一种强大方式

98
00:04:24,800 --> 00:04:30,290
当然还需考虑模块和工具使用时的注意事项

99
00:04:30,290 --> 00:04:32,870
如果需要安全执行环境

100
00:04:32,870 --> 00:04:36,180
如沙盒运行代码并应用限制

101
00:04:36,180 --> 00:04:39,420
虽然我知道即使这可能不是最佳实践

102
00:04:39,420 --> 00:04:43,640
我也知道很多开发者不使用沙盒环境

103
00:04:43,640 --> 00:04:47,750
从这个图表可以看出，基于代码的规划效果很好

104
00:04:47,750 --> 00:04:50,990
改编自孙耀王等人的研究论文

105
00:04:50,990 --> 00:04:57,590
可以看到对于他们研究的多种任务模型，代码作为行动

106
00:04:57,590 --> 00:05:02,290
其中让语言模型编写代码并通过代码执行操作

107
00:05:02,290 --> 00:05:10,330
这比让其生成JSON再转换为行动或文本更优

108
00:05:10,330 --> 00:05:14,360
你也看到编写代码表现更优的趋势

109
00:05:14,360 --> 00:05:18,540
编写JSON计划同样更好，而纯文本计划效果也不错

110
00:05:18,540 --> 00:05:21,650
现在他们开始用纯文本编写计划

111
00:05:21,650 --> 00:05:26,950
当然有些场景需要提供自定义工具供模型学习使用

112
00:05:26,950 --> 00:05:31,230
因此编写代码并非适用于所有场景

113
00:05:31,230 --> 00:05:32,470
但当适用时

114
00:05:32,470 --> 00:05:35,570
这对神经网络表达计划非常有效

115
00:05:35,570 --> 00:05:39,220
今天的规划部分到这里就结束了

116
00:05:39,220 --> 00:05:42,480
AI最强大的应用场景之一

117
00:05:42,480 --> 00:05:46,240
就是高度软件编码规划

118
00:05:46,240 --> 00:05:47,280
事实证明

119
00:05:47,280 --> 00:05:51,200
如果你询问顶尖的软件编码辅助工具

120
00:05:51,200 --> 00:05:53,800
让它为你编写复杂软件

121
00:05:53,800 --> 00:05:58,370
它可能会先制定构建软件组件的详细计划

122
00:05:58,370 --> 00:06:00,270
然后构建第二个组件，再构建第三个

123
00:06:00,270 --> 00:06:03,490
甚至可能计划测试组件的进展

124
00:06:03,490 --> 00:06:08,330
随后形成检查清单逐步执行

125
00:06:08,330 --> 00:06:15,279
这对构建日益复杂的软件应用非常有效

126
00:06:15,279 --> 00:06:17,339
我认为规划的使用仍在增长

127
00:06:17,339 --> 00:06:21,150
规划的一个缺点是

128
00:06:21,150 --> 00:06:25,030
由于开发者未明确指示系统具体操作

129
00:06:25,030 --> 00:06:26,950
控制起来稍显困难

130
00:06:26,950 --> 00:06:29,750
且无法预知运行时的具体情况

131
00:06:29,750 --> 00:06:32,070
但放弃部分控制

132
00:06:32,070 --> 00:06:37,270
显著扩展了模型可尝试的范围

133
00:06:37,270 --> 00:06:41,010
这项关键技术仍处于前沿

134
00:06:41,010 --> 00:06:43,950
在某些领域尚未完全成熟

135
00:06:43,950 --> 00:06:46,570
可能在特定场景中表现良好

136
00:06:46,570 --> 00:06:48,690
尽管仍有很大发展空间

137
00:06:48,690 --> 00:06:52,910
但希望你在应用中能享受其价值

138
00:06:52,910 --> 00:06:56,140
今天的规划部分到此结束

139
00:06:56,140 --> 00:06:57,800
还有一个最后的设计模式

140
00:06:57,800 --> 00:06:59,720
希望在这模块与你分享

141
00:06:59,720 --> 00:07:02,300
如何构建多智能体系统

142
00:07:02,300 --> 00:07:03,900
我们不仅有一个智能体

143
00:07:03,900 --> 00:07:08,300
而是多个协作完成任务的智能体

144
00:07:08,300 --> 00:07:10,820
让我们在下一视频中了解

