1
00:00:00,100 --> 00:00:02,480
反思通常能提升系统的性能

2
00:00:02,480 --> 00:00:04,740
但在决定保留它之前

3
00:00:04,740 --> 00:00:08,400
我通常会先检查它实际提升了多少性能

4
00:00:08,400 --> 00:00:13,460
因为它需要多一步操作，可能会稍微拖慢系统

5
00:00:13,460 --> 00:00:16,430
让我们看看反射工作流的弊端

6
00:00:16,430 --> 00:00:18,950
让我们看一个使用反射的例子

7
00:00:18,950 --> 00:00:26,020
为了改进语言模型生成的数据库查询以获取数据回答问题

8
00:00:26,020 --> 00:00:27,620
假设你经营一家零售店

9
00:00:27,620 --> 00:00:33,600
可能会收到类似哪种颜色产品总销量最高的问题

10
00:00:33,600 --> 00:00:36,780
你可能让语言模型生成一个数据库查询

11
00:00:36,780 --> 00:00:39,800
如果你了解数据库语言如SQL

12
00:00:39,800 --> 00:00:40,560
SQL

13
00:00:40,560 --> 00:00:42,840
它可能会生成类似这种语言的查询

14
00:00:42,840 --> 00:00:44,520
但如果你不熟悉SQL

15
00:00:44,520 --> 00:00:45,240
不用担心

16
00:00:45,240 --> 00:00:48,080
但在编写数据库查询后

17
00:00:48,080 --> 00:00:52,180
而不是直接使用它从数据库获取信息

18
00:00:52,180 --> 00:00:53,780
你可能会有一个M

19
00:00:53,780 --> 00:00:55,050
版本不同

20
00:00:55,050 --> 00:00:56,450
对版本进行反思

21
00:00:56,450 --> 00:00:59,800
对一个数据库查询进行反思并改进为更好的版本

22
00:00:59,800 --> 00:01:04,959
然后执行该数据库查询从数据库获取信息

23
00:01:04,959 --> 00:01:07,280
最终由语言模型回答问题

24
00:01:07,280 --> 00:01:13,180
问题在于使用第二个语言模型进行反思和优化数据库

25
00:01:13,180 --> 00:01:14,300
或SQL查询

26
00:01:14,300 --> 00:01:16,960
是否真正提升了最终输出

27
00:01:16,960 --> 00:01:18,620
为了评估这一点

28
00:01:18,620 --> 00:01:24,820
我可能会收集一组问题或提示连同真实答案

29
00:01:24,820 --> 00:01:28,420
例如：2025年5月售出多少件商品

30
00:01:28,420 --> 00:01:30,840
库存中最贵的商品是什么

31
00:01:30,840 --> 00:01:33,530
我的店铺中有哪些款式在售

32
00:01:33,530 --> 00:01:37,410
可能准备十到十五个

33
00:01:37,410 --> 00:01:39,890
提示的真实答案

34
00:01:39,890 --> 00:01:44,190
然后运行无反射的工作流

35
00:01:44,190 --> 00:01:48,430
无反射意味着直接使用第一个语言模型生成的SQL查询

36
00:01:48,430 --> 00:01:50,460
并查看其返回的答案

37
00:01:50,460 --> 00:01:55,080
有反射则使用第二个模型优化后的查询

38
00:01:55,080 --> 00:01:56,280
M已对其进行了反思

39
00:01:56,280 --> 00:01:59,540
查看从数据库获取的答案

40
00:01:59,540 --> 00:02:06,580
然后测量无反射和有反射的正确率

41
00:02:06,580 --> 00:02:07,360
在这个例子中

42
00:02:07,360 --> 00:02:08,940
无反射正确率87%

43
00:02:08,940 --> 00:02:10,120
八七成时间正确

44
00:02:10,120 --> 00:02:12,660
有反射正确率95%

45
00:02:12,660 --> 00:02:19,910
这表明反射显著提升了数据库查询质量

46
00:02:19,910 --> 00:02:22,270
我能准确提取正确答案

47
00:02:22,270 --> 00:02:27,260
开发者常做的另一件事是修改反射提示

48
00:02:27,260 --> 00:02:28,080
例如

49
00:02:28,080 --> 00:02:34,220
是否添加反射提示和指令以加快数据库查询速度

50
00:02:34,220 --> 00:02:36,050
或使其更清晰

51
00:02:36,050 --> 00:02:39,410
或者你可能有不同的改写思路

52
00:02:39,410 --> 00:02:43,930
无论是初始生成提示还是反思提示

53
00:02:43,930 --> 00:02:45,950
一旦你设置了这样的恶意内容

54
00:02:45,950 --> 00:02:52,560
你可以快速尝试不同提示并测量系统正确率

55
00:02:52,560 --> 00:02:53,880
当你调整提示时

56
00:02:53,880 --> 00:02:57,620
为了了解哪些提示最适合你的应用

57
00:02:57,620 --> 00:03:00,420
所以如果你在尝试大量提示

58
00:03:00,420 --> 00:03:01,460
构建恶意内容

59
00:03:01,460 --> 00:03:02,560
S非常重要

60
00:03:02,560 --> 00:03:08,370
这能帮助你系统化选择不同候选提示

61
00:03:08,370 --> 00:03:13,980
但这个例子展示了如何使用客观评估

62
00:03:13,980 --> 00:03:15,420
因为存在正确答案

63
00:03:15,420 --> 00:03:18,600
物品数量是1201

64
00:03:18,600 --> 00:03:20,900
答案要么正确要么错误

65
00:03:20,900 --> 00:03:26,240
对于需要主观而非客观评估的应用

66
00:03:26,240 --> 00:03:30,520
在上期视频中未使用反思的绘图示例

67
00:03:30,520 --> 00:03:32,740
我们有带反思的柱状图

68
00:03:32,740 --> 00:03:34,040
我们得到了这个图表

69
00:03:34,040 --> 00:03:37,580
但如何确定哪个图表更好

70
00:03:37,580 --> 00:03:39,630
我知道我更喜欢后者

71
00:03:39,630 --> 00:03:42,310
但不同图表在不同维度上变化

72
00:03:42,310 --> 00:03:47,760
如何判断哪个更好并衡量这些图表的优劣

73
00:03:47,760 --> 00:03:51,060
这更为主观

74
00:03:51,060 --> 00:03:55,100
而非纯粹黑白的客观标准

75
00:03:55,100 --> 00:03:58,170
对于这些主观标准

76
00:03:58,170 --> 00:04:01,430
你可以使用语言模型作为裁判

77
00:04:01,430 --> 00:04:06,260
一个基本方法可能是将两个图表输入模型

78
00:04:06,260 --> 00:04:09,150
一个多模态模型可接受两张图像输入

79
00:04:09,150 --> 00:04:11,330
只需询问哪个图像更好

80
00:04:11,330 --> 00:04:13,290
结果发现这并不奏效

81
00:04:13,290 --> 00:04:15,530
稍后我会分享更好的方法

82
00:04:15,530 --> 00:04:19,519
但你可以同时提供评估标准

83
00:04:19,519 --> 00:04:21,279
用于比较两个图表

84
00:04:21,279 --> 00:04:22,710
例如清晰度

85
00:04:22,710 --> 00:04:24,370
美观程度等

86
00:04:24,370 --> 00:04:28,660
但使用模型比较两个输入存在已知问题

87
00:04:28,660 --> 00:04:30,340
判断哪个更好

88
00:04:30,340 --> 00:04:33,380
首先发现答案往往不够理想

89
00:04:33,380 --> 00:04:37,220
可能过度依赖裁判模型的提示词

90
00:04:37,220 --> 00:04:42,400
有时排名与专家判断不一致

91
00:04:42,400 --> 00:04:47,000
其中一个表现是多数模型存在位置偏见

92
00:04:47,000 --> 00:04:51,180
许多模型更倾向于选择第一个选项

93
00:04:51,180 --> 00:04:52,380
而非第二个选项

94
00:04:52,380 --> 00:04:56,680
实际上我在多个案例中发现

95
00:04:56,680 --> 00:04:58,850
无论呈现哪个选项

96
00:04:58,850 --> 00:05:00,950
模型会判定第一个更好

97
00:05:00,950 --> 00:05:03,670
而有些模型偏好第二个选项

98
00:05:03,670 --> 00:05:06,469
但大多数更倾向第一个选项

99
00:05:06,469 --> 00:05:09,249
与其让模型比较输入对

100
00:05:09,249 --> 00:05:13,330
使用评分量表能获得更一致的结果

101
00:05:13,330 --> 00:05:17,130
例如，你可以提示模型执行某项任务

102
00:05:17,130 --> 00:05:18,669
给定一张单张图像

103
00:05:18,669 --> 00:05:21,629
根据质量评估标准评估附图

104
00:05:21,629 --> 00:05:24,960
该评估标准或评分准则可能包含明确指标

105
00:05:24,960 --> 00:05:26,620
比如情节是否有明确标题

106
00:05:26,620 --> 00:05:29,160
坐标标签是否齐全，图表类型是否恰当

107
00:05:29,160 --> 00:05:31,500
等等类似此类少量评估标准

108
00:05:31,500 --> 00:05:32,640
结果发现

109
00:05:32,640 --> 00:05:36,669
与其让模型在1到5分间评分

110
00:05:36,669 --> 00:05:39,709
它往往难以准确校准

111
00:05:39,709 --> 00:05:40,969
如果你改为提供

112
00:05:40,969 --> 00:05:43,149
五个二元判断标准

113
00:05:43,149 --> 00:05:44,980
五个0-1分项标准

114
00:05:44,980 --> 00:05:47,240
并让其给出五个二元评分

115
00:05:47,240 --> 00:05:51,140
将这些分数相加得到1到5或1到10的数值

116
00:05:51,140 --> 00:05:55,860
若使用十个二元标准则结果更稳定

117
00:05:55,860 --> 00:05:58,660
因此若收集若干

118
00:05:58,660 --> 00:05:59,320
例如十个

119
00:05:59,320 --> 00:06:02,850
十五个用户针对不同可视化图表的查询

120
00:06:02,850 --> 00:06:06,730
用户可能需要展示咖啡机销售数据

121
00:06:06,730 --> 00:06:12,780
则可生成无反射或带反射的图像

122
00:06:12,780 --> 00:06:16,840
并使用此类评估标准对每个图像评分

123
00:06:16,840 --> 00:06:18,630
然后检查

124
00:06:18,630 --> 00:06:24,740
或带反射生成的图像是否显著优于无反射版本

125
00:06:24,740 --> 00:06:28,400
一旦构建好此类图像集

126
00:06:28,400 --> 00:06:31,210
若需修改初始生成提示

127
00:06:31,210 --> 00:06:31,730
或调整反思提示

128
00:06:31,730 --> 00:06:33,430
也可重新运行评估以验证

129
00:06:33,430 --> 00:06:36,210
更新某个提示是否能让系统生成

130
00:06:36,210 --> 00:06:40,040
更符合评分标准的图像

131
00:06:40,040 --> 00:06:43,940
从而获得更多分数

132
00:06:43,940 --> 00:06:47,950
这也为持续优化提示提供了方法

133
00:06:47,950 --> 00:06:49,550
以实现持续性能提升

134
00:06:49,550 --> 00:06:52,770
在构建评估系统时

135
00:06:52,770 --> 00:06:58,110
对于反思任务或其他工作负载

136
00:06:58,110 --> 00:07:01,770
基于代码的评估通常更易管理

137
00:07:01,770 --> 00:07:04,410
在数据库查询示例中

138
00:07:04,410 --> 00:07:09,220
我们建立了真实示例和输出的数据库

139
00:07:09,220 --> 00:07:16,380
并通过代码统计系统正确率，形成客观评估指标

140
00:07:16,380 --> 00:07:17,100
相比之下

141
00:07:17,100 --> 00:07:18,900
对于主观性任务

142
00:07:18,900 --> 00:07:20,680
可能需要人工裁判参与

143
00:07:20,680 --> 00:07:23,160
但通常需要更多调优

144
00:07:23,160 --> 00:07:26,460
例如需设计合适的评估标准

145
00:07:26,460 --> 00:07:27,740
使裁判判断更准确可靠

146
00:07:27,740 --> 00:07:30,800
确保输出结果可信有效

147
00:07:30,800 --> 00:07:34,750
因此我希望这能帮助你理解如何构建评估系统

148
00:07:34,750 --> 00:07:36,150
用于评估反思过程

149
00:07:36,150 --> 00:07:40,409
或更广泛地评估不同自主工作流

150
00:07:40,529 --> 00:07:46,770
掌握有效构建评估系统的方法对优化工作流至关重要

151
00:07:46,770 --> 00:07:50,940
而在后续视频中我还会进一步详细讲解这一点

152
00:07:50,940 --> 00:07:54,930
但现在你已经了解了如何使用反射的基本方法

153
00:07:54,930 --> 00:07:59,240
在接下来的视频中，我希望能深入探讨其中一个方面

154
00:07:59,240 --> 00:08:02,860
那就是能够从外部获取额外信息

155
00:08:02,860 --> 00:08:06,360
而这会让反射功能表现得更好

156
00:08:06,360 --> 00:08:08,540
在本模块的最后一个视频中

157
00:08:08,540 --> 00:08:13,460
让我们看看如何通过这项技术使反射任务更高效

158
00:08:13,460 --> 00:08:15,240
我们下期视频再见

