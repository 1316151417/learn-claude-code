1
00:00:00,240 --> 00:00:01,080
在本节课中

2
00:00:01,080 --> 00:00:03,599
你将继续构建知识图谱

3
00:00:03,599 --> 00:00:09,000
上一节课根据构建计划从CSV文件创建了领域图

4
00:00:09,000 --> 00:00:11,480
现在你将处理Markdown文件

5
00:00:11,480 --> 00:00:17,259
将其切分为词汇图并提取实体到主体图

6
00:00:17,259 --> 00:00:20,559
你将学习如何使用新的vj图RAG库

7
00:00:20,559 --> 00:00:23,470
执行切分和实体提取操作

8
00:00:23,470 --> 00:00:27,190
你还将学习实体解析技术

9
00:00:27,269 --> 00:00:30,329
最终这不会是工作流程的遗传部分

10
00:00:30,329 --> 00:00:32,329
这将完全由工具处理

11
00:00:32,329 --> 00:00:33,860
因此我们将定义一些工具

12
00:00:33,860 --> 00:00:37,540
并编写这些工具所需的一些辅助函数

13
00:00:37,540 --> 00:00:42,129
我们需要的两个工具之一是实际构建知识图谱的工具

14
00:00:42,129 --> 00:00:43,789
我们将为每个文件创建一个构建器

15
00:00:43,789 --> 00:00:47,120
并让其处理文件进行切分和提取

16
00:00:47,120 --> 00:00:51,800
你将定义的另一个函数是关联主体与领域节点

17
00:00:51,800 --> 00:00:56,200
这两个工具将从Markdown文件构建图谱

18
00:00:56,200 --> 00:00:59,000
然后获取提取的实体结果

19
00:00:59,000 --> 00:01:01,580
并在主体图之间进行关联

20
00:01:01,580 --> 00:01:06,410
与之前从CSV文件创建的领域图

21
00:01:06,410 --> 00:01:08,230
现在可能有点难以理解

22
00:01:08,230 --> 00:01:10,350
随着逐步讲解会更清晰

23
00:01:10,350 --> 00:01:11,710
如同之前的笔记本教程

24
00:01:11,710 --> 00:01:14,130
你将首先导入所需库

25
00:01:14,130 --> 00:01:16,699
让我们进行常规设置

26
00:01:16,699 --> 00:01:18,639
所有需要的库

27
00:01:18,639 --> 00:01:22,180
等待导入完成

28
00:01:22,180 --> 00:01:24,180
确保Open Eyes已就绪

29
00:01:24,180 --> 00:01:26,860
并检查新FourJ是否准备就绪

30
00:01:27,970 --> 00:01:30,020
现在一切正常

31
00:01:30,020 --> 00:01:31,140
在此设置中

32
00:01:31,140 --> 00:01:36,460
我们需要的不仅仅是前几课创建的初始状态

33
00:01:36,460 --> 00:01:38,180
因为现在我们不再只是执行工作流程

34
00:01:38,180 --> 00:01:41,900
上一课实际上在eFourJ中创建了部分图谱

35
00:01:41,900 --> 00:01:45,240
由于新FourJ加载时会是全新状态

36
00:01:45,240 --> 00:01:46,380
我们需要添加

37
00:01:46,380 --> 00:01:49,910
之前课程中创建的部分产品节点

38
00:01:49,910 --> 00:01:51,910
我们有一个辅助函数用于此

39
00:01:51,910 --> 00:01:54,570
这个辅助函数是load_product_nodes

40
00:01:54,570 --> 00:01:55,790
我们可以直接调用它

41
00:01:55,790 --> 00:01:56,780
然后执行调用

42
00:01:56,780 --> 00:01:58,300
我们预期的是

43
00:01:58,300 --> 00:02:01,220
图中仅存在标签为product的节点

44
00:02:02,420 --> 00:02:02,640
好的

45
00:02:02,640 --> 00:02:03,580
操作正确

46
00:02:03,580 --> 00:02:04,830
太好了

47
00:02:04,830 --> 00:02:05,270
现在

48
00:02:05,270 --> 00:02:07,650
你需要为代理准备初始状态

49
00:02:07,650 --> 00:02:12,019
初始状态应包含工作流程前期创建的部分

50
00:02:12,019 --> 00:02:15,920
与之前加载的内容类似，我们需要构建计划

51
00:02:15,920 --> 00:02:18,280
我实际处理的已批准文件

52
00:02:18,280 --> 00:02:21,760
此外我们已完成实体提取的初步规划

53
00:02:21,760 --> 00:02:24,590
我们需要已批准的实体和事实类型

54
00:02:24,590 --> 00:02:27,690
我们将创建这些初始状态

55
00:02:27,690 --> 00:02:30,430
这是已批准的施工计划

56
00:02:32,880 --> 00:02:35,120
这是已批准的文件

57
00:02:36,350 --> 00:02:41,110
已批准的实体和事实类型

58
00:02:42,920 --> 00:02:47,740
现在可以开始定义创建管道所需的各种功能

59
00:02:47,740 --> 00:02:50,930
这将处理所有Markdown文件

60
00:02:50,930 --> 00:02:52,110
进行分块处理

61
00:02:52,110 --> 00:02:53,830
然后提取实体

62
00:02:53,830 --> 00:02:58,579
新的Four J图RAG库有一个便捷的简单知识图谱管道

63
00:02:58,579 --> 00:03:02,490
可用于处理分块和实体提取

64
00:03:02,490 --> 00:03:04,550
对于所有要处理的Markdown文件

65
00:03:04,550 --> 00:03:08,100
需要创建辅助函数正确配置

66
00:03:08,100 --> 00:03:12,019
但首先让我们看看简单知识图谱管道的接口

67
00:03:12,379 --> 00:03:14,479
这只是示例代码

68
00:03:14,479 --> 00:03:15,499
当然无法运行

69
00:03:15,499 --> 00:03:17,810
因为此处没有有效值

70
00:03:17,810 --> 00:03:19,170
但仅展示结构

71
00:03:19,170 --> 00:03:22,910
实际创建简单知识图谱管道实例的过程

72
00:03:22,910 --> 00:03:24,470
需要一个m

73
00:03:24,470 --> 00:03:26,990
当然进行实体提取时

74
00:03:26,990 --> 00:03:30,870
需要Four J的驱动程序以输出图谱

75
00:03:30,870 --> 00:03:34,830
需要更好的接口，可能是同一LLM或其他模型

76
00:03:34,830 --> 00:03:35,860
如果需要的话

77
00:03:35,860 --> 00:03:40,120
由于我们处理的是Markdown文件而非PDF

78
00:03:40,120 --> 00:03:42,940
通常设置为处理PDF为false

79
00:03:42,940 --> 00:03:44,440
但实际上并非如此

80
00:03:44,440 --> 00:03:47,780
我们将使用自定义PDF加载器而非加载PDF

81
00:03:47,780 --> 00:03:49,200
我们将加载Markdown文件

82
00:03:49,200 --> 00:03:52,170
这只是接口设计的一个小细节

83
00:03:52,170 --> 00:03:53,750
但最终我们会设为true

84
00:03:53,750 --> 00:03:54,360
在这里

85
00:03:54,360 --> 00:03:57,720
我们将定义自定义加载器并集成到此部分

86
00:03:57,720 --> 00:03:59,240
对于PDF加载器部分

87
00:03:59,240 --> 00:04:01,080
还需要自定义分块器

88
00:04:01,080 --> 00:04:03,490
因为我们了解Markdown的结构

89
00:04:03,490 --> 00:04:05,670
如果你有分块处理经验

90
00:04:05,670 --> 00:04:06,810
知道纯文本分割本身就是一门艺术

91
00:04:06,810 --> 00:04:08,420
可能有很多深度学习课程

92
00:04:08,420 --> 00:04:11,140
可以深入学习该主题

93
00:04:11,140 --> 00:04:14,160
这里有很多深度学习课程

94
00:04:14,160 --> 00:04:15,620
我们将采用简化版本

95
00:04:15,620 --> 00:04:18,060
基于现有数据做出假设

96
00:04:18,060 --> 00:04:19,760
还可以传入模式

97
00:04:19,760 --> 00:04:20,500
而模式是

98
00:04:20,500 --> 00:04:21,000
当然

99
00:04:21,000 --> 00:04:24,990
将基于前一课设置的建议模式

100
00:04:24,990 --> 00:04:28,380
关于能从文本中提取的事实和实体类型

101
00:04:28,380 --> 00:04:29,180
然后当然还有

102
00:04:29,180 --> 00:04:30,680
将所有这些内容整合起来

103
00:04:30,680 --> 00:04:33,000
我们将有一个自定义提示输入

104
00:04:33,000 --> 00:04:36,000
这将明确告知语言模型我们需要查找的内容

105
00:04:36,000 --> 00:04:38,470
以及如何进行提取思考

106
00:04:38,470 --> 00:04:42,810
让我们逐步讲解新四J KG构建器的端到端流程

107
00:04:42,810 --> 00:04:46,280
帮助你理解这些组件的功能

108
00:04:46,280 --> 00:04:47,720
每个文档都会被加载

109
00:04:47,720 --> 00:04:49,680
内置支持PDF格式

110
00:04:49,680 --> 00:04:52,550
但你会使用自定义Markdown加载器

111
00:04:52,550 --> 00:04:52,950
接下来

112
00:04:52,950 --> 00:04:55,490
文本分块组件将执行分块处理

113
00:04:55,490 --> 00:04:58,659
这是许多框架中常见的分块方法

114
00:04:58,659 --> 00:04:59,839
对于每个分块

115
00:04:59,839 --> 00:05:01,859
分块嵌入将计算向量

116
00:05:01,859 --> 00:05:02,559
嵌入

117
00:05:02,559 --> 00:05:04,059
然后对分块进行分析

118
00:05:04,059 --> 00:05:08,460
使用语言模型按实体和关系提取器的指令

119
00:05:08,460 --> 00:05:12,890
此组件将配置以匹配我们的知识提取计划

120
00:05:12,890 --> 00:05:14,650
图谱构建完成后

121
00:05:14,650 --> 00:05:17,770
可选的图谱清理器用于优化图谱

122
00:05:17,770 --> 00:05:19,539
所有操作都在内存中完成

123
00:05:19,539 --> 00:05:25,220
KG写入器负责将内存中的图谱保存到四J系统

124
00:05:25,220 --> 00:05:25,940
最后

125
00:05:25,940 --> 00:05:32,000
实体解析组件将合并可能相同的实体节点

126
00:05:32,640 --> 00:05:33,180
好的

127
00:05:33,180 --> 00:05:35,540
现在你可以开始定义这些自定义函数

128
00:05:35,540 --> 00:05:37,780
需要输入到流程中

129
00:05:37,780 --> 00:05:41,320
首先设置自定义文本分块器

130
00:05:41,320 --> 00:05:45,449
如果你还记得我们之前的火星飞行员Markdown文件

131
00:05:45,449 --> 00:05:47,369
开头有一个H1标题

132
00:05:47,369 --> 00:05:49,309
然后有这些分页符

133
00:05:49,309 --> 00:05:51,310
主要用于分割评论内容

134
00:05:51,310 --> 00:05:54,670
因此我们将使用简单正则表达式分块器

135
00:05:54,670 --> 00:05:56,159
在新四J中

136
00:05:56,159 --> 00:05:58,239
有一个名为文本分块器的基础类

137
00:05:58,239 --> 00:06:00,379
可扩展自定义功能

138
00:06:00,379 --> 00:06:01,919
这就是我们要做的

139
00:06:01,919 --> 00:06:03,520
我们将扩展文本分块器

140
00:06:03,520 --> 00:06:05,800
在文本分块器的运行函数中

141
00:06:05,800 --> 00:06:07,320
因为它是流程的一部分

142
00:06:07,320 --> 00:06:10,100
这里将放置自定义功能

143
00:06:10,100 --> 00:06:14,500
只需使用正则表达式进行文本分割

144
00:06:14,500 --> 00:06:16,780
基于已定义的正则表达式

145
00:06:16,780 --> 00:06:19,200
将其传递给函数本身

146
00:06:19,200 --> 00:06:21,320
对于任何传入的正则表达式

147
00:06:21,320 --> 00:06:25,440
均可作为文本的分割点

148
00:06:26,030 --> 00:06:27,870
最后一步是继续

149
00:06:27,870 --> 00:06:32,350
使用列表推导将每个纯文本分块

150
00:06:32,350 --> 00:06:36,230
转换为四J图谱RAG库期望的对象

151
00:06:36,230 --> 00:06:37,789
称为文本块

152
00:06:37,789 --> 00:06:40,329
文本块仅包含字符串本身的文本内容

153
00:06:40,329 --> 00:06:42,659
该文本段落的索引

154
00:06:42,659 --> 00:06:46,719
这将生成包含这些文本块对象的单个列表

155
00:06:46,719 --> 00:06:49,680
该列表将被命名为文本块

156
00:06:49,680 --> 00:06:53,880
你还将使用特殊的数据加载器加载Markdown文件

157
00:06:53,880 --> 00:06:55,930
与文本分割器类似

158
00:06:55,930 --> 00:07:00,170
这将继承新vj grarag库的基类

159
00:07:00,770 --> 00:07:02,810
这里有几个可用的选项

160
00:07:02,810 --> 00:07:05,350
但我们自己会找到一个特殊版本

161
00:07:05,350 --> 00:07:08,659
我们将导入数据加载器基类

162
00:07:08,659 --> 00:07:11,899
这些操作类型需要用于输出

163
00:07:11,899 --> 00:07:14,719
我们将模拟解析PDF文档的过程

164
00:07:14,719 --> 00:07:18,640
在Markdown数据加载器中加载PDF文档类型

165
00:07:18,640 --> 00:07:21,750
这里最关键的是

166
00:07:21,750 --> 00:07:24,330
我们知道Markdown中包含某些元数据

167
00:07:24,330 --> 00:07:28,470
我们需要提取并添加到数据加载的上下文中

168
00:07:28,470 --> 00:07:29,770
在分块处理时

169
00:07:29,770 --> 00:07:33,870
类中有一个名为提取标题的辅助函数

170
00:07:33,870 --> 00:07:36,330
将使用非常基础的正则表达式

171
00:07:36,330 --> 00:07:40,390
假设首次找到单个H1标题

172
00:07:40,390 --> 00:07:43,510
将其作为文档标题

173
00:07:43,510 --> 00:07:45,610
当调用运行函数时

174
00:07:45,610 --> 00:07:49,490
运行函数将从数据源加载数据

175
00:07:49,490 --> 00:07:51,680
将从文件系统加载

176
00:07:51,680 --> 00:07:54,940
读取整个Markdown文件

177
00:07:54,940 --> 00:07:56,120
提取标题

178
00:07:56,120 --> 00:08:00,020
然后将其转换为此文档信息

179
00:08:00,020 --> 00:08:02,880
文档信息才是关键部分

180
00:08:02,880 --> 00:08:08,630
这是与文档文本结合的元数据

181
00:08:08,630 --> 00:08:14,200
我们已将Markdown文本加载到此PDF文档类中

182
00:08:14,440 --> 00:08:18,800
构建知识图谱管道还需

183
00:08:18,800 --> 00:08:20,040
当然需要一个语言模型

184
00:08:20,040 --> 00:08:20,460
我们准备好了

185
00:08:20,460 --> 00:08:21,419
我们已有

186
00:08:21,419 --> 00:08:22,939
但我们将继续使用OpenAI

187
00:08:22,939 --> 00:08:25,419
当然也会使用OpenAI

188
00:08:25,419 --> 00:08:28,130
然后获取新的四J驱动器

189
00:08:28,130 --> 00:08:29,050
这里使用

190
00:08:29,050 --> 00:08:30,790
j graph rag库

191
00:08:30,790 --> 00:08:32,169
四J支持

192
00:08:32,169 --> 00:08:35,080
当然也支持OpenAI和其他模型

193
00:08:35,080 --> 00:08:37,100
我们将使用OpenAI作为语言模型

194
00:08:37,100 --> 00:08:38,770
同时用于嵌入生成

195
00:08:38,770 --> 00:08:41,770
创建新四J的语言模型实例

196
00:08:41,770 --> 00:08:43,350
以及四J better

197
00:08:43,350 --> 00:08:46,350
从图数据库获取四J驱动器

198
00:08:46,350 --> 00:08:50,110
我们一直使用的单例，用于发送查询

199
00:08:50,110 --> 00:08:53,270
该单例允许获取内部驱动器

200
00:08:53,270 --> 00:08:55,250
这就是我们在这里的操作

201
00:08:55,250 --> 00:08:55,950
好的

202
00:08:55,950 --> 00:08:59,230
你已经定义了知识图谱管道所需的一些实用函数

203
00:08:59,230 --> 00:09:03,319
同时也定义了其他组件，比如语言模型和嵌入器

204
00:09:03,319 --> 00:09:08,859
现在我们将转向实际进行知识图谱实体提取所需的上下文

205
00:09:08,859 --> 00:09:11,329
我们首先从实体模式开始

206
00:09:11,329 --> 00:09:16,380
新四j图RAG包所需的实体模式包含几个不同组件

207
00:09:16,380 --> 00:09:20,020
其中一个是要知道应在文本中查找的节点类型

208
00:09:20,020 --> 00:09:24,390
这里我们只需复制或创建approved_entities的别名

209
00:09:24,390 --> 00:09:26,890
我们还将获取关系类型模式

210
00:09:26,890 --> 00:09:30,670
为此我们将从批准的事实类型中提取

211
00:09:30,670 --> 00:09:34,860
所有批准的事实类型实际上都存在于字典中

212
00:09:34,860 --> 00:09:38,190
字典的键正是关系类型本身

213
00:09:38,190 --> 00:09:39,990
因此我们只需提取所有键

214
00:09:39,990 --> 00:09:41,730
这将成为关系类型模式

215
00:09:41,730 --> 00:09:43,110
你可以在这里看到

216
00:09:43,110 --> 00:09:45,570
你还会使用批准的事实类型

217
00:09:45,570 --> 00:09:50,000
作为知识图谱构建管道所说的模式模式

218
00:09:50,000 --> 00:09:53,240
这其实只是信息的重新包装

219
00:09:53,240 --> 00:09:54,460
从每个事实中

220
00:09:54,460 --> 00:09:57,380
我们将生成包含主语标签的列表

221
00:09:57,380 --> 00:09:59,870
谓词标签和宾语标签

222
00:09:59,870 --> 00:10:01,550
我们将处理谓词标签

223
00:10:01,550 --> 00:10:02,650
将其转换为大写

224
00:10:02,650 --> 00:10:05,710
这是new for j的约定

225
00:10:06,990 --> 00:10:11,319
知识图谱构建所需的完整模式在此

226
00:10:11,319 --> 00:10:12,459
包含节点类型

227
00:10:12,459 --> 00:10:13,359
关系类型

228
00:10:13,359 --> 00:10:15,580
这些如何组合的模式

229
00:10:15,580 --> 00:10:17,900
并将此标志设为false

230
00:10:17,900 --> 00:10:20,340
仅使用我们定义的这些类型

231
00:10:20,340 --> 00:10:22,700
不要添加新内容

232
00:10:24,169 --> 00:10:28,289
接下来获取实体提取上下文的重要部分

233
00:10:28,289 --> 00:10:29,880
我们将创建自定义提示

234
00:10:29,880 --> 00:10:33,500
将每个块内的文本注入其中

235
00:10:33,500 --> 00:10:35,720
同时还会添加模式

236
00:10:35,720 --> 00:10:38,800
我们还将使用特殊实用函数

237
00:10:38,800 --> 00:10:41,230
用于添加文件上下文

238
00:10:41,230 --> 00:10:43,650
管道将处理单个块

239
00:10:43,650 --> 00:10:47,470
文件的整体上下文将添加到提示中

240
00:10:47,470 --> 00:10:50,870
以便LLM在查看该块时

241
00:10:50,870 --> 00:10:53,180
知道它所属的文档是什么

242
00:10:53,180 --> 00:10:56,560
因此对于文件上下文我们创建这个小辅助函数

243
00:10:56,560 --> 00:10:57,740
所有操作其实只是

244
00:10:57,740 --> 00:11:01,080
获取文件文本的前几行

245
00:11:01,080 --> 00:11:03,060
包含文件标题

246
00:11:03,060 --> 00:11:05,440
以及一些简介和信息

247
00:11:05,440 --> 00:11:08,420
为每个块提供足够上下文

248
00:11:08,420 --> 00:11:10,660
然后定义提示本身

249
00:11:10,660 --> 00:11:12,250
我们来看这个提示

250
00:11:12,250 --> 00:11:14,510
作为一大段文本

251
00:11:14,510 --> 00:11:17,520
它将大致遵循我们之前采用的相同格式

252
00:11:17,520 --> 00:11:19,000
我们有一些关于

253
00:11:19,000 --> 00:11:22,280
当前工作中LLM的角色是什么

254
00:11:22,280 --> 00:11:24,350
以及实际追求的目标是什么

255
00:11:24,350 --> 00:11:26,050
但其中大部分是搭建

256
00:11:26,050 --> 00:11:27,470
一些设计提示

257
00:11:27,470 --> 00:11:31,390
同时也包括上下文和上下文包含模式定义

258
00:11:31,390 --> 00:11:34,280
以及我们将要提取的文件部分内容

259
00:11:34,280 --> 00:11:36,220
当你查看这个提示时

260
00:11:36,220 --> 00:11:37,400
你会发现它包含

261
00:11:37,400 --> 00:11:39,520
关于角色和目标的说明

262
00:11:39,520 --> 00:11:41,460
这里还有一些设计指令

263
00:11:41,460 --> 00:11:42,720
关于它应该执行什么

264
00:11:42,720 --> 00:11:46,510
还包含输出格式的具体要求

265
00:11:46,510 --> 00:11:49,630
在这里以及每个片段的模式都将被注入

266
00:11:49,630 --> 00:11:52,770
一旦所有内容就位

267
00:11:52,770 --> 00:11:54,770
作为输出的一部分

268
00:11:54,770 --> 00:11:57,790
我们将要求它为每个节点生成独特想法

269
00:11:57,790 --> 00:11:59,880
在创建这些节点时

270
00:12:00,280 --> 00:12:02,320
同时我们还会给出此处的指令

271
00:12:02,320 --> 00:12:05,730
关于如何处理输出中的每个属性

272
00:12:05,730 --> 00:12:08,470
我们需要节点输出包含某些ID

273
00:12:08,470 --> 00:12:09,850
我们需要知道标签是什么

274
00:12:09,850 --> 00:12:10,610
它所选择的内容

275
00:12:10,610 --> 00:12:14,110
以及应分配给该实体的属性是什么

276
00:12:14,310 --> 00:12:17,450
接下来是来自文件的上下文

277
00:12:17,450 --> 00:12:20,330
文档级上下文将被注入

278
00:12:20,330 --> 00:12:22,370
在这里因为这是一个辅助函数

279
00:12:22,370 --> 00:12:24,819
用于创建整体提示

280
00:12:24,819 --> 00:12:28,359
我们将直接将其作为静态文本注入

281
00:12:28,359 --> 00:12:29,720
因此不会被注入

282
00:12:29,720 --> 00:12:31,380
每次创建片段时

283
00:12:31,380 --> 00:12:33,260
它将是静态文本的一部分

284
00:12:33,260 --> 00:12:38,260
最后将把片段数据放入此模板格式

285
00:12:38,500 --> 00:12:39,060
好的

286
00:12:39,060 --> 00:12:40,820
整合所有已设置的上下文

287
00:12:40,820 --> 00:12:45,960
结合知识图谱构建器所需的各类辅助函数

288
00:12:45,960 --> 00:12:48,140
我们可以创建知识图谱构建器

289
00:12:48,140 --> 00:12:50,380
然后使用它

290
00:12:50,380 --> 00:12:53,220
因为我们将为每个文件创建知识图谱构建器

291
00:12:53,220 --> 00:12:55,420
从而生成针对文件的专用提示

292
00:12:55,420 --> 00:12:57,050
基于文件内容

293
00:12:57,050 --> 00:12:59,569
这里是我们在辅助函数中设置的方法

294
00:12:59,569 --> 00:13:02,989
我们将创建一个生成知识图谱构建器的辅助函数

295
00:13:02,989 --> 00:13:06,069
其输出是一个简单的知识图谱处理管道

296
00:13:06,069 --> 00:13:08,599
这是图RAG类的新功能

297
00:13:08,599 --> 00:13:10,359
首先在该辅助函数内部

298
00:13:10,359 --> 00:13:13,359
获取文档级上下文

299
00:13:13,359 --> 00:13:16,770
使用我们创建的文件上下文工具

300
00:13:16,770 --> 00:13:19,850
再次获取数据文件的前几行内容

301
00:13:19,850 --> 00:13:23,170
然后从这里生成上下文化的提示

302
00:13:23,170 --> 00:13:24,350
传递该上下文

303
00:13:24,350 --> 00:13:28,560
这是我们能得到的完整提示

304
00:13:28,560 --> 00:13:30,940
因此当我们创建简单的知识图谱管道

305
00:13:30,940 --> 00:13:33,040
我们将获取定义的lm模型

306
00:13:33,040 --> 00:13:35,620
我们使用的驱动程序是embe

307
00:13:35,620 --> 00:13:37,660
我们将假装在处理PDF文件

308
00:13:37,660 --> 00:13:39,580
因为我们有一个自定义的PDF加载器

309
00:13:39,580 --> 00:13:41,410
实际上会加载Markdown文件

310
00:13:41,410 --> 00:13:42,730
我们的自定义分词器

311
00:13:42,730 --> 00:13:44,800
将使用正则表达式

312
00:13:44,800 --> 00:13:47,340
在这里正则表达式只是向前查找

313
00:13:47,340 --> 00:13:47,840
短横线

314
00:13:47,840 --> 00:13:48,080
短横线

315
00:13:48,080 --> 00:13:48,420
短横线

316
00:13:48,420 --> 00:13:49,560
这就是Markdown页面

317
00:13:49,560 --> 00:13:52,720
如果查看之前看到的Markdown文件

318
00:13:52,720 --> 00:13:54,580
这就是每个评论的分割方式

319
00:13:54,580 --> 00:13:56,060
因此我们将使用这些文本

320
00:13:56,060 --> 00:13:59,450
将组装的模式拆分为实体模式

321
00:13:59,450 --> 00:14:03,610
然后最终构建的上下文化提示

322
00:14:03,610 --> 00:14:04,610
将所有内容整合

323
00:14:04,610 --> 00:14:08,680
得到一个完整的管道进行分块

324
00:14:08,680 --> 00:14:10,790
然后进行实体提取

325
00:14:10,790 --> 00:14:14,250
现在你有了生成知识图谱v管道的辅助函数

326
00:14:14,250 --> 00:14:15,610
针对特定文件

327
00:14:15,610 --> 00:14:21,270
现在只需遍历导入目录中的所有文件

328
00:14:21,270 --> 00:14:24,650
为每个文件获取完整路径

329
00:14:24,650 --> 00:14:26,250
输出提示语句

330
00:14:26,250 --> 00:14:27,790
告知当前进度

331
00:14:27,790 --> 00:14:29,290
创建知识图谱构建器

332
00:14:29,290 --> 00:14:30,950
然后运行知识图谱构建器

333
00:14:32,350 --> 00:14:33,550
这需要几分钟时间

334
00:14:33,550 --> 00:14:34,130
我们有

335
00:14:34,130 --> 00:14:37,440
我想处理大约十个文件

336
00:14:37,440 --> 00:14:38,840
每个文件将需要

337
00:14:38,840 --> 00:14:41,780
根据OpenAI的响应速度

338
00:14:41,780 --> 00:14:42,040
AI

339
00:14:42,040 --> 00:14:43,140
可能需要一分钟

340
00:14:43,140 --> 00:14:47,549
完成文档的自然语言处理和提取

341
00:14:47,549 --> 00:14:51,200
同时进行分块处理

342
00:14:51,400 --> 00:14:51,980
好的

343
00:14:51,980 --> 00:14:53,630
当循环完成后

344
00:14:53,630 --> 00:14:56,410
将得到完整的词汇图

345
00:14:56,410 --> 00:14:57,790
这是图的组成部分

346
00:14:57,790 --> 00:14:59,990
包含相互连接的块

347
00:14:59,990 --> 00:15:02,970
并连接到文档注释

348
00:15:02,970 --> 00:15:07,170
同时还有主体图

349
00:15:07,170 --> 00:15:09,810
包含所有提取的实体

350
00:15:10,690 --> 00:15:12,990
以及它们之间的关系

351
00:15:12,990 --> 00:15:14,390
已完成

352
00:15:14,390 --> 00:15:16,830
现在你拥有了一个词典图

353
00:15:16,830 --> 00:15:19,490
一个主体图和一个领域图

354
00:15:19,490 --> 00:15:22,270
然而知识图谱并不完整

355
00:15:22,270 --> 00:15:26,130
因为主体图和领域图尚未连接

356
00:15:26,130 --> 00:15:30,340
而且如果你还记得领域图是基于CSV文件创建的

357
00:15:30,340 --> 00:15:35,380
而我们刚刚从Markdown文件中提取数据生成了主体图

358
00:15:35,380 --> 00:15:40,020
下一步是将从Markdown文件中提取的实体连接起来

359
00:15:40,020 --> 00:15:41,320
整合到主体图中

360
00:15:41,320 --> 00:15:44,560
我们希望将这些与领域图连接

361
00:15:44,560 --> 00:15:44,960
所以

362
00:15:44,960 --> 00:15:48,140
如果领域图中存在与主体图提取实体相同的产品

363
00:15:48,140 --> 00:15:51,260
作为主体图中的提取实体

364
00:15:51,260 --> 00:15:52,640
我们希望将它们连接

365
00:15:52,640 --> 00:15:55,280
因此我们将定义几个工具来实现这一目标

366
00:15:55,280 --> 00:15:58,349
现在对于主体图中的每种实体类型

367
00:15:58,349 --> 00:16:02,900
你需要制定与领域图中正确节点关联的策略

368
00:16:02,900 --> 00:16:03,640
例如

369
00:16:03,640 --> 00:16:08,100
你应该预期主体图中的产品名称实体存在

370
00:16:08,100 --> 00:16:11,480
这些应与领域图中的产品对应

371
00:16:11,480 --> 00:16:13,180
为了做到这一点

372
00:16:13,180 --> 00:16:15,620
你将首先进行几项操作

373
00:16:15,620 --> 00:16:19,950
找到主体图中所有唯一的实体标签

374
00:16:20,190 --> 00:16:24,480
同样找到领域图中所有唯一的节点标签

375
00:16:24,480 --> 00:16:29,240
然后尝试在这两个标签集合之间关联属性键

376
00:16:29,240 --> 00:16:30,240
这样你可以确定

377
00:16:30,240 --> 00:16:33,820
如果主体图中有产品具有多个属性

378
00:16:33,820 --> 00:16:38,319
如何与领域图中具有多个属性的产品对应

379
00:16:38,319 --> 00:16:38,679
所以

380
00:16:38,679 --> 00:16:41,559
最终步骤是执行实体解析

381
00:16:41,559 --> 00:16:45,180
通过分析属性值的相似性

382
00:16:45,300 --> 00:16:45,660
好的

383
00:16:45,660 --> 00:16:49,100
第一步是找到主体图中的唯一实体标签

384
00:16:49,100 --> 00:16:50,980
现在让我们查看主体图

385
00:16:50,980 --> 00:16:52,740
观察节点的结构

386
00:16:52,740 --> 00:16:55,720
在新的j grafrag库完成工作后

387
00:16:55,720 --> 00:17:01,089
主体图中的节点将带有额外标识标签

388
00:17:01,089 --> 00:17:03,749
它们将被标记为双下划线实体

389
00:17:03,749 --> 00:17:05,030
下划线标签

390
00:17:05,030 --> 00:17:10,380
你还会看到额外标签标识实体类型

391
00:17:10,380 --> 00:17:13,140
如果我们运行匹配任意节点的查询

392
00:17:13,140 --> 00:17:16,920
并查找具有该标签的节点

393
00:17:16,920 --> 00:17:21,560
即可返回不同标签的集合并称为实体标签

394
00:17:21,560 --> 00:17:23,579
现在查看结果

395
00:17:23,579 --> 00:17:26,699
可以看到这里添加了几个特殊标签

396
00:17:26,699 --> 00:17:28,239
有双下划线实体标签

397
00:17:28,239 --> 00:17:30,310
还有双下划线kg builder

398
00:17:30,310 --> 00:17:33,969
表明kg builder负责创建这些节点

399
00:17:33,969 --> 00:17:37,529
但我们真正关心的是看到产品位置

400
00:17:37,529 --> 00:17:38,729
问题和功能

401
00:17:38,729 --> 00:17:43,139
现在我们已经知道这一点，因为这是我们从之前的步骤中预期的结果

402
00:17:43,139 --> 00:17:48,230
但重要的是，这些步骤可能原本试图寻找类似位置之类的信息

403
00:17:48,230 --> 00:17:51,290
但这些可能实际上未能在图中发生

404
00:17:51,290 --> 00:17:53,900
因为语言模型未能真正找到它们

405
00:17:53,900 --> 00:17:55,220
因此我们将采取以下做法

406
00:17:55,220 --> 00:17:57,659
我们将查询图中实际发生的内容

407
00:17:57,659 --> 00:18:00,139
然后根据我们在图中找到的标签

408
00:18:00,139 --> 00:18:04,180
我们将这些称为主体图中的唯一实体标签

409
00:18:04,180 --> 00:18:07,300
让我们通过几个查询示例来详细说明

410
00:18:07,300 --> 00:18:10,460
首先，如果你查看这些行，你会发现每一行

411
00:18:10,460 --> 00:18:12,020
实际上是一个标签列表

412
00:18:12,020 --> 00:18:13,320
对于每一行

413
00:18:13,320 --> 00:18:16,230
如果我们继续使用展开子句

414
00:18:16,230 --> 00:18:20,890
在这里，我们说要展开实体标签，这些标签将属于每个节点

415
00:18:20,890 --> 00:18:24,340
并将这些单独的行称为实体标签

416
00:18:24,340 --> 00:18:26,860
然后我们可以返回唯一的实体标签

417
00:18:26,860 --> 00:18:28,360
我们应该看到所有相同的值

418
00:18:28,360 --> 00:18:30,520
但现在不再是多个列表

419
00:18:30,520 --> 00:18:33,100
我们将看到一个包含所有值的单一列表

420
00:18:33,520 --> 00:18:34,120
好的

421
00:18:34,120 --> 00:18:36,460
现在列表实际上只是几行

422
00:18:36,460 --> 00:18:38,360
每行只有一个标签

423
00:18:38,360 --> 00:18:39,380
知识图谱构建器

424
00:18:39,380 --> 00:18:42,370
产品实体你可以直接看到

425
00:18:42,450 --> 00:18:45,310
让我们进一步详细说明这个查询

426
00:18:45,310 --> 00:18:47,930
我们需要过滤掉这些下划线标签

427
00:18:47,930 --> 00:18:51,290
我们只需通过相同的查询来实现

428
00:18:51,290 --> 00:18:52,750
我们从匹配开始

429
00:18:52,750 --> 00:18:55,610
仅针对实际是实体的项设置谓词

430
00:18:55,610 --> 00:18:57,010
展开所有这些

431
00:18:57,010 --> 00:18:59,300
这些只是单独的实体标签

432
00:18:59,300 --> 00:19:02,040
然后我们添加另一个谓词

433
00:19:02,040 --> 00:19:02,260
好的

434
00:19:02,260 --> 00:19:05,440
现在删除所有以下划线开头的实体

435
00:19:05,440 --> 00:19:09,340
这将移除知识图谱构建器和下划线实体

436
00:19:09,940 --> 00:19:12,700
这就是我们想要的产品位置列表

437
00:19:12,700 --> 00:19:14,260
问题和功能

438
00:19:14,990 --> 00:19:19,150
你可以定义一个实用函数来封装对new four j的调用

439
00:19:19,800 --> 00:19:21,320
如果你尝试使用这个实用函数

440
00:19:22,320 --> 00:19:22,760
你应该看到

441
00:19:22,760 --> 00:19:23,140
当然

442
00:19:23,140 --> 00:19:23,980
仅仅这个列表

443
00:19:23,980 --> 00:19:26,369
正是我们现在需要的内容

444
00:19:26,369 --> 00:19:28,349
对于每个唯一的实体标签

445
00:19:28,349 --> 00:19:31,370
我们也想找到每个标签的唯一键

446
00:19:31,370 --> 00:19:34,050
对于每一个，我们将执行类似的操作

447
00:19:34,050 --> 00:19:36,250
我们将定义一个实用函数

448
00:19:36,250 --> 00:19:39,250
用于查找具有该特定标签的所有节点

449
00:19:39,250 --> 00:19:42,650
但一旦找到这些样本集合

450
00:19:42,650 --> 00:19:45,550
我们将仅提取这些节点上出现的唯一键

451
00:19:45,550 --> 00:19:49,420
让我们看看这个效用函数在这里是什么样子的

452
00:19:49,420 --> 00:19:50,240
它将接收一个参数

453
00:19:50,240 --> 00:19:53,200
也就是我们正在寻找的实体标签是什么

454
00:19:53,200 --> 00:19:54,600
现在进行匹配

455
00:19:54,600 --> 00:19:56,200
而不是查找所有节点

456
00:19:56,200 --> 00:19:59,490
我们只查找具有该特定实体标签的节点

457
00:19:59,490 --> 00:20:02,850
在这里我们将稍微调整一下思路

458
00:20:02,850 --> 00:20:03,930
我们实际上想要查找

459
00:20:03,930 --> 00:20:04,370
当然

460
00:20:04,370 --> 00:20:08,820
仅在该标签与下划线实体共同出现的位置

461
00:20:08,820 --> 00:20:12,400
而不是查找不同的标签集合

462
00:20:12,400 --> 00:20:16,840
我们将查找这些节点的唯一键并返回

463
00:20:16,840 --> 00:20:18,520
和之前类似

464
00:20:18,520 --> 00:20:22,660
我们将将这些键列表展开为几行键

465
00:20:22,660 --> 00:20:24,860
这就是展开操作在这里的作用

466
00:20:24,860 --> 00:20:27,540
然后我们将这些全部收集回列表

467
00:20:27,540 --> 00:20:29,760
然后将其作为单个结果返回

468
00:20:29,760 --> 00:20:31,360
现在定义这个函数

469
00:20:31,360 --> 00:20:32,520
然后运行它

470
00:20:32,520 --> 00:20:37,400
仅查找与主体图中产品相关的唯一键

471
00:20:38,550 --> 00:20:40,510
好的，看起来我们

472
00:20:40,510 --> 00:20:43,860
在进行实体提取时并没有太多限制

473
00:20:43,860 --> 00:20:46,820
这次语言模型实际上发现了许多不同键

474
00:20:46,820 --> 00:20:48,560
在创建这些实体时

475
00:20:48,560 --> 00:20:50,240
在不同产品之间

476
00:20:50,240 --> 00:20:54,300
这里展示了从评论中推导出的不同属性

477
00:20:54,300 --> 00:20:56,599
它识别出了材料等信息

478
00:20:56,599 --> 00:20:57,719
关于不同特征的

479
00:20:57,719 --> 00:21:00,379
我不确定书架深度似乎出现在某个地方

480
00:21:00,379 --> 00:21:02,099
必须查看Markdown文本

481
00:21:02,099 --> 00:21:04,940
才能看到语言模型为何发现这些不同属性

482
00:21:06,020 --> 00:21:09,720
根据提取时使用的具体评论

483
00:21:09,720 --> 00:21:12,400
有些评论可能提到了这些属性

484
00:21:12,400 --> 00:21:13,400
其他则没有

485
00:21:13,400 --> 00:21:16,600
因此这些不会在所有属性中一致

486
00:21:16,600 --> 00:21:19,040
但其中一些可能是特别的

487
00:21:19,040 --> 00:21:21,400
我认为名称会共同出现

488
00:21:21,400 --> 00:21:25,110
稍后你会看到我们如何将这个键列表

489
00:21:25,110 --> 00:21:28,270
与领域图中的可用键进行关联

490
00:21:28,270 --> 00:21:30,920
这就是我们如何同步所有内容的方法

491
00:21:30,920 --> 00:21:34,100
接下来定义的效用函数非常相似

492
00:21:34,100 --> 00:21:36,840
但现在我们将注意力转向领域图

493
00:21:36,840 --> 00:21:42,580
在领域图中我们已经知道如何查找领域图中的标签

494
00:21:42,580 --> 00:21:47,850
我们知道存在没有实体标签的标签

495
00:21:47,850 --> 00:21:49,850
如果我们匹配特定标签

496
00:21:49,850 --> 00:21:50,710
比如产品

497
00:21:50,710 --> 00:21:53,530
要查找产品的唯一领域键

498
00:21:53,530 --> 00:21:55,330
我们将进行头部匹配

499
00:21:55,330 --> 00:21:58,490
然后过滤掉带有实体的项

500
00:21:58,490 --> 00:22:00,380
因为这些属于主体图

501
00:22:00,380 --> 00:22:03,100
然后我们按照之前处理函数的方法

502
00:22:03,100 --> 00:22:07,020
接下来我们将获取这些域节点的唯一键

503
00:22:07,020 --> 00:22:08,889
然后将这些键收集到列表中

504
00:22:08,889 --> 00:22:12,209
因此如果我们查找域标签的唯一属性键

505
00:22:12,209 --> 00:22:16,949
这应该是一致的，因为这些都来自同一个CSV文件

506
00:22:16,949 --> 00:22:18,189
这是一个更小的列表

507
00:22:18,189 --> 00:22:21,089
它很可能与CSV文件中的内容完全对应

508
00:22:21,089 --> 00:22:22,129
这是产品名称

509
00:22:22,129 --> 00:22:23,249
价格描述

510
00:22:23,249 --> 00:22:25,109
产品ID

511
00:22:26,700 --> 00:22:28,180
为了辅助这一过程

512
00:22:28,180 --> 00:22:30,940
我们将定义一个名为normalize_key的辅助函数

513
00:22:30,940 --> 00:22:33,600
你可以为特定标签

514
00:22:33,600 --> 00:22:35,760
输入需要归一化的键是什么

515
00:22:35,920 --> 00:22:37,760
这个函数的作用

516
00:22:37,760 --> 00:22:39,520
会将键转为小写

517
00:22:39,520 --> 00:22:41,400
去除多余空格

518
00:22:41,400 --> 00:22:42,659
这没什么帮助

519
00:22:42,659 --> 00:22:45,539
如果存在前缀的话

520
00:22:45,539 --> 00:22:47,439
其中前缀是标签本身

521
00:22:47,439 --> 00:22:49,130
将其移除

522
00:22:49,130 --> 00:22:52,510
例如产品名称会变为name

523
00:22:52,510 --> 00:22:58,170
这样可以轻松与主体图的name键关联

524
00:22:58,170 --> 00:23:01,790
项目名称会变为name

525
00:23:01,790 --> 00:23:03,910
产品空间名称也会变为name

526
00:23:03,910 --> 00:23:07,070
当然像价格这样的属性键仍保持price

527
00:23:07,070 --> 00:23:10,220
不会被改变，所以再次

528
00:23:10,220 --> 00:23:11,760
实现非常直接

529
00:23:11,760 --> 00:23:16,400
但这样做的目的是让属性键更容易比较

530
00:23:16,400 --> 00:23:17,880
然后查看一些示例

531
00:23:17,880 --> 00:23:21,719
仅作合理性检查看起来正常

532
00:23:22,199 --> 00:23:27,359
接下来要编写的实用函数是用于关联特定标签的键

533
00:23:27,359 --> 00:23:30,920
这将利用我们已有的实用函数

534
00:23:30,920 --> 00:23:33,360
现在看看实现代码

535
00:23:33,360 --> 00:23:37,389
我们将在这里导入Python的新库rapidfuzz

536
00:23:37,389 --> 00:23:40,249
主要用于文本相似度评分

537
00:23:40,249 --> 00:23:42,900
这是基于编辑距离的简单评分

538
00:23:42,900 --> 00:23:45,140
实际上有多种方法来判断

539
00:23:45,140 --> 00:23:47,440
文本字符串是否高度相似

540
00:23:47,440 --> 00:23:51,540
rapidfuzz是该领域功能强大的库

541
00:23:51,540 --> 00:23:53,040
给定特定标签

542
00:23:53,040 --> 00:23:56,220
实体节点和域节点的键

543
00:23:56,220 --> 00:24:00,669
我们将查看相似度阈值

544
00:24:00,669 --> 00:24:02,889
这些键如何相互关联

545
00:24:02,889 --> 00:24:06,870
根据rapidfuzz的fuzz函数评分

546
00:24:06,870 --> 00:24:09,270
对于高度相关的键

547
00:24:09,270 --> 00:24:10,870
我们将配对并说明

548
00:24:10,870 --> 00:24:14,990
这些键值得比较值

549
00:24:14,990 --> 00:24:17,070
现在详细看一下

550
00:24:17,379 --> 00:24:18,499
相关键

551
00:24:18,499 --> 00:24:19,959
所以我们想要配对的键

552
00:24:19,959 --> 00:24:21,360
初始状态为空

553
00:24:21,360 --> 00:24:25,100
我们将遍历实体键集合中的所有键

554
00:24:25,100 --> 00:24:26,520
采用经典风格

555
00:24:26,520 --> 00:24:27,520
我们将使用for循环

556
00:24:27,520 --> 00:24:30,610
在for循环中遍历所有实体键

557
00:24:30,610 --> 00:24:33,470
然后在其中遍历所有域键

558
00:24:33,470 --> 00:24:34,790
对于每一对组合

559
00:24:34,790 --> 00:24:37,310
我们将考虑它们的相关性程度

560
00:24:37,310 --> 00:24:40,060
我们将对每个键进行归一化处理

561
00:24:40,060 --> 00:24:44,300
由于快速模糊相似度分数从0到100

562
00:24:44,300 --> 00:24:48,620
我们将反转这个值使其更像相似度评分

563
00:24:48,620 --> 00:24:50,500
我们现在

564
00:24:50,500 --> 00:24:55,700
计算归一化域键与实体键的比率

565
00:24:55,940 --> 00:24:57,940
这应该就是模糊相似度

566
00:24:57,940 --> 00:24:58,500
现在

567
00:24:58,500 --> 00:25:01,820
我们希望模糊相似度超过相似度阈值

568
00:25:01,820 --> 00:25:04,140
这是传递给函数的参数

569
00:25:04,760 --> 00:25:07,500
当前默认值设为0.9

570
00:25:07,500 --> 00:25:09,980
如果超过该阈值

571
00:25:09,980 --> 00:25:12,650
我们将将其添加到相关键

572
00:25:12,650 --> 00:25:14,930
作为有效配对

573
00:25:14,930 --> 00:25:16,870
我们继续对这些键进行排序

574
00:25:16,870 --> 00:25:17,659
然后

575
00:25:17,659 --> 00:25:21,339
以便更容易查看高度相关的项

576
00:25:21,339 --> 00:25:22,699
Verse的相关性较低

577
00:25:22,699 --> 00:25:26,870
我们将取最高相关性的一项后续使用

578
00:25:26,870 --> 00:25:27,350
所以

579
00:25:27,350 --> 00:25:28,590
在定义该函数后

580
00:25:28,590 --> 00:25:29,510
我们将继续

581
00:25:29,510 --> 00:25:33,590
这部分只是尝试演示

582
00:25:34,800 --> 00:25:37,080
让我们定义产品函数

583
00:25:37,080 --> 00:25:39,840
将查找所有唯一实体键

584
00:25:39,840 --> 00:25:41,020
查找域键

585
00:25:41,020 --> 00:25:44,200
将其传递给此函数并查看结果

586
00:25:44,200 --> 00:25:45,560
对于产品

587
00:25:45,560 --> 00:25:48,520
可以看到名称与产品名称完全匹配

588
00:25:48,520 --> 00:25:50,420
价格与价格完全匹配

589
00:25:50,420 --> 00:25:52,900
描述与描述完全匹配

590
00:25:52,900 --> 00:25:56,260
但设计描述的相关性较低

591
00:25:56,260 --> 00:25:58,500
尺寸与描述的相关性低

592
00:25:58,500 --> 00:26:00,350
这些效果不佳

593
00:26:00,350 --> 00:26:02,250
我们设置的阈值是多少

594
00:26:02,250 --> 00:26:02,710
是的

595
00:26:02,710 --> 00:26:04,690
我们要求相似度为0.5

596
00:26:04,690 --> 00:26:07,350
可以尝试不同值查看结果差异

597
00:26:07,350 --> 00:26:08,020
你得到

598
00:26:08,020 --> 00:26:09,660
默认值0.9

599
00:26:09,660 --> 00:26:13,460
是经典高阈值设置

600
00:26:13,460 --> 00:26:14,340
好的

601
00:26:14,340 --> 00:26:16,320
这里还有一个背景信息

602
00:26:16,320 --> 00:26:18,659
接下来我们将把这些内容整合起来

603
00:26:18,659 --> 00:26:21,479
我们现在能够关联特定标签

604
00:26:21,479 --> 00:26:23,579
在主体图和领域图中

605
00:26:23,579 --> 00:26:25,659
这些标签的键值

606
00:26:25,659 --> 00:26:27,339
这些良好配对的作用

607
00:26:27,339 --> 00:26:30,739
实际判断两个节点是否为同一节点

608
00:26:30,739 --> 00:26:34,099
这一切都是基于实体解析技术

609
00:26:34,099 --> 00:26:37,580
这是一种实现目标的技术方法

610
00:26:37,580 --> 00:26:39,160
这是一个不错的基准方案

611
00:26:39,160 --> 00:26:43,870
它完美适配当前数据集，可能对其他数据集也有效

612
00:26:43,870 --> 00:26:45,630
你需要采用多种技术手段

613
00:26:45,630 --> 00:26:48,190
当然可以想象构建一个完整代理系统

614
00:26:48,190 --> 00:26:50,850
只需针对现有数据

615
00:26:50,850 --> 00:26:53,470
确定最适合的解析技术

616
00:26:53,650 --> 00:26:54,990
但今天我们

617
00:26:54,990 --> 00:26:56,610
需要做出一些假设

618
00:26:56,610 --> 00:26:59,150
接下来要使用的函数是

619
00:26:59,150 --> 00:27:03,389
在处理new four j数据时调用加密方法

620
00:27:03,389 --> 00:27:07,250
加密库也支持字符串比较方法

621
00:27:07,250 --> 00:27:11,490
可用的值相似度函数之一是jo winkler距离

622
00:27:11,490 --> 00:27:14,230
这本质上是一种字符串比较方法

623
00:27:14,230 --> 00:27:15,230
类似于

624
00:27:15,230 --> 00:27:19,190
你可能使用向量相似度需要计算嵌入向量

625
00:27:19,190 --> 00:27:22,420
也可以通过多种方式计算文本距离

626
00:27:22,420 --> 00:27:27,139
gerald winkler通过计算两字符串的编辑距离

627
00:27:27,139 --> 00:27:30,059
主要评估需要进行的微小修改次数

628
00:27:30,059 --> 00:27:32,779
只需比较字符串a和字符串b

629
00:27:32,779 --> 00:27:36,480
需要进行多少次编辑使两者相同

630
00:27:36,480 --> 00:27:39,520
结果值介于0到1之间

631
00:27:39,520 --> 00:27:41,760
数值呈反向关系

632
00:27:41,760 --> 00:27:42,520
0表示完全匹配

633
00:27:42,520 --> 00:27:43,840
意味着精确一致

634
00:27:43,840 --> 00:27:47,470
1表示完全无匹配

635
00:27:47,470 --> 00:27:50,770
near for j的技术相似度库

636
00:27:50,770 --> 00:27:53,040
包含gerald winkler计算方法

637
00:27:53,040 --> 00:27:54,860
还可以使用汉明距离

638
00:27:54,860 --> 00:27:56,240
莱文斯坦距离

639
00:27:56,240 --> 00:27:58,000
还有瑟尔森-迪斯相似度

640
00:27:58,000 --> 00:27:59,550
以及模糊匹配

641
00:27:59,550 --> 00:28:00,590
当然如果需要

642
00:28:00,590 --> 00:28:04,190
也可以使用向量嵌入进行余弦相似度

643
00:28:04,190 --> 00:28:05,170
这些各有不同

644
00:28:05,170 --> 00:28:06,010
特征特性

645
00:28:06,010 --> 00:28:08,150
就像我们之前所做的所有工作

646
00:28:08,150 --> 00:28:10,389
在日志raft构建过程中

647
00:28:10,389 --> 00:28:12,269
可以自行选择最适合的方案

648
00:28:12,269 --> 00:28:12,509
如果

649
00:28:12,509 --> 00:28:14,909
针对特定数据集的数据

650
00:28:14,909 --> 00:28:17,880
jo winkler距离完全适用

651
00:28:17,880 --> 00:28:20,540
所以你可以看看杰瑞·温克勒在行动中的样子

652
00:28:20,540 --> 00:28:22,020
仅使用纯密码

653
00:28:22,020 --> 00:28:25,659
如果你查看此处匹配子句中的密码查询

654
00:28:25,659 --> 00:28:30,630
实际上我们将匹配特定标签下的实体和域名对

655
00:28:30,630 --> 00:28:34,130
这里我们将寻找双方具有相同实体标签

656
00:28:34,130 --> 00:28:38,260
当然实体节点还带有额外标签_实体

657
00:28:38,260 --> 00:28:40,380
然后结合实体和域名

658
00:28:40,380 --> 00:28:43,240
然后计算这个乔温克勒距离得分

659
00:28:43,240 --> 00:28:45,820
我们将通过过滤器传递该得分

660
00:28:45,820 --> 00:28:47,900
得分必须小于0.4

661
00:28:47,900 --> 00:28:50,820
如果你记得得分为零表示完美匹配

662
00:28:50,820 --> 00:28:53,690
所以我们在这里采用相反的评分方式

663
00:28:53,690 --> 00:28:55,270
我们寻找低值

664
00:28:55,270 --> 00:28:56,530
在此进行过滤

665
00:28:56,530 --> 00:28:58,860
然后返回这些值进行查看

666
00:28:58,860 --> 00:29:00,160
在这个例子中

667
00:29:00,160 --> 00:29:02,690
我们将传入一些查询参数

668
00:29:02,690 --> 00:29:05,310
我们寻找实体标签为产品

669
00:29:05,310 --> 00:29:08,530
在主体图和域名图上均适用

670
00:29:08,530 --> 00:29:09,810
在主体图中

671
00:29:09,810 --> 00:29:11,930
我们将查找实体键名

672
00:29:11,930 --> 00:29:15,179
域名键将为产品_名称

673
00:29:15,179 --> 00:29:15,739
好的

674
00:29:15,739 --> 00:29:17,470
可以看到这些是完美得分

675
00:29:17,470 --> 00:29:19,370
哥德堡桌子和哥德堡桌子

676
00:29:19,370 --> 00:29:20,710
这些完全相同

677
00:29:20,710 --> 00:29:23,570
当然你会预期它们得分很低

678
00:29:23,570 --> 00:29:25,110
你可以尝试不同值

679
00:29:25,110 --> 00:29:26,930
观察效果

680
00:29:26,930 --> 00:29:30,500
如果使用稍低的阈值

681
00:29:30,500 --> 00:29:31,540
比如0.5

682
00:29:32,540 --> 00:29:35,880
可以看到哥德堡电缆和沃斯塔书架

683
00:29:35,880 --> 00:29:39,000
显然并不差

684
00:29:39,000 --> 00:29:40,860
哥德堡桌子和斯德哥尔摩椅子

685
00:29:40,860 --> 00:29:43,320
我不确定文本上有多相似

686
00:29:43,320 --> 00:29:45,170
但距离计算显示如此

687
00:29:45,170 --> 00:29:47,610
这就是为什么实践中通常需要

688
00:29:47,610 --> 00:29:48,930
设置非常低的阈值

689
00:29:48,930 --> 00:29:49,969
比如1.1

690
00:29:49,969 --> 00:29:53,729
使结果尽可能接近完全相同

691
00:29:54,370 --> 00:29:56,650
让我们详细解释这个查询

692
00:29:56,650 --> 00:29:58,290
这正是相同的查询

693
00:29:58,290 --> 00:30:00,200
我们添加了一个额外部分

694
00:30:00,200 --> 00:30:03,360
当我们找到两个低阈值实体时

695
00:30:03,360 --> 00:30:06,040
现在我们稍作调整

696
00:30:06,040 --> 00:30:09,929
在实体与域名节点的配对中

697
00:30:09,929 --> 00:30:11,289
我们将使用where子句

698
00:30:11,289 --> 00:30:14,009
仅对温克勒距离进行约束

699
00:30:14,009 --> 00:30:16,570
将阈值设为0.1

700
00:30:16,570 --> 00:30:19,920
对于通过对应关系的任何配对

701
00:30:19,920 --> 00:30:24,500
我们将实际创建从实体到域节点的关系

702
00:30:24,500 --> 00:30:26,780
因此我们将使用固定类型

703
00:30:26,780 --> 00:30:29,599
它不会参数化，对应于

704
00:30:29,599 --> 00:30:34,719
因此关系将是该实体节点与该域节点对应

705
00:30:34,719 --> 00:30:36,719
现在我们将使用两个子句

706
00:30:36,719 --> 00:30:38,940
以防您多次运行此操作

707
00:30:38,940 --> 00:30:41,700
在执行合并时这非常有用

708
00:30:41,700 --> 00:30:44,389
Merge在Neo4j中类似于Upsert操作

709
00:30:44,389 --> 00:30:48,409
它实际上基于行为有两个子句

710
00:30:48,409 --> 00:30:51,169
如果合并找到匹配项

711
00:30:51,169 --> 00:30:52,649
实际上你所描述的内容

712
00:30:52,649 --> 00:30:55,639
则存在匹配时的子句

713
00:30:55,639 --> 00:30:58,659
然后后续操作将被执行

714
00:30:58,659 --> 00:31:01,599
或者首次创建时

715
00:31:01,599 --> 00:31:05,840
当执行合并后会调用创建子句

716
00:31:05,840 --> 00:31:07,640
如果首次运行时

717
00:31:07,640 --> 00:31:08,600
将调用创建操作

718
00:31:08,600 --> 00:31:09,900
我们将设置此值

719
00:31:09,900 --> 00:31:12,030
创建时间并添加时间戳

720
00:31:12,030 --> 00:31:14,270
如果已创建过

721
00:31:14,270 --> 00:31:15,630
再次进行匹配时

722
00:31:15,630 --> 00:31:18,190
我们将为更新时间添加时间戳

723
00:31:18,190 --> 00:31:20,840
每次运行都会更新

724
00:31:20,840 --> 00:31:21,480
好的

725
00:31:21,480 --> 00:31:27,140
此查询覆盖所有对应产品效果良好

726
00:31:28,660 --> 00:31:30,840
此Cypher查询完全符合需求

727
00:31:30,840 --> 00:31:33,280
现在将其封装为函数调用

728
00:31:33,280 --> 00:31:36,900
传入实体键和域键

729
00:31:36,900 --> 00:31:40,040
以及所需的相似度阈值

730
00:31:40,040 --> 00:31:42,260
此处查询基本相同

731
00:31:42,260 --> 00:31:45,980
可以看到参数作为查询参数传递

732
00:31:45,980 --> 00:31:48,220
从函数参数中传入

733
00:31:48,520 --> 00:31:49,120
同样

734
00:31:49,120 --> 00:31:53,380
我们直接运行此操作测试产品名称

735
00:31:53,380 --> 00:31:55,940
这两个实体的不同键

736
00:31:55,940 --> 00:31:58,310
以及域图中的对应键

737
00:31:58,310 --> 00:31:58,870
很好

738
00:31:58,870 --> 00:32:04,950
在主体图和域图间找到十项合理关系

739
00:32:04,950 --> 00:32:07,010
为完整性考虑

740
00:32:07,010 --> 00:32:09,810
虽然我们知道可以连接所需产品

741
00:32:09,810 --> 00:32:11,900
对所有可用实体执行此操作

742
00:32:11,900 --> 00:32:14,500
以关联并连接所有主体节点

743
00:32:14,500 --> 00:32:16,380
到对应域节点

744
00:32:16,380 --> 00:32:18,200
我们只需添加循环

745
00:32:18,200 --> 00:32:21,159
遍历所有唯一实体标签

746
00:32:21,159 --> 00:32:25,239
从实体侧关联到域侧

747
00:32:25,239 --> 00:32:28,919
主体节点与域节点将被连接

748
00:32:29,690 --> 00:32:31,350
可以看到产品已成功连接

749
00:32:31,350 --> 00:32:32,110
当然

750
00:32:32,110 --> 00:32:34,490
位置实际上没有关联

751
00:32:34,490 --> 00:32:35,770
现在它确实可以发行了

752
00:32:35,770 --> 00:32:36,970
或者两者都没有功能

753
00:32:36,970 --> 00:32:38,940
但这是我们预期的

754
00:32:38,940 --> 00:32:40,220
现在发生了什么

755
00:32:40,220 --> 00:32:42,100
经过所有这些工作

756
00:32:42,100 --> 00:32:47,340
你终于得到了一个完整的领域图，它是从CSV文件构建的

757
00:32:47,340 --> 00:32:52,270
你还拥有一个词汇图和一个主题图，它们是由Markdown文件创建的

758
00:32:52,270 --> 00:32:53,810
随着这最后一步

759
00:32:53,810 --> 00:32:58,280
你已将主题图中的实体与领域节点中的实体连接

760
00:32:58,280 --> 00:33:00,880
现在你拥有了完全连接的知识图谱

761
00:33:00,880 --> 00:33:02,220
做得很好

