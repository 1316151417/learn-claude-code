1
00:00:00,260 --> 00:00:01,980
要构建多智能体系统

2
00:00:01,980 --> 00:00:05,500
你将使用谷歌的ADK或智能体开发工具包

3
00:00:05,500 --> 00:00:07,930
这是一个用于开发智能体的框架

4
00:00:07,930 --> 00:00:08,950
在本课中

5
00:00:08,950 --> 00:00:14,130
你将学习如何创建和运行单个智能体以及整个智能体团队

6
00:00:14,130 --> 00:00:16,600
让我们开始本课的学习

7
00:00:16,600 --> 00:00:20,000
你将熟悉谷歌的智能体开发工具包

8
00:00:20,000 --> 00:00:23,820
并将使用它来构建整个多智能体系统

9
00:00:23,820 --> 00:00:24,700
在本课中

10
00:00:24,700 --> 00:00:27,980
你将学习如何使用ADK创建和运行智能体

11
00:00:27,980 --> 00:00:29,540
以及我们正在导入的内容

12
00:00:29,540 --> 00:00:30,880
当然包括标准的os模块

13
00:00:30,880 --> 00:00:33,580
然后是从谷歌ADK本身导入的大量内容

14
00:00:33,580 --> 00:00:35,180
我们将导入这个智能体

15
00:00:35,180 --> 00:00:39,120
这将是描述智能体核心功能的关键

16
00:00:39,120 --> 00:00:40,360
与大型语言模型交互

17
00:00:40,360 --> 00:00:42,000
我们将使用轻量级LLM库

18
00:00:42,000 --> 00:00:43,240
所以在这里进行导入

19
00:00:43,240 --> 00:00:47,560
这是一个让谷歌80K与OpenAI通信的小封装

20
00:00:47,560 --> 00:00:51,000
同时我们还需要为智能体准备记忆功能

21
00:00:51,000 --> 00:00:52,740
我们将使用记忆会话服务

22
00:00:52,740 --> 00:00:55,200
最后智能体还需要一个运行方式

23
00:00:55,200 --> 00:00:56,800
因此导入运行器

24
00:00:56,800 --> 00:00:58,480
我们还有一些类型相关的代码

25
00:00:58,480 --> 00:01:00,880
这些对整体功能影响不大

26
00:01:00,880 --> 00:01:03,850
让我们确保所有导入都正确

27
00:01:03,850 --> 00:01:05,530
所有库都已导入

28
00:01:05,530 --> 00:01:09,800
接下来是定义将要使用的模型

29
00:01:09,800 --> 00:01:12,420
本课程将使用OpenAI

30
00:01:12,420 --> 00:01:13,960
现在开始导入

31
00:01:13,960 --> 00:01:17,460
我们将定义模型本身为GPT-4o

32
00:01:17,460 --> 00:01:19,219
再次使用GPT-4o

33
00:01:19,219 --> 00:01:23,590
我们将通过轻量级LLM调用OpenAI API

34
00:01:23,590 --> 00:01:28,810
现在尝试一个简单的聊天完成示例

35
00:01:28,810 --> 00:01:30,820
如果你查看这里的聊天内容

36
00:01:30,820 --> 00:01:33,340
你会注意到我们正在设置一条消息

37
00:01:33,340 --> 00:01:34,740
即将发送给OpenAI

38
00:01:34,740 --> 00:01:35,860
并询问

39
00:01:35,860 --> 00:01:37,940
你准备好了吗

40
00:01:39,060 --> 00:01:40,600
如果一切顺利

41
00:01:40,600 --> 00:01:42,240
我们将收到OpenAI的成功响应

42
00:01:42,240 --> 00:01:46,440
确认系统正常运行并查看响应模型

43
00:01:46,440 --> 00:01:48,520
这里包含大量信息

44
00:01:48,520 --> 00:01:52,080
但关键部分是响应包含OpenAI的消息

45
00:01:52,080 --> 00:01:52,520
回答是

46
00:01:52,520 --> 00:01:53,060
我已准备就绪

47
00:01:53,060 --> 00:01:54,580
今天如何协助您

48
00:01:54,580 --> 00:01:56,440
OpenAI已就绪

49
00:01:56,440 --> 00:01:58,160
我们今天还将使用new for j

50
00:01:58,160 --> 00:01:59,600
因此导入辅助库

51
00:01:59,600 --> 00:02:03,320
这将新四j与谷歌avk以优雅的方式结合

52
00:02:03,320 --> 00:02:06,960
这个库是我们可以查看以了解细节的

53
00:02:06,960 --> 00:02:08,479
正在发生的具体细节

54
00:02:08,479 --> 00:02:10,160
我们将要使用的导入内容

55
00:02:10,160 --> 00:02:14,340
仅从新四j for eighty k导入图数据库库

56
00:02:14,340 --> 00:02:16,500
让我们看看这些细节

57
00:02:16,500 --> 00:02:17,160
好的

58
00:02:17,160 --> 00:02:19,320
现在我们进入了新四j for adk

59
00:02:19,320 --> 00:02:21,200
你可以看到它开始得相当简单

60
00:02:21,200 --> 00:02:23,180
我们从操作系统导入了一些内容

61
00:02:23,180 --> 00:02:25,269
当然加载了环境

62
00:02:25,269 --> 00:02:27,609
然后从you for j的python包

63
00:02:27,609 --> 00:02:29,409
我们加载了图数据库

64
00:02:29,409 --> 00:02:32,180
你还会得到一个结果类定义

65
00:02:32,180 --> 00:02:32,460
现在

66
00:02:32,460 --> 00:02:34,900
这里许多函数都非常适合

67
00:02:34,900 --> 00:02:37,380
封装如何与me四j交互

68
00:02:37,380 --> 00:02:42,070
并以谷歌aday喜欢的方式呈现结果

69
00:02:42,070 --> 00:02:42,790
其中一个关键

70
00:02:42,790 --> 00:02:48,650
点是结果应返回字典形式，状态为成功

71
00:02:48,650 --> 00:02:50,390
或作为错误

72
00:02:50,390 --> 00:02:54,550
这两个辅助函数可帮助实现，你可以调用success或error

73
00:02:54,550 --> 00:02:56,130
连同其他参数

74
00:02:56,130 --> 00:03:00,050
并从任何调用中获取格式良好的结果

75
00:03:00,050 --> 00:03:05,810
我们随后整合了由谷歌adk处理的辅助库结果

76
00:03:05,810 --> 00:03:07,370
需要易于持久化

77
00:03:07,370 --> 00:03:09,570
此处调用python的函数

78
00:03:09,570 --> 00:03:13,310
遍历新四j返回的各种结果类型

79
00:03:13,310 --> 00:03:17,459
并将其转换为谷歌adk可读的序列化格式

80
00:03:17,459 --> 00:03:20,410
你可以查看细节以了解具体情况

81
00:03:20,410 --> 00:03:21,130
关键部分

82
00:03:21,130 --> 00:03:21,570
当然

83
00:03:21,570 --> 00:03:26,090
是这个处理新四j结果的函数

84
00:03:26,090 --> 00:03:29,150
基本调用python包

85
00:03:29,150 --> 00:03:32,510
将其整合为谷歌adk可轻松使用的结果

86
00:03:32,510 --> 00:03:37,100
每个辅助函数也被上层类使用

87
00:03:37,100 --> 00:03:38,660
名为d四j for adk

88
00:03:38,660 --> 00:03:40,020
这实际上是一个包装器

89
00:03:40,020 --> 00:03:44,329
整合新四j驱动程序，初始化环境变量

90
00:03:44,329 --> 00:03:46,029
提供驱动程序访问权限

91
00:03:46,029 --> 00:03:49,230
然后有一个特殊函数用于发送查询

92
00:03:49,230 --> 00:03:51,370
可以发送任何类型的查询

93
00:03:51,370 --> 00:03:55,190
但使用这些辅助函数重新格式化结果

94
00:03:55,190 --> 00:03:58,160
最终生成谷歌aday友好的结果

95
00:03:58,160 --> 00:04:01,600
由于我们只有一个驱动和连接

96
00:04:01,600 --> 00:04:04,340
我们将使用该类的单例

97
00:04:04,340 --> 00:04:07,680
这是我们将暴露的图数据库变量

98
00:04:07,680 --> 00:04:09,750
并通过所有笔记本使用

99
00:04:09,750 --> 00:04:10,350
好的

100
00:04:10,350 --> 00:04:12,250
我们查看了新四j for eighty k

101
00:04:12,250 --> 00:04:13,870
我们继续使用笔记本

102
00:04:13,870 --> 00:04:17,930
现在一切已就绪，我们可以开始定义智能体本身

103
00:04:17,930 --> 00:04:18,410
好的

104
00:04:18,410 --> 00:04:19,730
我们的新四j包装器已准备就绪

105
00:04:19,730 --> 00:04:21,029
我们继续尝试一下

106
00:04:21,029 --> 00:04:23,850
你可以输入类似四j查询语句

107
00:04:23,850 --> 00:04:26,060
只要这里语法正确

108
00:04:26,060 --> 00:04:28,480
我们发送的四j语句是一个非常简单的声明

109
00:04:28,480 --> 00:04:30,580
除了直接返回结果外不做其他操作

110
00:04:30,580 --> 00:04:32,140
在这里返回结果

111
00:04:32,140 --> 00:04:33,380
结果是一个字符串

112
00:04:33,380 --> 00:04:34,800
新四j已就绪

113
00:04:34,800 --> 00:04:37,920
将结果作为消息变量返回

114
00:04:37,920 --> 00:04:38,920
如果我们运行这个

115
00:04:38,920 --> 00:04:39,880
然后打印结果

116
00:04:39,880 --> 00:04:44,290
你会看到它被封装成一个整洁的字典

117
00:04:44,290 --> 00:04:45,610
包含状态成功

118
00:04:45,610 --> 00:04:50,820
以及包含数据库返回所有行的数组的查询结果

119
00:04:51,720 --> 00:04:53,080
太好了，open ai已就绪

120
00:04:53,080 --> 00:04:54,080
四j已就绪

121
00:04:54,080 --> 00:04:57,840
我们可以开始定义工具和智能体

122
00:04:57,840 --> 00:05:03,000
最终工具定义是定义无工具智能体的重要部分

123
00:05:03,000 --> 00:05:04,500
智能体可以进行大量思考

124
00:05:04,500 --> 00:05:05,540
也许进行一些对话

125
00:05:05,540 --> 00:05:09,350
但无法与环境或周围世界交互

126
00:05:09,350 --> 00:05:11,090
我们将创建一个非常简单的工具

127
00:05:11,090 --> 00:05:14,500
仅用于说明智能体能做什么

128
00:05:14,500 --> 00:05:15,900
Hello World是经典示例

129
00:05:15,900 --> 00:05:16,440
当然

130
00:05:16,440 --> 00:05:20,330
我们将开发智能体工具的Hello World版本

131
00:05:20,330 --> 00:05:21,730
并命名为say_hello

132
00:05:22,850 --> 00:05:25,480
工具可以简单定义为函数

133
00:05:25,480 --> 00:05:26,660
函数只需说Hello

134
00:05:26,660 --> 00:05:29,120
接受单个参数person_name作为字符串

135
00:05:29,120 --> 00:05:30,440
并返回一个字典

136
00:05:30,440 --> 00:05:34,740
当然这个字典是符合Google AK规范的

137
00:05:34,750 --> 00:05:37,669
其中包含几个重要部分

138
00:05:37,669 --> 00:05:39,069
这里有一个文档字符串

139
00:05:39,069 --> 00:05:41,009
编写代码时总是有用的

140
00:05:41,009 --> 00:05:45,050
在开发Google ADK工具时尤其关键

141
00:05:45,050 --> 00:05:50,180
这个文档字符串让Google ADK理解工具功能

142
00:05:50,180 --> 00:05:52,480
会传递给语言模型

143
00:05:52,480 --> 00:05:53,620
当模型被告知

144
00:05:53,620 --> 00:05:55,060
这里列出所有可用工具

145
00:05:55,060 --> 00:05:58,390
以及这些工具的功能描述

146
00:05:58,390 --> 00:05:58,950
所以

147
00:05:58,950 --> 00:06:01,130
我们需要了解几个重要部分

148
00:06:01,130 --> 00:06:03,580
在这里描述工具功能

149
00:06:03,580 --> 00:06:05,900
仅格式化给定姓名的欢迎消息

150
00:06:05,900 --> 00:06:07,960
当然，输入的person_name参数

151
00:06:07,960 --> 00:06:10,429
你描述了正在传递的参数

152
00:06:10,429 --> 00:06:11,709
还有结果

153
00:06:11,709 --> 00:06:13,989
这里的结果在所有工具中保持一致

154
00:06:13,989 --> 00:06:17,669
因为结果是一个谷歌喜欢看到的字典

155
00:06:17,669 --> 00:06:20,049
但你可以在这里添加一些额外细节

156
00:06:20,049 --> 00:06:20,589
例如

157
00:06:20,589 --> 00:06:22,529
如果你知道可能出现的错误类型

158
00:06:22,529 --> 00:06:26,990
也可以在函数内解释这些错误

159
00:06:26,990 --> 00:06:31,630
函数内部操作非常简单

160
00:06:31,630 --> 00:06:34,530
我们将调用新的four j发送查询

161
00:06:34,530 --> 00:06:37,450
我们仍然返回一个问候语给你

162
00:06:37,450 --> 00:06:40,870
然后将其与这个人名连接

163
00:06:40,870 --> 00:06:43,310
这个人名作为函数参数传入

164
00:06:43,310 --> 00:06:47,370
这将作为查询参数传递

165
00:06:47,370 --> 00:06:50,390
每当在new four j语句中看到美元符号时

166
00:06:50,390 --> 00:06:52,530
这意味着这是一个查询参数

167
00:06:52,530 --> 00:06:56,110
在这个传递的字典数组中

168
00:06:56,110 --> 00:06:59,140
你会看到人名被传入为person name

169
00:06:59,140 --> 00:07:01,680
这里会被替换为该变量

170
00:07:01,680 --> 00:07:03,020
并非模板替换

171
00:07:03,020 --> 00:07:04,780
而是作为变量值传递

172
00:07:04,780 --> 00:07:07,000
然后整个查询将执行

173
00:07:07,000 --> 00:07:08,790
现在我们定义这个函数

174
00:07:08,790 --> 00:07:11,490
当然因为这是一个普通函数

175
00:07:11,490 --> 00:07:12,850
我们可以尝试运行它

176
00:07:12,850 --> 00:07:15,520
我们可以打印'向abk问好'

177
00:07:15,520 --> 00:07:21,089
预期看到格式良好的谷歌adk成功结果

178
00:07:21,089 --> 00:07:23,369
发送到four的查询结果

179
00:07:23,369 --> 00:07:24,920
J有回复

180
00:07:24,920 --> 00:07:28,909
向你问好abk完成拼接真棒

181
00:07:28,909 --> 00:07:29,349
现在

182
00:07:29,349 --> 00:07:31,269
关于查询参数的补充说明

183
00:07:31,269 --> 00:07:32,449
我们这样做部分原因

184
00:07:32,449 --> 00:07:34,810
这对任何查询语言都是良好规范

185
00:07:34,810 --> 00:07:36,490
大多数查询语言

186
00:07:36,490 --> 00:07:38,610
都支持查询参数

187
00:07:38,610 --> 00:07:41,390
这样做原因之一是避免注入攻击

188
00:07:41,390 --> 00:07:41,850
没错

189
00:07:41,850 --> 00:07:47,160
防止用户传入类似sql或cipher语句的值

190
00:07:47,160 --> 00:07:49,840
或任何查询语言语句作为值

191
00:07:49,840 --> 00:07:51,860
并将其拼接到字符串中

192
00:07:51,860 --> 00:07:53,770
可能导致各种混乱

193
00:07:53,770 --> 00:07:56,030
因此传入查询参数

194
00:07:56,030 --> 00:07:56,690
在这里

195
00:07:56,690 --> 00:07:57,090
例如

196
00:07:57,090 --> 00:08:00,470
如果传入名称并说实际名称是hey

197
00:08:00,470 --> 00:08:01,940
此处返回字符串

198
00:08:01,940 --> 00:08:05,800
这可能被恶意代码替换

199
00:08:05,800 --> 00:08:08,440
如果直接拼接为字符串

200
00:08:08,440 --> 00:08:10,800
各种坏事可能发生

201
00:08:10,800 --> 00:08:14,340
因为它是一个仍然作为变量行为的查询参数

202
00:08:14,340 --> 00:08:15,420
它会被传递进来

203
00:08:15,420 --> 00:08:18,060
它会与其他字符串进行字符串拼接

204
00:08:18,060 --> 00:08:23,800
结果就是简单的hello对稍显友好的恶意注入攻击

205
00:08:23,800 --> 00:08:25,300
当然这已经被避免了

206
00:08:25,300 --> 00:08:28,529
现在我们有了一个基础工具

207
00:08:28,529 --> 00:08:31,270
我们可以定义一个使用该工具的代理

208
00:08:31,270 --> 00:08:33,590
现在定义代理有几个组件

209
00:08:33,590 --> 00:08:35,390
所有框架中都有共同点

210
00:08:35,390 --> 00:08:37,870
它们会以相同理念的不同变体实现

211
00:08:37,870 --> 00:08:39,809
让我们看看谷歌内部的情况

212
00:08:39,809 --> 00:08:41,909
今天定义一个代理

213
00:08:43,840 --> 00:08:45,040
如果你还记得之前

214
00:08:45,040 --> 00:08:48,230
我们从google a k导入了这个代理类

215
00:08:48,230 --> 00:08:50,230
我们将创建该类的实例

216
00:08:50,230 --> 00:08:51,910
它需要大量参数

217
00:08:51,910 --> 00:08:56,000
首先重要的是每个代理都需在此命名

218
00:08:56,000 --> 00:08:56,780
我们将其命名为hello

219
00:08:56,780 --> 00:08:58,530
Agent_v_one

220
00:08:58,530 --> 00:09:03,050
以防同时需要多个版本代理

221
00:09:03,050 --> 00:09:06,290
或需要不同版本的指令

222
00:09:06,290 --> 00:09:10,130
明确代理版本对调试非常有帮助

223
00:09:10,130 --> 00:09:11,010
稍后

224
00:09:11,010 --> 00:09:13,740
你还需要传入使用的模型

225
00:09:13,740 --> 00:09:14,620
如果你还记得

226
00:09:14,620 --> 00:09:18,260
我们之前定义llm为通过light调用

227
00:09:18,260 --> 00:09:19,660
Llm连接到open ai

228
00:09:19,660 --> 00:09:21,190
这里我们将使用该模型

229
00:09:21,190 --> 00:09:25,750
接下来这两个对谷歌adk的协调执行至关重要

230
00:09:25,750 --> 00:09:27,960
和执行代理

231
00:09:27,960 --> 00:09:30,760
首先是代理的描述

232
00:09:30,760 --> 00:09:33,440
类似于工具的文档字符串

233
00:09:33,440 --> 00:09:36,290
描述该代理的功能

234
00:09:36,290 --> 00:09:37,250
让谷歌adk

235
00:09:37,250 --> 00:09:40,779
也让其他代理理解该代理的目的

236
00:09:40,779 --> 00:09:43,899
以及何时应调用该代理

237
00:09:43,899 --> 00:09:45,379
而非自行处理

238
00:09:45,379 --> 00:09:48,250
这称为代理委派

239
00:09:48,290 --> 00:09:51,270
这是其他代理如何处理该代理的依据

240
00:09:51,270 --> 00:09:52,670
对于代理本身

241
00:09:52,670 --> 00:09:54,330
需提供一些指令

242
00:09:54,330 --> 00:09:57,230
指令与你在提示工程中所做的类似

243
00:09:57,230 --> 00:09:57,730
嗯

244
00:09:57,730 --> 00:09:58,990
当你进行提示工程时

245
00:09:58,990 --> 00:10:00,530
并定义系统提示

246
00:10:00,530 --> 00:10:02,430
这是为llm设定的提示

247
00:10:02,430 --> 00:10:04,960
与你在那里的操作相同

248
00:10:04,960 --> 00:10:06,700
这是一个hello world代理

249
00:10:06,700 --> 00:10:08,680
当然非常有用

250
00:10:08,680 --> 00:10:11,240
这是一个乐于助人的助手将与用户聊天

251
00:10:11,240 --> 00:10:14,010
它实际上只有一个想要使用的工具

252
00:10:14,010 --> 00:10:15,450
在这里描述这个工具

253
00:10:15,450 --> 00:10:18,150
因此代理不仅从工具定义中理解

254
00:10:18,150 --> 00:10:21,850
还要从你的指令中了解如何思考该工具

255
00:10:21,850 --> 00:10:24,029
以及何时使用该工具，所以在这里

256
00:10:24,029 --> 00:10:25,629
如果用户提供他们的姓名

257
00:10:25,629 --> 00:10:26,409
你知道

258
00:10:26,409 --> 00:10:30,200
使用say hello工具提供个性化问候

259
00:10:30,200 --> 00:10:32,200
哀悼

260
00:10:33,440 --> 00:10:34,440
然后最后一部分

261
00:10:34,440 --> 00:10:36,360
当然我们需要让这些工具可用

262
00:10:36,360 --> 00:10:40,480
工具作为函数名数组传递

263
00:10:40,480 --> 00:10:41,440
所以我们需要传入

264
00:10:41,440 --> 00:10:42,300
Say hello

265
00:10:42,300 --> 00:10:44,900
然后拥有该工具的代理

266
00:10:44,900 --> 00:10:46,260
知道如何使用该工具

267
00:10:46,260 --> 00:10:47,800
因为我们提供了指令

268
00:10:47,800 --> 00:10:48,780
和其他代理

269
00:10:48,780 --> 00:10:53,980
如果有其他代理现在知道这个代理的角色

270
00:10:53,980 --> 00:10:55,120
代理拥有一个工具

271
00:10:55,120 --> 00:10:57,490
并且有关于如何使用该工具的指令

272
00:10:57,490 --> 00:10:59,050
现在我们需要运行代理

273
00:10:59,050 --> 00:11:03,250
这是创建基础遗传系统最后一步

274
00:11:03,250 --> 00:11:06,250
代理必须有一个执行环境

275
00:11:06,250 --> 00:11:07,970
所以你看这个图表

276
00:11:07,970 --> 00:11:09,890
你会看到在这个框里

277
00:11:09,890 --> 00:11:11,930
这就是执行环境发生的地方

278
00:11:11,930 --> 00:11:15,670
有一个运行器类管理所有事件循环

279
00:11:15,670 --> 00:11:17,910
基本上用于调用LLM

280
00:11:17,910 --> 00:11:20,430
将LLM结果传递给特定代理

281
00:11:20,430 --> 00:11:22,210
并协调所有代理本身

282
00:11:22,210 --> 00:11:23,610
以及它们的执行方式

283
00:11:23,610 --> 00:11:26,910
每个运行器还访问各种服务

284
00:11:26,910 --> 00:11:29,430
无论是内存服务例如

285
00:11:29,430 --> 00:11:31,810
进行实际内存存储

286
00:11:31,810 --> 00:11:34,970
或者可以使用数据库技术作为记忆

287
00:11:34,970 --> 00:11:36,690
这提供存储访问

288
00:11:36,690 --> 00:11:40,150
执行逻辑在执行循环内

289
00:11:40,150 --> 00:11:43,550
这里是实际运行和协调代理的步骤

290
00:11:43,550 --> 00:11:47,170
代理是并行、顺序还是循环执行

291
00:11:47,170 --> 00:11:50,950
所有这些共同构成代理的执行环境

292
00:11:50,950 --> 00:11:51,730
好的

293
00:11:51,730 --> 00:11:53,590
我们将手动实现这一点

294
00:11:53,590 --> 00:11:56,730
然后展示如何封装为便捷方法

295
00:11:56,730 --> 00:11:59,260
在使用Google ADK进行开发时

296
00:11:59,260 --> 00:12:02,460
Google ADK提供了优秀的工具定义代理

297
00:12:02,460 --> 00:12:04,760
并运行代理的实际工具

298
00:12:04,760 --> 00:12:07,800
并提供所需完整执行环境

299
00:12:07,800 --> 00:12:09,340
我们将手动完成这些步骤

300
00:12:09,340 --> 00:12:10,200
在笔记本中进行

301
00:12:10,200 --> 00:12:11,860
那么我们一步一步来

302
00:12:11,860 --> 00:12:14,620
然后将其封装成一个小助手

303
00:12:14,940 --> 00:12:18,780
你需要准备几个实际设置执行环境的事项

304
00:12:18,780 --> 00:12:21,520
每个运行时实际上都在一个会话中运行

305
00:12:21,520 --> 00:12:21,820
当然

306
00:12:21,820 --> 00:12:25,740
当然可以有多个在生产环境中运行的会话

307
00:12:25,740 --> 00:12:26,800
我们将使用单一会话

308
00:12:26,800 --> 00:12:29,630
接下来我们将设置内存服务

309
00:12:29,630 --> 00:12:32,450
为代理提供上下文和状态

310
00:12:32,450 --> 00:12:33,290
在运行过程中

311
00:12:33,290 --> 00:12:37,040
我们可以基于该内存创建会话服务

312
00:12:37,040 --> 00:12:39,200
以及针对我们编写的特定代理

313
00:12:39,200 --> 00:12:41,120
同时假设我们有一个用户

314
00:12:41,120 --> 00:12:42,860
我们将假设只有一个用户

315
00:12:42,860 --> 00:12:46,220
一个在单一会话中运行的应用程序

316
00:12:46,220 --> 00:12:47,780
所有这些都将在这里使用

317
00:12:47,780 --> 00:12:53,340
在创建会话时用于生成可执行状态

318
00:12:53,340 --> 00:12:55,900
然后运行器将运行该状态

319
00:12:55,900 --> 00:12:57,810
基于它拥有的代理

320
00:12:57,810 --> 00:13:01,870
这里运行器结合了我们要运行的hello world代理

321
00:13:01,870 --> 00:13:05,360
应用名称将与我们传递给会话的名称相同

322
00:13:05,360 --> 00:13:10,139
同时会话服务将是该代理运行的会话

323
00:13:10,139 --> 00:13:11,279
在生产环境中

324
00:13:11,279 --> 00:13:12,819
可能会有多个会话

325
00:13:12,819 --> 00:13:15,339
可能会有多个使用该代理的应用程序

326
00:13:15,339 --> 00:13:18,219
这就是这些运行参数的不同之处

327
00:13:19,080 --> 00:13:19,480
好的

328
00:13:19,480 --> 00:13:20,900
现在有很多内容需要讲解

329
00:13:20,900 --> 00:13:23,240
仅为了实际运行代理

330
00:13:23,240 --> 00:13:25,700
让我们逐步进行，慢慢来

331
00:13:25,700 --> 00:13:27,400
我们知道已经有了这个运行器

332
00:13:27,400 --> 00:13:28,560
我们刚刚定义的

333
00:13:28,560 --> 00:13:32,320
我们将进行一次单循环处理单用户消息

334
00:13:32,320 --> 00:13:37,630
让运行器执行代理以响应用户消息

335
00:13:37,630 --> 00:13:39,270
我们将定义用户消息

336
00:13:39,270 --> 00:13:40,670
我简单说一声'你好'

337
00:13:40,670 --> 00:13:44,370
我可能是K，然后以友好方式打印该消息

338
00:13:44,370 --> 00:13:46,650
这样我们可以看到运行过程

339
00:13:46,650 --> 00:13:47,710
了解发生了什么

340
00:13:47,710 --> 00:13:49,690
这个纯文本消息

341
00:13:49,690 --> 00:13:52,790
需要打包成Google ADK运行时期望的数据结构

342
00:13:52,790 --> 00:13:54,710
运行时环境需要

343
00:13:54,710 --> 00:13:56,710
通常这是后台自动处理的

344
00:13:56,710 --> 00:13:57,030
当然

345
00:13:57,030 --> 00:13:58,250
但我们手动进行

346
00:13:58,250 --> 00:14:01,460
我们将在此创建内容类

347
00:14:01,460 --> 00:14:05,160
我们创建的内容角色来自用户

348
00:14:05,160 --> 00:14:06,640
这是一个用户消息

349
00:14:06,640 --> 00:14:08,730
内容可以包含多个部分

350
00:14:08,730 --> 00:14:10,490
我们将创建一个部分数组

351
00:14:10,490 --> 00:14:13,360
其中一个部分包含一些文本

352
00:14:13,360 --> 00:14:15,280
这里的文本是用户消息

353
00:14:15,280 --> 00:14:18,610
这些内容被打包起来以便执行更复杂的操作

354
00:14:18,610 --> 00:14:21,770
我们只是尝试运行单个用户的单条消息

355
00:14:21,770 --> 00:14:25,810
当有大量额外操作时，这能提供很大灵活性

356
00:14:25,810 --> 00:14:28,470
这基本上是在创建内容事件

357
00:14:28,470 --> 00:14:31,790
然后需要由代理运行时系统处理

358
00:14:31,790 --> 00:14:36,220
我们还将设置代理系统的响应

359
00:14:36,220 --> 00:14:38,440
以防它没有执行任何操作

360
00:14:38,440 --> 00:14:40,160
所以输入一条消息后

361
00:14:40,160 --> 00:14:41,520
我们将实际执行

362
00:14:41,520 --> 00:14:44,480
运行该消息并让代理有机会响应

363
00:14:44,480 --> 00:14:47,320
但代理可能不会响应

364
00:14:47,320 --> 00:14:49,960
存在最终响应的概念

365
00:14:49,960 --> 00:14:54,580
这是代理通过不同方式设置的标志以表明

366
00:14:54,580 --> 00:14:54,820
好的

367
00:14:54,820 --> 00:14:56,100
我已完成对此的思考

368
00:14:56,100 --> 00:14:57,500
或已完成处理

369
00:14:57,500 --> 00:15:01,540
如果代理无反应，可返回用户

370
00:15:01,540 --> 00:15:03,500
最终响应可能未设置

371
00:15:03,500 --> 00:15:08,480
因此我们预先设置默认值以表明无操作

372
00:15:08,480 --> 00:15:11,560
目前可以不显示详细输出

373
00:15:11,560 --> 00:15:12,780
稍后您可以看到

374
00:15:12,780 --> 00:15:14,849
详细输出可能是什么样子

375
00:15:14,849 --> 00:15:16,449
这就是事件循环本身

376
00:15:17,449 --> 00:15:19,149
应该说明事件的一个步骤

377
00:15:19,149 --> 00:15:22,970
比如针对这条用户消息

378
00:15:22,970 --> 00:15:28,110
我们将异步使用运行器并调用LLM

379
00:15:28,110 --> 00:15:32,230
使用传入的代理和指定模型

380
00:15:32,230 --> 00:15:34,560
以及所有提供的指令

381
00:15:34,560 --> 00:15:37,240
首先注意到当我们调用此异步方法时

382
00:15:37,240 --> 00:15:40,970
我们还传递了创建会话时的所有信息

383
00:15:40,970 --> 00:15:43,250
这是因为可以重复运行

384
00:15:43,250 --> 00:15:44,650
可能存在多个会话

385
00:15:44,650 --> 00:15:49,120
因此多个事件循环在异步运行时传递

386
00:15:49,120 --> 00:15:51,680
这是当前的操作上下文

387
00:15:51,680 --> 00:15:54,040
针对该用户和会话

388
00:15:54,040 --> 00:15:56,320
这是传入的内容

389
00:15:56,320 --> 00:15:58,920
使用LLM执行一次

390
00:15:58,920 --> 00:16:00,520
在此进行处理

391
00:16:00,520 --> 00:16:02,800
这在循环内部

392
00:16:02,800 --> 00:16:04,900
因为这是一个事件系统

393
00:16:04,900 --> 00:16:07,160
当代理收到此消息后

394
00:16:07,160 --> 00:16:11,000
可能在最终响应前执行多项操作

395
00:16:11,000 --> 00:16:16,790
事件循环在此提取代理的异步事件

396
00:16:16,790 --> 00:16:20,410
每个事件是代理的更新信息

397
00:16:20,410 --> 00:16:21,950
当事件到来时

398
00:16:21,950 --> 00:16:23,490
如果启用了详细模式

399
00:16:23,490 --> 00:16:24,270
我们将打印

400
00:16:24,270 --> 00:16:27,780
这里发生了一个事件，这是谁创建的事件

401
00:16:27,780 --> 00:16:28,940
初始事件

402
00:16:28,940 --> 00:16:31,340
当然应该传递用户消息

403
00:16:31,340 --> 00:16:32,320
我们应该看到该事件

404
00:16:32,320 --> 00:16:34,770
作者是用户自己

405
00:16:34,770 --> 00:16:37,319
你也会看到事件内容

406
00:16:37,319 --> 00:16:39,679
你可以查看调试语句中的情况

407
00:16:39,679 --> 00:16:41,219
大量信息被打印出来

408
00:16:41,219 --> 00:16:43,259
有助于理解当前状态

409
00:16:43,259 --> 00:16:46,830
这是保持事件循环运行的关键概念

410
00:16:46,830 --> 00:16:48,250
只要你想让它运行

411
00:16:48,250 --> 00:16:51,900
希望代理只会执行必要操作

412
00:16:51,900 --> 00:16:53,760
但每个事件到来时

413
00:16:53,760 --> 00:16:55,220
有一个标志表明

414
00:16:55,220 --> 00:16:55,700
好的

415
00:16:55,700 --> 00:16:56,920
这是最终事件

416
00:16:56,920 --> 00:16:58,220
我已完成处理

417
00:16:58,220 --> 00:17:00,020
代理已完成处理

418
00:17:00,020 --> 00:17:01,040
如果它设置了这个

419
00:17:01,040 --> 00:17:02,300
那么你就知道

420
00:17:02,300 --> 00:17:03,620
处理已完成

421
00:17:03,620 --> 00:17:05,099
可以查看内容

422
00:17:05,099 --> 00:17:09,720
决定最终响应可能是什么，我们查看内容

423
00:17:09,720 --> 00:17:12,159
如果存在多个部分

424
00:17:12,159 --> 00:17:15,439
如果返回的文本数组非空

425
00:17:15,439 --> 00:17:19,130
我们将取第一个消息部分

426
00:17:19,130 --> 00:17:20,550
提取该部分的文本

427
00:17:20,550 --> 00:17:22,410
这里我们做了一些假设

428
00:17:22,410 --> 00:17:28,138
第一部分的文本响应实际上是正确的，转换为最终响应文本

429
00:17:28,138 --> 00:17:32,299
或者代理可能决定这就是最终响应

430
00:17:32,299 --> 00:17:34,860
顺便说一句，我实际上没有响应

431
00:17:34,860 --> 00:17:38,680
我要求运行时系统执行的是升级

432
00:17:38,680 --> 00:17:39,220
现在

433
00:17:39,220 --> 00:17:40,260
升级最终结束

434
00:17:40,260 --> 00:17:42,130
意味着代理正在运行

435
00:17:42,130 --> 00:17:43,630
知道它是子代理

436
00:17:43,630 --> 00:17:44,670
无法处理

437
00:17:44,670 --> 00:17:47,340
或无法继续处理现有内容

438
00:17:47,340 --> 00:17:48,480
基本上在说

439
00:17:48,480 --> 00:17:49,920
将此升级给他人

440
00:17:49,920 --> 00:17:51,620
可能是上级或其他代理

441
00:17:51,620 --> 00:17:52,860
可能更合适

442
00:17:52,860 --> 00:17:54,330
在这种情况下

443
00:17:54,330 --> 00:17:57,530
最终响应文本将基于此

444
00:17:57,530 --> 00:17:58,010
我们将说

445
00:17:58,010 --> 00:18:01,670
亚洲团队决定升级当前消息处理

446
00:18:01,670 --> 00:18:03,470
我们没有具体消息

447
00:18:03,470 --> 00:18:04,990
或存在错误消息

448
00:18:04,990 --> 00:18:08,570
如果有则返回该消息作为最终结果

449
00:18:09,690 --> 00:18:13,680
所有操作是为了继续一轮事件循环

450
00:18:13,680 --> 00:18:15,640
由单个用户消息触发

451
00:18:15,640 --> 00:18:19,409
然后最后我们将打印出最终的代理响应

452
00:18:19,409 --> 00:18:20,669
这有点内容需要处理

453
00:18:20,669 --> 00:18:22,449
但请稍微记住这一点

454
00:18:22,449 --> 00:18:24,769
在浏览所有内部笔记本时

455
00:18:24,769 --> 00:18:29,340
这正是让所有运行的机器实际运作的关键

456
00:18:29,340 --> 00:18:30,420
所有这些工作

457
00:18:30,420 --> 00:18:31,760
我们进入简单聊天

458
00:18:31,760 --> 00:18:32,220
你好

459
00:18:32,220 --> 00:18:33,240
我是abk

460
00:18:33,240 --> 00:18:35,270
你好abk

461
00:18:35,470 --> 00:18:36,190
当然

462
00:18:36,190 --> 00:18:39,370
因为我们将会大量手动调用代理

463
00:18:39,370 --> 00:18:42,070
我们将设置一个辅助类来帮助我们

464
00:18:42,070 --> 00:18:44,170
更轻松地完成这些操作

465
00:18:44,370 --> 00:18:47,190
我将其命名为代理调用器

466
00:18:47,190 --> 00:18:51,250
这个代理调用器封装了我们之前讨论的那些函数

467
00:18:51,250 --> 00:18:53,520
这里逐一处理每个函数

468
00:18:53,520 --> 00:18:58,760
并将事件循环本身整合到一个类中

469
00:18:58,760 --> 00:19:01,179
如果你查看细节

470
00:19:01,179 --> 00:19:04,220
它完成了我们之前看到的所有操作

471
00:19:04,220 --> 00:19:07,200
保存单个用户ID

472
00:19:07,200 --> 00:19:08,740
单个会话ID

473
00:19:08,740 --> 00:19:10,200
当前要运行的代理

474
00:19:10,200 --> 00:19:12,420
以及已设置的运行器

475
00:19:12,420 --> 00:19:17,690
它可以访问用于内部管理的会话

476
00:19:17,690 --> 00:19:24,140
这里的调用函数会触发一次事件循环往返

477
00:19:24,140 --> 00:19:25,340
基于用户消息

478
00:19:25,340 --> 00:19:26,940
它执行我们之前看到的操作

479
00:19:26,940 --> 00:19:28,350
接收用户消息

480
00:19:28,350 --> 00:19:29,350
将其打包

481
00:19:29,350 --> 00:19:33,130
使其可被代理处理

482
00:19:33,130 --> 00:19:35,700
然后运行事件循环

483
00:19:35,700 --> 00:19:38,980
同样可用调试选项

484
00:19:39,719 --> 00:19:41,619
这纯粹是风格选择

485
00:19:41,619 --> 00:19:43,419
我不是原生Python开发者

486
00:19:43,419 --> 00:19:44,919
所以我喜欢这样操作

487
00:19:44,919 --> 00:19:49,130
偏好为复杂构造创建工厂方法

488
00:19:49,130 --> 00:19:49,610
所以

489
00:19:49,610 --> 00:19:52,389
而不是在类中使用复杂构造器

490
00:19:52,389 --> 00:19:55,949
我创建了一个单独的构造类

491
00:19:57,430 --> 00:20:01,150
这里的实用函数make_agent_caller

492
00:20:01,150 --> 00:20:03,850
将创建代理调用器实例

493
00:20:03,850 --> 00:20:06,850
你需要传入所有必要信息

494
00:20:06,850 --> 00:20:09,179
指定要运行的代理

495
00:20:09,179 --> 00:20:11,679
以及代理的初始状态

496
00:20:11,679 --> 00:20:14,670
其中状态是代理的内部记忆

497
00:20:14,670 --> 00:20:17,270
所有内容应与之前运行的一致

498
00:20:17,270 --> 00:20:20,410
但现在封装成不同组件

499
00:20:20,410 --> 00:20:23,720
应整合到代理调用器中的主要组件

500
00:20:23,720 --> 00:20:24,880
当前应用是什么

501
00:20:24,880 --> 00:20:26,590
会话ID的使用者

502
00:20:26,590 --> 00:20:29,170
为内存创建会话服务

503
00:20:29,170 --> 00:20:31,590
同时用于管理会话本身

504
00:20:31,590 --> 00:20:33,920
最后还要创建一个运行器

505
00:20:33,920 --> 00:20:36,260
在构建完所有组件后

506
00:20:36,260 --> 00:20:37,960
将它们传递给代理外壳

507
00:20:37,960 --> 00:20:41,690
该外壳将所有内容整合到执行循环中

508
00:20:42,130 --> 00:20:42,530
好的

509
00:20:42,530 --> 00:20:45,090
现在我们有了运行代理的实用函数

510
00:20:45,090 --> 00:20:48,340
可以运行一个问候对话

511
00:20:48,340 --> 00:20:48,900
嗯

512
00:20:48,900 --> 00:20:51,510
我们之前创建的代理

513
00:20:51,510 --> 00:20:54,190
要为我们的问候代理创建新代理调用器

514
00:20:54,190 --> 00:20:54,750
代理

515
00:20:54,750 --> 00:20:57,450
我们将调用辅助函数

516
00:20:57,450 --> 00:21:00,480
创建代理调用器并传入问候代理

517
00:21:00,480 --> 00:21:03,200
我们将其命名为问候代理调用器

518
00:21:03,200 --> 00:21:05,040
要运行对话

519
00:21:05,040 --> 00:21:06,889
我们将创建一个异步函数

520
00:21:06,889 --> 00:21:11,249
传入多个用户消息到代理调用器

521
00:21:11,249 --> 00:21:13,089
首先使用call方法

522
00:21:13,089 --> 00:21:13,729
我说你好

523
00:21:13,729 --> 00:21:14,690
我可能在

524
00:21:14,690 --> 00:21:16,470
然后我说我很兴奋

525
00:21:16,470 --> 00:21:20,900
我们运行这个对话并查看效果，太棒了

526
00:21:20,900 --> 00:21:23,340
我们创建了一个友好的聊天代理

527
00:21:23,340 --> 00:21:24,840
做得很好

528
00:21:24,840 --> 00:21:27,300
现在你已经学到这里

529
00:21:27,300 --> 00:21:29,900
已经掌握了使用Google ASDK的基础

530
00:21:29,900 --> 00:21:31,180
如何创建代理

531
00:21:31,180 --> 00:21:33,610
如何为代理添加可用工具

532
00:21:33,610 --> 00:21:36,830
同时如何为代理创建执行环境

533
00:21:36,830 --> 00:21:38,750
最终掌握这些内容后

534
00:21:38,750 --> 00:21:42,250
可以在笔记本中编写与代理的交互脚本

535
00:21:42,250 --> 00:21:47,230
传入用户消息以测试代理的工作方式

536
00:21:47,230 --> 00:21:50,600
我们创建的这个优秀的代理调用器类

537
00:21:50,600 --> 00:21:54,280
以及工厂方法make_agent_caller

538
00:21:54,280 --> 00:21:57,490
我们将在后续笔记本中使用它以简化操作

539
00:21:57,490 --> 00:21:58,730
找到代理后

540
00:21:58,730 --> 00:22:01,470
可以轻松使用该函数创建运行时环境

541
00:22:01,470 --> 00:22:04,090
你会频繁使用这个功能

