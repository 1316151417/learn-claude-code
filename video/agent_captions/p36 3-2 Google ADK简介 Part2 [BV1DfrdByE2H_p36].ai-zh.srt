1
00:00:00,360 --> 00:00:04,980
上节课你学习了如何使用Google Adk创建一个代理

2
00:00:04,980 --> 00:00:07,300
现在我们将创建多个代理

3
00:00:07,300 --> 00:00:09,260
一组协同工作的代理团队

4
00:00:09,260 --> 00:00:10,740
我们将有一个根代理

5
00:00:10,740 --> 00:00:13,860
然后构建两个子代理，基于之前的内容

6
00:00:13,860 --> 00:00:14,780
我们需要说

7
00:00:14,780 --> 00:00:15,000
你好

8
00:00:15,000 --> 00:00:15,560
代理

9
00:00:15,560 --> 00:00:18,290
我们将引入一个新代理来执行告别

10
00:00:18,290 --> 00:00:23,730
然后我们将创建另一个代理，将其整合为一个完整的多代理系统

11
00:00:23,730 --> 00:00:26,660
我们开始导入所需的库

12
00:00:26,660 --> 00:00:27,600
当然

13
00:00:27,600 --> 00:00:30,460
接下来设置我们将继续使用的语言模型

14
00:00:30,460 --> 00:00:31,440
这是OpenAI

15
00:00:31,440 --> 00:00:33,019
我们定义语言模型

16
00:00:33,019 --> 00:00:36,159
并通过传递消息进行快速验证

17
00:00:36,159 --> 00:00:37,980
确保系统已就绪

18
00:00:38,180 --> 00:00:42,220
总是有趣看看OpenAI当天会说什么

19
00:00:42,220 --> 00:00:43,640
通常会发送友好消息

20
00:00:43,640 --> 00:00:46,750
它会友好回应

21
00:00:46,750 --> 00:00:48,510
可以设置代理调用器

22
00:00:48,510 --> 00:00:51,310
我们将使用之前定义的同一类

23
00:00:51,310 --> 00:00:53,570
在第三课第一部分

24
00:00:53,570 --> 00:00:55,250
无需重复定义所有内容

25
00:00:55,250 --> 00:00:57,280
只需导入所需工具

26
00:00:57,280 --> 00:00:58,700
如果你还记得第一部分

27
00:00:58,700 --> 00:00:59,820
我们有一个辅助函数

28
00:00:59,820 --> 00:01:00,880
创建代理颜色

29
00:01:00,880 --> 00:01:04,759
将生成包含运行所需功能的代理颜色类

30
00:01:04,759 --> 00:01:06,219
所有准备就绪

31
00:01:06,219 --> 00:01:08,940
现在开始构建多代理系统

32
00:01:08,940 --> 00:01:11,420
创建多个专业代理

33
00:01:11,420 --> 00:01:14,250
每个负责特定功能

34
00:01:14,250 --> 00:01:16,790
创建一个负责问候的代理

35
00:01:16,790 --> 00:01:17,730
即说你好

36
00:01:17,730 --> 00:01:22,720
之前的代理负责问候，新代理将处理告别

37
00:01:22,960 --> 00:01:25,900
通过根代理将两者结合

38
00:01:25,900 --> 00:01:28,780
你会听到协调者或调度者等术语

39
00:01:28,780 --> 00:01:30,140
顶层代理

40
00:01:30,140 --> 00:01:33,820
本质上是封装其他代理的代理

41
00:01:33,820 --> 00:01:36,270
并管理其执行

42
00:01:36,270 --> 00:01:39,170
根代理将接收初始用户请求

43
00:01:39,170 --> 00:01:42,030
无论是问候还是用户指定的内容

44
00:01:42,030 --> 00:01:46,470
然后决定如何处理，自行执行或委托

45
00:01:46,470 --> 00:01:48,730
转交给子代理处理

46
00:01:48,730 --> 00:01:49,830
因此根代理

47
00:01:49,830 --> 00:01:54,210
这个顶层协调者将委托问候和告别任务

48
00:01:54,210 --> 00:01:57,830
希望由专门处理这些任务的子代理执行

49
00:01:57,830 --> 00:01:58,430
好的

50
00:01:58,430 --> 00:02:01,100
现在开始组装我们的多代理系统

51
00:02:01,100 --> 00:02:03,580
我们将使用之前提到的打招呼代理

52
00:02:03,580 --> 00:02:05,200
我们现在要添加一个道别代理

53
00:02:05,200 --> 00:02:07,380
然后我们将它们结合起来

54
00:02:07,460 --> 00:02:09,740
首先定义子代理的工具

55
00:02:10,820 --> 00:02:14,560
第一个工具是来自前一课的相同打招呼工具

56
00:02:14,560 --> 00:02:16,260
这是hello world函数

57
00:02:16,260 --> 00:02:20,960
接收人名并生成问候消息作为响应

58
00:02:21,980 --> 00:02:25,160
接下来我们将加入道别函数

59
00:02:25,160 --> 00:02:28,200
这个工具比打招呼更简单

60
00:02:28,200 --> 00:02:29,780
因为它不接受任何参数

61
00:02:29,780 --> 00:02:34,189
无论什么情况都会返回固定的回复

62
00:02:34,189 --> 00:02:35,569
无论你想做什么

63
00:02:35,569 --> 00:02:37,629
你将得到这样的响应

64
00:02:37,629 --> 00:02:41,030
用这两个工具向用户道别

65
00:02:41,030 --> 00:02:43,970
现在可以定义使用这些工具的代理

66
00:02:43,970 --> 00:02:47,430
现在我们将创建专门的问候代理和道别代理

67
00:02:47,430 --> 00:02:50,770
但你会发现非常简单

68
00:02:51,940 --> 00:02:53,760
在定义这些子代理时

69
00:02:53,760 --> 00:02:55,820
我特别强调最佳实践

70
00:02:55,820 --> 00:03:00,260
每个代理的详细描述非常重要

71
00:03:00,260 --> 00:03:02,360
以及传递给它们的指令

72
00:03:02,360 --> 00:03:03,860
一旦建立多代理系统

73
00:03:03,860 --> 00:03:06,090
大部分时间将用于

74
00:03:06,090 --> 00:03:07,670
在设置任何多代理系统后

75
00:03:07,670 --> 00:03:09,610
大部分时间将用于

76
00:03:09,610 --> 00:03:11,710
优化这些指令

77
00:03:11,710 --> 00:03:15,800
这回到经典提示工程

78
00:03:15,800 --> 00:03:18,740
同时重复前一课的内容

79
00:03:18,740 --> 00:03:20,269
描述让其他代理知道

80
00:03:20,269 --> 00:03:23,790
这个代理的功能

81
00:03:23,790 --> 00:03:26,510
以及何时调用该代理进行委派

82
00:03:26,510 --> 00:03:27,630
指令是让代理自身理解

83
00:03:27,630 --> 00:03:28,870
其目的

84
00:03:28,870 --> 00:03:30,650
要实现的目标

85
00:03:30,650 --> 00:03:32,170
可用的工具

86
00:03:32,170 --> 00:03:33,870
以及何时使用它们

87
00:03:33,870 --> 00:03:38,130
这是问候子代理

88
00:03:38,610 --> 00:03:40,910
它只能访问打招呼工具

89
00:03:40,910 --> 00:03:43,430
然后我们将添加道别代理

90
00:03:43,430 --> 00:03:45,430
与问候代理类似

91
00:03:45,430 --> 00:03:48,450
可以查看这里的指令描述

92
00:03:48,450 --> 00:03:52,660
这些指令值得仔细研究

93
00:03:52,660 --> 00:03:53,960
看起来很明显

94
00:03:53,960 --> 00:03:54,460
好的

95
00:03:54,460 --> 00:03:57,370
你的任务是作为道别代理回应

96
00:03:57,370 --> 00:04:00,030
当用户以某种方式说再见时

97
00:04:00,030 --> 00:04:02,380
人们用各种方式道别

98
00:04:02,380 --> 00:04:07,440
这是一个在代理指令中进行少量学习的小例子

99
00:04:07,440 --> 00:04:09,220
这里括号内有示例

100
00:04:09,220 --> 00:04:12,400
例如当用户使用像'再见'这样的词

101
00:04:12,400 --> 00:04:13,080
再见

102
00:04:13,080 --> 00:04:14,290
谢谢再见

103
00:04:14,290 --> 00:04:15,510
或者下次见

104
00:04:15,510 --> 00:04:17,690
这些都是告别的方式

105
00:04:17,690 --> 00:04:21,450
现在大多数LLM不需要额外的例子

106
00:04:21,450 --> 00:04:24,299
但总体来说这是一个好习惯，需要思考

107
00:04:24,299 --> 00:04:28,019
我该如何帮助LLM理解这个代理的目的

108
00:04:28,019 --> 00:04:31,659
以及何时执行和在角色中该做什么

109
00:04:31,659 --> 00:04:33,459
当然我们要交给它说再见

110
00:04:33,459 --> 00:04:35,939
我们之前定义的工具很棒

111
00:04:35,939 --> 00:04:36,379
你知道的

112
00:04:36,379 --> 00:04:38,530
我有两个子模块准备就绪

113
00:04:38,530 --> 00:04:39,970
现在我们需要将它们合并

114
00:04:39,970 --> 00:04:42,490
我们将通过定义根代理来实现

115
00:04:42,490 --> 00:04:44,970
它将理解这两个子代理

116
00:04:44,970 --> 00:04:47,110
并判断何时委派任务

117
00:04:47,110 --> 00:04:49,000
类似于调用工具

118
00:04:49,000 --> 00:04:51,640
但代理知道在与另一个代理对话

119
00:04:51,640 --> 00:04:54,220
因此整个对话历史会被传递

120
00:04:54,220 --> 00:04:58,079
并且对话控制权会转交给子代理

121
00:04:58,079 --> 00:04:59,999
这与调用略有不同

122
00:04:59,999 --> 00:05:01,570
但核心思想相同

123
00:05:01,570 --> 00:05:05,450
当前工作流将从负责的代理开始

124
00:05:05,450 --> 00:05:07,900
根代理到子代理之一

125
00:05:07,900 --> 00:05:09,620
这类似于调用工具

126
00:05:09,620 --> 00:05:13,159
但让我们仔细看看代理委派如何运作

127
00:05:13,159 --> 00:05:16,919
我们知道代理自身已描述了角色

128
00:05:16,919 --> 00:05:17,599
它们会说

129
00:05:17,599 --> 00:05:17,899
你好

130
00:05:17,899 --> 00:05:19,519
亚洲代理与告别代理

131
00:05:19,519 --> 00:05:22,379
两者都清楚自身职责

132
00:05:22,379 --> 00:05:25,399
它们的描述告知其他代理职责

133
00:05:25,399 --> 00:05:26,520
他们的工作是

134
00:05:26,520 --> 00:05:28,120
我们将进一步强调这一点

135
00:05:28,120 --> 00:05:30,340
在给根代理的指令中

136
00:05:30,340 --> 00:05:35,090
根代理需被告知其职责是协调子代理团队

137
00:05:35,090 --> 00:05:37,070
你可以在指令中看到这一点

138
00:05:37,070 --> 00:05:39,990
其主要目标是保持友好

139
00:05:39,990 --> 00:05:41,250
为了保持友好

140
00:05:41,250 --> 00:05:43,530
它拥有两个专用子代理

141
00:05:43,530 --> 00:05:44,750
因此需描述这些子代理

142
00:05:44,750 --> 00:05:48,729
以便代理知道何时使用子代理

143
00:05:48,729 --> 00:05:50,049
这类似于描述

144
00:05:50,049 --> 00:05:51,770
何时使用特定工具

145
00:05:51,770 --> 00:05:56,090
问候代理用于处理简单问候如你好或嗨

146
00:05:56,090 --> 00:05:59,050
当然告别代理用于说再见

147
00:05:59,050 --> 00:06:02,479
无论是'再见'或其他表达

148
00:06:02,479 --> 00:06:04,559
这里明确说明

149
00:06:04,559 --> 00:06:06,719
当收到用户消息时

150
00:06:06,719 --> 00:06:10,139
请委派子代理实际回应用户

151
00:06:10,139 --> 00:06:12,960
与其直接作为协调者回应

152
00:06:12,960 --> 00:06:14,120
所以如果这个方案有效

153
00:06:14,120 --> 00:06:17,610
协调者只需回答一般性问题

154
00:06:17,610 --> 00:06:19,350
当你说问候或告别时

155
00:06:19,350 --> 00:06:22,770
应转交给子代理执行响应

156
00:06:22,770 --> 00:06:25,030
或生成对用户的回复

157
00:06:25,650 --> 00:06:28,950
顶层协调者没有任何工具可用

158
00:06:28,950 --> 00:06:31,920
只能进行对话或转交子代理

159
00:06:31,920 --> 00:06:34,200
我们也将在此分发子代理列表

160
00:06:34,200 --> 00:06:35,620
在子代理的键中

161
00:06:35,620 --> 00:06:39,850
因此子代理包括问候子代理和告别子代理

162
00:06:39,970 --> 00:06:43,290
现在我们将所有代理整合成一个多代理系统

163
00:06:43,290 --> 00:06:45,460
让我们开始与之互动

164
00:06:45,460 --> 00:06:48,680
这与第三课第一部分类似

165
00:06:48,680 --> 00:06:52,500
我们有一个管理对话的异步函数

166
00:06:52,500 --> 00:06:55,040
因此对话可以和之前一样

167
00:06:55,040 --> 00:06:55,520
你好

168
00:06:55,520 --> 00:06:56,300
我 abbk

169
00:06:56,300 --> 00:06:57,240
然后稍后

170
00:06:57,240 --> 00:06:57,980
而不是说

171
00:06:57,980 --> 00:06:58,970
我很兴奋

172
00:06:58,970 --> 00:07:01,030
这段转录将显示

173
00:07:01,030 --> 00:07:01,810
谢谢再见

174
00:07:01,810 --> 00:07:04,420
这将是第二个用户消息

175
00:07:04,540 --> 00:07:07,140
我们还添加了这个true

176
00:07:07,140 --> 00:07:10,360
所以当你调用这个代理调用者时

177
00:07:10,360 --> 00:07:14,810
传入的第二个参数是是否开启详细响应

178
00:07:14,810 --> 00:07:16,450
我们将启用详细模式

179
00:07:16,450 --> 00:07:18,790
这样可以看到后台运行情况

180
00:07:18,790 --> 00:07:21,900
可以理解用户输入信息

181
00:07:21,900 --> 00:07:23,020
观察转交过程

182
00:07:23,020 --> 00:07:24,360
查看工具调用

183
00:07:24,360 --> 00:07:25,840
并看到响应结果

184
00:07:25,840 --> 00:07:27,000
内容较多需要梳理

185
00:07:27,000 --> 00:07:30,480
但至少走一遍有助于熟悉

186
00:07:30,480 --> 00:07:31,800
在调试代理时

187
00:07:31,800 --> 00:07:33,840
交互过程

188
00:07:34,920 --> 00:07:35,840
好的

189
00:07:35,840 --> 00:07:37,600
这开始看起来很正常

190
00:07:37,600 --> 00:07:39,020
接收用户消息

191
00:07:39,020 --> 00:07:39,480
你好

192
00:07:39,480 --> 00:07:44,880
我可能k，可以看到初始事件来自友好代理团队

193
00:07:44,880 --> 00:07:46,820
这就是顶层协调者

194
00:07:46,820 --> 00:07:49,830
将调用子代理的团队协调者

195
00:07:49,830 --> 00:07:54,350
可以看到它的第一个动作是转接到代理

196
00:07:54,350 --> 00:07:57,150
即转交或委托给子代理

197
00:07:57,150 --> 00:07:59,810
并将转接到问候子代理

198
00:07:59,810 --> 00:08:01,910
完美对应问候回应

199
00:08:01,910 --> 00:08:04,720
我可能k 顶层协调者意识到

200
00:08:04,720 --> 00:08:07,260
我有一个擅长问候的代理

201
00:08:07,260 --> 00:08:10,120
让我将控制权转交给那个代理

202
00:08:10,120 --> 00:08:12,700
所以响应的转移没有任何

203
00:08:12,700 --> 00:08:13,200
你知道的价值

204
00:08:13,200 --> 00:08:13,720
 whatsoever

205
00:08:13,720 --> 00:08:14,710
它只是一个修女

206
00:08:14,710 --> 00:08:17,770
但接下来我们需要看到问候子代理接管控制

207
00:08:17,770 --> 00:08:19,570
所以这里又有一个事件

208
00:08:19,570 --> 00:08:21,800
但现在由问候子代理处理

209
00:08:21,800 --> 00:08:25,720
它将查看对话记录并分析用户消息

210
00:08:25,720 --> 00:08:26,960
并意识到

211
00:08:26,960 --> 00:08:29,280
现在我需要实际处理这个问题

212
00:08:29,280 --> 00:08:32,440
问候子代理将通过调用工具进行响应

213
00:08:33,440 --> 00:08:37,140
你可以看到此处的函数调用及目标函数名称

214
00:08:37,140 --> 00:08:37,480
Called

215
00:08:37,480 --> 00:08:38,280
Say hello

216
00:08:38,280 --> 00:08:40,100
并将传递一些参数

217
00:08:40,100 --> 00:08:44,179
其中传入的参数是人员名称为abk

218
00:08:44,460 --> 00:08:47,820
代理已从当前语句中识别出

219
00:08:47,820 --> 00:08:48,280
当然

220
00:08:48,280 --> 00:08:48,620
你好

221
00:08:48,620 --> 00:08:49,560
我是abk

222
00:08:49,560 --> 00:08:52,800
它成功提取了abk应为人员姓名

223
00:08:52,800 --> 00:08:57,150
并将调用工具函数传入该名称

224
00:08:57,550 --> 00:08:59,610
然后接收响应

225
00:08:59,610 --> 00:09:05,750
这里是函数响应，回复是向abk问好完美

226
00:09:06,030 --> 00:09:07,930
现在问候子代理已完成

227
00:09:07,930 --> 00:09:11,210
继续执行，最终消息为true

228
00:09:11,210 --> 00:09:13,910
这是表示已完成处理的标志

229
00:09:13,910 --> 00:09:17,250
我们可以终止此事件循环

230
00:09:17,250 --> 00:09:21,970
最终代理响应即为工具返回的结果

231
00:09:21,970 --> 00:09:24,349
向你问好abk

232
00:09:24,389 --> 00:09:26,549
我们发送第二个查询

233
00:09:26,549 --> 00:09:31,690
或用户的留言，用户说谢谢再见

234
00:09:31,690 --> 00:09:33,410
顶层代理将继续处理

235
00:09:33,410 --> 00:09:34,010
哦其实不是

236
00:09:34,010 --> 00:09:36,650
仍由问候子代理控制

237
00:09:36,650 --> 00:09:39,090
问候子代理自身会意识到

238
00:09:39,090 --> 00:09:39,370
好的

239
00:09:39,370 --> 00:09:40,980
这不是我该处理的内容

240
00:09:40,980 --> 00:09:43,620
请转交给告别子代理

241
00:09:43,620 --> 00:09:45,800
它已知晓可用的其他代理

242
00:09:45,800 --> 00:09:48,620
转交给告别子代理

243
00:09:48,900 --> 00:09:53,680
此处函数响应结束

244
00:09:53,680 --> 00:09:56,960
然后是告别子代理的留言

245
00:09:56,960 --> 00:09:58,840
再次查看对话记录

246
00:09:58,840 --> 00:10:01,710
在接管当前对话后

247
00:10:01,710 --> 00:10:03,470
首先会意识到

248
00:10:03,470 --> 00:10:03,670
好的

249
00:10:03,670 --> 00:10:05,510
用户说了再见

250
00:10:05,510 --> 00:10:09,560
我将调用说再见工具来生成响应

251
00:10:09,560 --> 00:10:12,180
这就是用于道别的函数调用

252
00:10:12,180 --> 00:10:16,320
当然它像预期的那样不接受任何参数

253
00:10:16,519 --> 00:10:20,719
但它的响应是我们之前在工具定义中看到的常量

254
00:10:20,719 --> 00:10:22,259
它将获取告别信息

255
00:10:22,259 --> 00:10:24,380
这是来自cipher的再见

256
00:10:24,620 --> 00:10:28,410
这再次是此事件循环的最终响应

257
00:10:28,410 --> 00:10:30,930
因此这将是最终的代理响应

258
00:10:30,930 --> 00:10:32,450
来自cypher的再见

259
00:10:32,450 --> 00:10:32,930
好的

260
00:10:32,930 --> 00:10:34,490
刚才讲解的内容很多

261
00:10:34,490 --> 00:10:38,069
花时间理解这些内容对后续工作很有帮助

262
00:10:38,069 --> 00:10:41,309
你可以看到所有工具调用的交互过程

263
00:10:41,309 --> 00:10:42,469
代理委托机制

264
00:10:42,469 --> 00:10:45,950
以及整体状态的变化和响应

265
00:10:45,950 --> 00:10:47,430
非常值得这样做

266
00:10:47,430 --> 00:10:49,110
我们不会在每个笔记本中都这样做

267
00:10:49,110 --> 00:10:50,810
但如果你有时间

268
00:10:50,810 --> 00:10:54,160
请务必花时间深入理解背后的原理

269
00:10:54,160 --> 00:10:56,880
因为幕后发生的事情会影响

270
00:10:56,880 --> 00:11:00,060
当然整体架构的定义方式

271
00:11:00,060 --> 00:11:02,609
以及代理编排流程

272
00:11:02,809 --> 00:11:05,709
你将在多代理系统中再进一步

273
00:11:05,709 --> 00:11:08,740
我们有一个代理的执行环境

274
00:11:08,740 --> 00:11:11,580
我们拥有多代理团队协同工作

275
00:11:11,580 --> 00:11:13,720
它们可以互相委托任务

276
00:11:13,720 --> 00:11:15,680
每个代理还拥有工具

277
00:11:15,680 --> 00:11:21,170
所有代理系统最重要的组件是记忆功能

278
00:11:21,170 --> 00:11:22,970
记忆就是内部状态

279
00:11:22,970 --> 00:11:27,830
在特定会话中涉及的任何代理之间持续存在

280
00:11:27,830 --> 00:11:30,099
当然还有用户自己

281
00:11:30,099 --> 00:11:31,279
什么是会话状态

282
00:11:31,279 --> 00:11:36,519
在Google Adk中默认的会话状态其实就是一个可用字典

283
00:11:36,519 --> 00:11:39,250
你可以更新该字典中的键值

284
00:11:39,250 --> 00:11:42,070
当你更新这些键的值时

285
00:11:42,070 --> 00:11:44,250
Google hk会追踪这些变化

286
00:11:44,250 --> 00:11:46,760
基本追踪状态的增量变化

287
00:11:46,760 --> 00:11:51,130
并更新整体会话状态以保持一致性

288
00:11:51,130 --> 00:11:54,010
无论代理是并行还是顺序运行

289
00:11:54,010 --> 00:11:56,450
因为系统本质上是异步的

290
00:11:56,450 --> 00:11:59,240
它管理所有状态更新

291
00:11:59,520 --> 00:12:02,349
代理有几种不同的状态交互方式

292
00:12:02,349 --> 00:12:04,349
其中一种我更推荐的方式

293
00:12:04,349 --> 00:12:08,189
与状态交互的主要方法是通过工具上下文

294
00:12:08,189 --> 00:12:10,110
每当调用工具时

295
00:12:10,110 --> 00:12:12,250
会有一个额外的参数可用

296
00:12:12,250 --> 00:12:15,910
即该工具被调用时的上下文

297
00:12:15,910 --> 00:12:17,490
基于此工具上下文

298
00:12:17,490 --> 00:12:22,089
工具本身可以访问当前状态或代理的记忆

299
00:12:22,089 --> 00:12:25,809
并利用这些记忆做出不同决策

300
00:12:25,809 --> 00:12:26,929
生成不同输出

301
00:12:26,929 --> 00:12:29,010
无论对内存是否合适

302
00:12:29,010 --> 00:12:33,620
代理还可以通过使用输出键与状态交互

303
00:12:33,620 --> 00:12:36,700
因此无需使用工具调用来更新某些内存

304
00:12:36,700 --> 00:12:38,250
以及访问内存时

305
00:12:38,250 --> 00:12:42,200
你可以获取代理最终响应的实际输出

306
00:12:42,200 --> 00:12:45,300
而不是仅将此结果作为代理的响应返回

307
00:12:45,300 --> 00:12:48,740
你可以通过定义输出键保存中间状态

308
00:12:48,740 --> 00:12:51,250
当你看到这个最终结果时

309
00:12:51,610 --> 00:12:53,270
与最终结果相关的信息

310
00:12:53,270 --> 00:12:54,430
此处应为文本内容

311
00:12:54,430 --> 00:12:58,900
再见信息可用于更新自身状态

312
00:12:58,900 --> 00:13:00,240
这有时非常方便

313
00:13:00,240 --> 00:13:03,810
稍后在这些笔记本中我们会稍作演示

314
00:13:04,050 --> 00:13:04,450
好的

315
00:13:04,450 --> 00:13:06,550
在下一步中我们将设置一些内存

316
00:13:06,550 --> 00:13:10,569
我们始终使用当前的内存会话

317
00:13:10,569 --> 00:13:13,769
因此内存仅保存在RAM中

318
00:13:13,769 --> 00:13:15,690
并未持久化到数据库

319
00:13:15,690 --> 00:13:18,050
当然这是生产系统的最佳做法

320
00:13:18,050 --> 00:13:19,190
但出于便利性

321
00:13:19,190 --> 00:13:22,430
使用内存状态完全没问题

322
00:13:22,430 --> 00:13:27,599
我们将更新两个工具以利用内存状态

323
00:13:27,599 --> 00:13:29,959
无论是打招呼还是道别

324
00:13:29,959 --> 00:13:33,119
我们将更新这些工具以利用工具上下文

325
00:13:33,119 --> 00:13:36,639
用于更新会话状态或内存

326
00:13:36,780 --> 00:13:40,890
应逐一进行并仔细对比差异

327
00:13:40,890 --> 00:13:44,410
你会发现我们导入了google adk的工具上下文

328
00:13:44,410 --> 00:13:48,650
工具上下文是管理会话状态的类

329
00:13:48,650 --> 00:13:52,960
除了其他对工具有用的功能

330
00:13:52,960 --> 00:13:57,000
我们将更新打招呼函数为状态化版本

331
00:13:57,000 --> 00:13:57,980
状态化

332
00:13:57,980 --> 00:14:00,660
仍接受用户姓名参数

333
00:14:00,660 --> 00:14:04,300
但新增了工具上下文参数

334
00:14:04,380 --> 00:14:08,240
工具上下文将让我们访问会话状态

335
00:14:08,240 --> 00:14:12,060
由执行环境传递的会话参数

336
00:14:12,480 --> 00:14:15,530
在工具上下文中有一个状态字典

337
00:14:15,530 --> 00:14:18,310
我们将更新用户名键

338
00:14:18,310 --> 00:14:20,790
使用函数传入的名称

339
00:14:20,790 --> 00:14:23,170
用于更新会话内存

340
00:14:23,170 --> 00:14:26,110
或会话状态中的用户名键

341
00:14:26,110 --> 00:14:29,230
这非常直接，用户名用户名

342
00:14:29,230 --> 00:14:32,590
现在有一个所有代理共享的字典

343
00:14:32,590 --> 00:14:37,130
所有工具均可访问此函数传入的值

344
00:14:37,130 --> 00:14:42,250
这是一种通过函数自然使用来跟踪信息的方式

345
00:14:42,250 --> 00:14:47,000
同时为后续调试保留这些信息

346
00:14:47,000 --> 00:14:48,200
当调用此工具时

347
00:14:48,200 --> 00:14:51,420
我们将打印会话状态的更新

348
00:14:51,420 --> 00:14:53,380
特别是用户名键

349
00:14:53,380 --> 00:14:55,660
当然我们仍将执行之前的操作

350
00:14:55,660 --> 00:14:56,400
说 hello

351
00:14:56,400 --> 00:15:00,480
我们将向near发送一个查询请求，使用查询参数j

352
00:15:00,480 --> 00:15:01,940
这就是用户名

353
00:15:01,940 --> 00:15:05,990
现在你已经定义了，我们继续定义这个

354
00:15:05,990 --> 00:15:09,570
你可以为say goodbye定义相同的内容，再次操作

355
00:15:09,570 --> 00:15:10,550
在定义这个过程中

356
00:15:10,550 --> 00:15:12,210
这只是对say goodbye的更新

357
00:15:12,210 --> 00:15:13,579
我们之前定义的那个

358
00:15:13,579 --> 00:15:15,499
现在不同的是这个say goodbye

359
00:15:15,499 --> 00:15:19,540
尽管它不接受任何与用户相关的参数

360
00:15:19,540 --> 00:15:21,580
这里没有自定义参数

361
00:15:21,580 --> 00:15:24,329
但它会接收工具上下文

362
00:15:24,329 --> 00:15:27,749
我需要说明这是Google ADK自动处理的

363
00:15:27,749 --> 00:15:32,480
当检测到工具的最后一个参数是工具上下文时

364
00:15:32,480 --> 00:15:35,349
会自动注入该上下文到工具调用中

365
00:15:35,349 --> 00:15:36,569
当执行say goodbye

366
00:15:36,569 --> 00:15:38,029
Stateful被调用时

367
00:15:38,029 --> 00:15:40,449
将获取工具上下文但无其他内容

368
00:15:40,449 --> 00:15:42,529
但因为say hello

369
00:15:42,529 --> 00:15:44,915
Stateful设置了状态

370
00:15:45,590 --> 00:15:48,110
将用户名存入状态

371
00:15:48,590 --> 00:15:49,410
say goodbye

372
00:15:49,410 --> 00:15:50,950
可以实际访问用户名

373
00:15:50,950 --> 00:15:53,550
现在我们记住了用户的姓名

374
00:15:53,550 --> 00:15:56,950
可以访问状态键为username的值

375
00:15:56,950 --> 00:16:01,460
并设置默认值以防用户未自我标识

376
00:16:01,460 --> 00:16:03,300
但可以从字典中获取

377
00:16:03,300 --> 00:16:04,680
用户名或默认值

378
00:16:04,680 --> 00:16:06,380
赋值给用户名变量

379
00:16:06,380 --> 00:16:10,540
然后用于生成告别语句

380
00:16:12,340 --> 00:16:15,620
你可以定义新的stateful代理处理告别

381
00:16:15,620 --> 00:16:19,100
这与之前的联邦代理相同

382
00:16:19,100 --> 00:16:22,900
但现在会调用say goodbye stateful工具

383
00:16:23,180 --> 00:16:24,400
如同之前

384
00:16:24,400 --> 00:16:29,480
可通过根代理或协调者将它们组合成多代理系统

385
00:16:29,480 --> 00:16:33,120
由根代理或协调者使用这两个子代理

386
00:16:33,120 --> 00:16:37,280
这与之前的根代理完全相同

387
00:16:37,280 --> 00:16:42,119
现在仅使用核心基于状态的子代理

388
00:16:42,119 --> 00:16:44,770
这些具有状态管理的工具

389
00:16:45,410 --> 00:16:49,330
现在拥有利用记忆的多代理系统

390
00:16:49,330 --> 00:16:51,300
你可以尝试一下

391
00:16:51,540 --> 00:16:56,440
使用朋友创建代理调用者，传入新root代理stateful

392
00:16:56,440 --> 00:16:57,980
这是协调者的顶层

393
00:16:57,980 --> 00:17:02,100
为该代理创建调用者以观察会话变化

394
00:17:02,100 --> 00:17:04,960
我们直接从调用者获取会话

395
00:17:04,960 --> 00:17:07,060
记得有获取会话的实用函数

396
00:17:07,060 --> 00:17:09,638
查看亚洲调用者类

397
00:17:09,919 --> 00:17:11,199
我们获取会话

398
00:17:11,199 --> 00:17:12,398
基于该会话

399
00:17:12,398 --> 00:17:15,299
打印创建时的初始状态

400
00:17:15,299 --> 00:17:18,190
应看到当前状态为空

401
00:17:18,390 --> 00:17:19,170
正如预期的那样

402
00:17:19,170 --> 00:17:21,030
初始状态为空

403
00:17:22,460 --> 00:17:24,220
你现在可以定义一个对话

404
00:17:24,220 --> 00:17:27,119
这是我们一直在进行的对话，比如说你好

405
00:17:27,119 --> 00:17:28,180
说再见

406
00:17:28,180 --> 00:17:30,110
让我们看看会发生什么

407
00:17:30,230 --> 00:17:33,890
实际上我现在要移除这些冗长的语句

408
00:17:33,890 --> 00:17:35,750
你可以选择保留这些或添加它们

409
00:17:35,750 --> 00:17:37,760
如果你想的话可以任选其一运行

410
00:17:37,760 --> 00:17:39,680
但为了减少输出内容

411
00:17:39,680 --> 00:17:42,970
我们先不带调试语句运行这段代码

412
00:17:42,970 --> 00:17:46,870
这里真正重要的是我们看到初始状态为空

413
00:17:46,870 --> 00:17:49,870
并且在这些调用完成后

414
00:17:49,870 --> 00:17:52,540
初始状态应变为最终状态

415
00:17:52,540 --> 00:17:54,440
现在我们再次获取它

416
00:17:54,440 --> 00:18:00,360
最终状态应包含由调用定义的用户姓名

417
00:18:00,360 --> 00:18:01,860
说你好

418
00:18:04,760 --> 00:18:05,500
太棒了

419
00:18:05,500 --> 00:18:10,810
我们的工具函数在这里打印了用户名更新

420
00:18:10,810 --> 00:18:13,010
当我们获取会话时

421
00:18:13,010 --> 00:18:20,140
然后从会话中获取状态，最终状态包含用户名abk

422
00:18:20,140 --> 00:18:21,000
太好了

423
00:18:21,000 --> 00:18:23,340
一切按预期运行

424
00:18:24,840 --> 00:18:25,120
现在

425
00:18:25,120 --> 00:18:25,800
如果你想的话

426
00:18:25,800 --> 00:18:28,000
你可以在交互环境中运行这段代码

427
00:18:28,000 --> 00:18:29,680
甚至在这个笔记本中

428
00:18:29,680 --> 00:18:32,020
可以设置一个小的辅助函数

429
00:18:32,020 --> 00:18:35,280
用于循环获取用户输入的消息

430
00:18:35,280 --> 00:18:38,780
然后调用我们的caller函数传入该消息

431
00:18:38,780 --> 00:18:44,040
只要用户不输入退出消息就会持续运行

432
00:18:44,040 --> 00:18:45,820
当你设置好并运行它时

433
00:18:45,820 --> 00:18:47,850
会弹出一个小窗口

434
00:18:47,850 --> 00:18:49,850
当你运行交互会话时

435
00:18:49,850 --> 00:18:52,650
可以输入消息并观察结果

436
00:18:55,040 --> 00:18:56,960
我先不透露我的名字

437
00:18:56,960 --> 00:18:58,320
看看会发生什么

438
00:18:59,769 --> 00:19:00,169
好的

439
00:19:00,169 --> 00:19:01,129
这有点有趣

440
00:19:01,129 --> 00:19:03,909
语言模型推断出我的名字在这里

441
00:19:03,909 --> 00:19:05,209
基于这条消息

442
00:19:05,209 --> 00:19:06,649
这并不理想

443
00:19:06,649 --> 00:19:07,689
让我们纠正它

444
00:19:07,689 --> 00:19:08,534
让我们说

445
00:19:12,180 --> 00:19:14,620
只需传入我的名字是abb

446
00:19:14,620 --> 00:19:18,800
K 工具上下文已更新为abk

447
00:19:18,800 --> 00:19:20,540
有一个名为say hello的工具

448
00:19:20,540 --> 00:19:21,690
针对abk

449
00:19:21,690 --> 00:19:24,810
因此语言模型正确识别

450
00:19:24,810 --> 00:19:25,850
我的名字是abk

451
00:19:25,850 --> 00:19:27,150
将此保存到内存中

452
00:19:27,150 --> 00:19:28,170
这太棒了

453
00:19:28,170 --> 00:19:30,020
如果我说再见

454
00:19:30,340 --> 00:19:32,500
现在我们应该通过abk收到一条好消息

455
00:19:32,500 --> 00:19:33,530
和之前一样

456
00:19:33,530 --> 00:19:34,430
试试这个

457
00:19:34,430 --> 00:19:36,330
与它互动并看看你能想到什么

458
00:19:36,330 --> 00:19:36,570
而且

459
00:19:36,570 --> 00:19:36,930
当然

460
00:19:36,930 --> 00:19:41,270
如果你想修改代码结尾并观察其影响

461
00:19:41,590 --> 00:19:41,990
好的

462
00:19:41,990 --> 00:19:45,070
你已经完成了第三课的所有内容

463
00:19:45,070 --> 00:19:49,770
你创建了一个基本的单体代理，它会说你好

464
00:19:49,770 --> 00:19:52,150
然后你创建了一个多代理系统

465
00:19:52,150 --> 00:19:55,570
包含两个子代理，分别擅长说你好或再见

466
00:19:55,570 --> 00:19:59,790
然后根代理负责协调与用户的交互

467
00:19:59,880 --> 00:20:01,020
有了这些

468
00:20:01,020 --> 00:20:05,080
你已准备好继续进行遗传知识图谱构建

