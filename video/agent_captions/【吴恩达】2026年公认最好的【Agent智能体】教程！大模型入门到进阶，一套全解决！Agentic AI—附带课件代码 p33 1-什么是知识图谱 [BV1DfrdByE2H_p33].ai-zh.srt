1
00:00:00,220 --> 00:00:01,220
在本节课中

2
00:00:01,220 --> 00:00:03,360
我们将讲解知识图谱的概念

3
00:00:03,360 --> 00:00:07,140
以及它们如何帮助表示和检索数据中的关系

4
00:00:07,140 --> 00:00:08,780
接下来你将探索数据集

5
00:00:08,780 --> 00:00:11,040
你将动手构建一个知识图谱

6
00:00:11,040 --> 00:00:12,520
让我们开始吧

7
00:00:12,520 --> 00:00:14,480
那么什么是知识图谱

8
00:00:14,480 --> 00:00:19,730
我们暂时退后一步，回顾关系型数据库

9
00:00:19,730 --> 00:00:21,790
以及关系型模式的结构

10
00:00:21,790 --> 00:00:24,759
我们可能都熟悉这样的场景

11
00:00:24,759 --> 00:00:28,380
左边有一个表格，右边也有一个表格

12
00:00:28,380 --> 00:00:29,660
中间这个表格

13
00:00:29,660 --> 00:00:34,500
这是连接表，允许人员与产品之间建立多对多关系

14
00:00:34,500 --> 00:00:36,410
在本例中

15
00:00:36,410 --> 00:00:38,610
让我们考虑这两个表格和连接表

16
00:00:39,730 --> 00:00:40,570
如果你提出一个问题

17
00:00:40,570 --> 00:00:43,690
比如这个人购买了哪些产品

18
00:00:43,690 --> 00:00:46,850
你会先从人员表开始，选择此处的人员

19
00:00:46,850 --> 00:00:49,010
其标识为abk

20
00:00:49,010 --> 00:00:52,340
当然你需要通过连接到人员产品表

21
00:00:52,340 --> 00:00:57,360
你会看到人员产品表中存在abk与某把椅子的关联

22
00:00:57,360 --> 00:00:58,300
a k与一盏台灯

23
00:00:58,300 --> 00:00:59,820
abk与一张书桌

24
00:00:59,820 --> 00:01:01,960
太棒了，一个词

25
00:01:01,960 --> 00:01:06,080
从人员表跨连接到人员产品表再到产品表

26
00:01:06,080 --> 00:01:07,740
现在你已得到完整答案

27
00:01:07,740 --> 00:01:12,840
从abk可以看到这里是他购买的产品，包括椅子

28
00:01:12,840 --> 00:01:13,640
台灯和书桌

29
00:01:13,640 --> 00:01:16,360
你可以获取这些购买的详细信息

30
00:01:16,360 --> 00:01:18,200
如果扩展这个问题

31
00:01:18,200 --> 00:01:22,660
并询问还有谁购买了abk购买的产品

32
00:01:22,660 --> 00:01:23,860
你从相同的连接开始

33
00:01:23,860 --> 00:01:25,620
从abk到产品

34
00:01:25,620 --> 00:01:28,540
然后连接回人员产品表

35
00:01:28,540 --> 00:01:30,960
再从那里回到人员表

36
00:01:30,960 --> 00:01:36,969
现在你会得到购买了abk同类产品的人员ee

37
00:01:36,969 --> 00:01:40,469
但注意ee还多买了一个产品

38
00:01:40,469 --> 00:01:41,270
嗯

39
00:01:41,270 --> 00:01:42,850
这很有趣

40
00:01:43,050 --> 00:01:47,350
因此我们可以进一步扩展这个问题

41
00:01:47,350 --> 00:01:48,190
哪种产品

42
00:01:48,190 --> 00:01:51,020
我们应该推荐abk下次购买

43
00:01:51,020 --> 00:01:54,300
这就是推荐查询的基础

44
00:01:54,300 --> 00:01:57,420
如果你发现abk的购买模式

45
00:01:57,420 --> 00:02:01,870
与其他人或群体的购买模式匹配

46
00:02:01,870 --> 00:02:05,730
想要推荐给abk的是其他人购买的产品

47
00:02:05,730 --> 00:02:08,770
而abk尚未购买的，因此同样的连接步骤

48
00:02:08,770 --> 00:02:13,870
从abk通过产品连接到购买同类产品的其他人员

49
00:02:13,870 --> 00:02:15,600
连接次数太多

50
00:02:15,600 --> 00:02:17,510
这有点复杂

51
00:02:17,510 --> 00:02:19,830
其实有一个更优雅的方式来思考这个问题

52
00:02:19,830 --> 00:02:21,050
现在来执行这个查询

53
00:02:21,050 --> 00:02:22,970
让我们将其转换为图形结构

54
00:02:22,970 --> 00:02:26,679
第一步是删除所有无关记录

55
00:02:26,679 --> 00:02:29,269
所有那些未参与原始查询的优质记录

56
00:02:29,269 --> 00:02:32,629
暂时将这些记录搁置一旁，专注于已知记录

57
00:02:32,629 --> 00:02:34,069
属于数据集的部分

58
00:02:34,069 --> 00:02:34,509
到目前为止

59
00:02:34,509 --> 00:02:38,600
这对推荐给abk的内容查询至关重要

60
00:02:38,600 --> 00:02:41,200
移除中间所有联合表记录

61
00:02:41,200 --> 00:02:42,100
将这些转换为箭头

62
00:02:42,100 --> 00:02:45,690
直接连接abk到他购买的产品

63
00:02:45,690 --> 00:02:49,200
同样处理ee到他们购买的产品

64
00:02:49,200 --> 00:02:51,600
现在稍微调整记录位置

65
00:02:51,600 --> 00:02:55,170
这样abk在一边，另一边

66
00:02:55,170 --> 00:02:56,810
现在看起来整洁多了

67
00:02:56,810 --> 00:02:58,550
更容易理解其中逻辑

68
00:02:58,550 --> 00:03:02,060
a k和e都连接到中间产品

69
00:03:02,060 --> 00:03:08,320
但此人还连接到与abk无关的另一产品

70
00:03:08,320 --> 00:03:12,960
可以通过模式匹配将其转化为查询

71
00:03:12,960 --> 00:03:15,329
以abk在左侧开始

72
00:03:15,329 --> 00:03:19,109
可以用名为cipher的查询语言描述

73
00:03:19,109 --> 00:03:21,429
看起来类似sql

74
00:03:21,429 --> 00:03:23,940
如果sql具备模式匹配能力

75
00:03:23,940 --> 00:03:28,879
这里描述要查找的数据记录模式

76
00:03:28,879 --> 00:03:32,339
从我们将称为abk的数据记录开始

77
00:03:32,339 --> 00:03:34,470
具有person标签

78
00:03:34,470 --> 00:03:37,090
并有一个名为key的属性

79
00:03:37,090 --> 00:03:38,950
其值为abk

80
00:03:38,950 --> 00:03:40,490
这部分用圆括号表示

81
00:03:40,490 --> 00:03:42,840
在图论中这是一个节点

82
00:03:42,840 --> 00:03:48,080
然后有一个右向箭头带purchased

83
00:03:48,080 --> 00:03:49,540
这是关系类型

84
00:03:49,540 --> 00:03:50,730
即为购买行为

85
00:03:50,730 --> 00:03:55,630
匹配abk购买到其他括号中的模式

86
00:03:55,630 --> 00:03:57,660
我们称之为abk产品

87
00:03:57,660 --> 00:04:01,760
从abk到匹配产品的模式

88
00:04:01,760 --> 00:04:03,699
可以直接返回这些结果

89
00:04:03,699 --> 00:04:06,450
对应中间部分

90
00:04:06,530 --> 00:04:11,500
可扩展该模式包含其他购买者

91
00:04:11,500 --> 00:04:14,500
从abk到其购买产品

92
00:04:14,500 --> 00:04:18,760
还可关联到产品并说明

93
00:04:18,760 --> 00:04:20,839
有其他人购买了这些产品

94
00:04:20,839 --> 00:04:25,610
该模式会找到与abk共有的产品

95
00:04:25,610 --> 00:04:30,200
可进一步扩展以解决推荐问题

96
00:04:30,200 --> 00:04:32,800
而不仅仅是寻找其他产品

97
00:04:33,840 --> 00:04:35,400
其他产品具有独特属性

98
00:04:35,400 --> 00:04:38,760
这些是abk尚未拥有的

99
00:04:38,760 --> 00:04:43,330
保持相同模式从abk到产品再到他人

100
00:04:43,330 --> 00:04:45,890
并扩展到其他产品

101
00:04:45,890 --> 00:04:50,719
现在我们添加了一个谓词，表示我们实际上希望一个负模式为真

102
00:04:50,719 --> 00:04:53,990
Abk 没有购买那些其他产品

103
00:04:53,990 --> 00:04:56,850
所以Abk 没有购买那些其他产品的地方

104
00:04:56,850 --> 00:04:59,470
所以下方那个虚线部分

105
00:04:59,470 --> 00:05:01,010
从Abk 到沙发

106
00:05:01,010 --> 00:05:02,900
我们希望这个不存在

107
00:05:02,900 --> 00:05:03,340
现在

108
00:05:03,340 --> 00:05:04,720
我们正在描述一个模式

109
00:05:04,720 --> 00:05:06,640
同时包含应该存在的记录

110
00:05:06,640 --> 00:05:08,220
某些不应该存在的事物

111
00:05:08,220 --> 00:05:13,180
其他产品现在将缩减为Abk 未购买的产品

112
00:05:13,180 --> 00:05:14,180
这就是我们要使用的

113
00:05:14,180 --> 00:05:16,390
作为他购买的推荐

114
00:05:16,470 --> 00:05:19,190
那么知识图谱到底是什么

115
00:05:19,190 --> 00:05:22,050
它是一种以节点表示信息的数据库

116
00:05:22,050 --> 00:05:23,390
代表人物等实体

117
00:05:23,390 --> 00:05:23,810
产品

118
00:05:23,810 --> 00:05:24,430
博客

119
00:05:24,430 --> 00:05:27,430
任何你想在数据库中记录的内容

120
00:05:27,430 --> 00:05:32,580
但同时也包含非简单连接表的关联关系

121
00:05:32,580 --> 00:05:33,980
而是作为一等公民存在

122
00:05:33,980 --> 00:05:37,760
数据库中实际存在具有语义含义的数据记录

123
00:05:37,760 --> 00:05:40,160
它们真正表示两个节点的连接方式

124
00:05:40,160 --> 00:05:43,020
并添加关于这两个节点的信息

125
00:05:43,020 --> 00:05:45,720
因此节点和关系都具有键值属性

126
00:05:45,720 --> 00:05:48,100
节点有多个标签

127
00:05:48,100 --> 00:05:49,660
关系始终有方向性

128
00:05:49,660 --> 00:05:51,230
且具有单一类型

129
00:05:51,230 --> 00:05:55,330
用于模式匹配的查询语言称为Cypher

130
00:05:55,330 --> 00:05:58,650
结果发现这对映射自然语言非常方便

131
00:05:58,650 --> 00:06:01,830
也非常适合与生成式AI和LLM协作

132
00:06:01,830 --> 00:06:04,340
因为LLM擅长自然语言处理

133
00:06:04,340 --> 00:06:08,340
如果我们回到之前的查询

134
00:06:08,340 --> 00:06:11,180
你可以朗读并理解它

135
00:06:11,180 --> 00:06:13,740
匹配Abk 这个名为

136
00:06:13,740 --> 00:06:17,750
Abk 购买了一些其他人也购买的产品

137
00:06:17,750 --> 00:06:22,390
他购买了其他产品，而Abk 未购买这些产品

138
00:06:22,390 --> 00:06:24,810
知识图谱的另一个有趣之处

139
00:06:24,810 --> 00:06:27,690
在于它能方便整合非结构化数据

140
00:06:27,690 --> 00:06:29,270
与结构化数据结合

141
00:06:29,270 --> 00:06:32,790
无论是我们的产品还是人物

142
00:06:32,790 --> 00:06:34,330
任何结构化数据中的内容

143
00:06:34,330 --> 00:06:36,490
然后可以添加任意文本块

144
00:06:36,490 --> 00:06:39,900
将其向量化存储在数据库中

145
00:06:39,900 --> 00:06:46,270
结合向量相似度搜索和模式匹配实现多种强大查询

146
00:06:46,270 --> 00:06:47,370
例如

147
00:06:47,370 --> 00:06:48,910
如果你想进行根本原因分析

148
00:06:49,950 --> 00:06:54,470
假设你是一家家具制造商，想要了解客户投诉

149
00:06:54,470 --> 00:06:55,560
关于你们的产品

150
00:06:55,560 --> 00:06:57,380
于是你召集专家团队

151
00:06:57,380 --> 00:06:59,240
你知道数据工程和数据分析团队

152
00:06:59,240 --> 00:07:00,220
然后说嘿

153
00:07:00,220 --> 00:07:01,780
你能做一下根本原因分析吗

154
00:07:01,780 --> 00:07:05,340
我听说网上有很多关于我们产品的投诉

155
00:07:05,340 --> 00:07:07,600
我们得想办法找出问题所在

156
00:07:07,600 --> 00:07:11,830
根本原因分析会包含类似哪些产品问题最多的问题

157
00:07:11,830 --> 00:07:13,530
然后根据这些产品

158
00:07:13,530 --> 00:07:13,830
嗯

159
00:07:13,830 --> 00:07:15,850
产品哪个部分才是实际问题所在

160
00:07:15,850 --> 00:07:17,470
然后你可能需要问一个问题

161
00:07:17,470 --> 00:07:19,570
比如该部件本身有问题吗

162
00:07:19,570 --> 00:07:21,230
或许还有其他因素在起作用

163
00:07:21,230 --> 00:07:22,630
人们可能就是不喜欢这个产品

164
00:07:22,630 --> 00:07:24,590
但如果你能采取纠正措施

165
00:07:24,590 --> 00:07:27,590
可能是因为制造流程存在问题

166
00:07:27,590 --> 00:07:29,710
这里需要寻找可采取的纠正措施

167
00:07:29,710 --> 00:07:33,620
针对可以改进的问题进行根本原因分析

168
00:07:33,620 --> 00:07:34,860
如果是设计问题

169
00:07:34,860 --> 00:07:36,700
可以转交给设计团队处理

170
00:07:36,700 --> 00:07:39,140
他们可以分析用户的投诉内容

171
00:07:39,140 --> 00:07:42,320
但如果是制造问题或部件问题

172
00:07:42,320 --> 00:07:44,600
可以在相关环节进行分析

173
00:07:44,600 --> 00:07:45,900
找出部件问题

174
00:07:45,900 --> 00:07:48,090
要么更换新部件

175
00:07:48,090 --> 00:07:50,920
要么优化生产流程

176
00:07:50,920 --> 00:07:52,360
作为数据工程师

177
00:07:52,360 --> 00:07:53,580
如果接到这项任务

178
00:07:53,580 --> 00:07:55,040
你会从常规步骤开始

179
00:07:55,040 --> 00:07:57,000
提出澄清问题

180
00:07:57,280 --> 00:07:58,900
我们为什么要做这件事

181
00:07:58,900 --> 00:08:03,120
需要理解供应链可能存在制造问题

182
00:08:03,120 --> 00:08:03,700
好的

183
00:08:03,700 --> 00:08:04,510
明白了

184
00:08:04,510 --> 00:08:05,670
第二个问题是

185
00:08:05,670 --> 00:08:08,630
或者要确定可用数据

186
00:08:08,630 --> 00:08:10,770
以便进行分析

187
00:08:10,770 --> 00:08:13,690
在这个场景中我们需要构建材料

188
00:08:13,690 --> 00:08:18,320
连接产品到供应商的CSV文件

189
00:08:18,320 --> 00:08:20,080
可能来自某些电子表格

190
00:08:20,080 --> 00:08:24,100
可能来自不适合分析的关系型数据库

191
00:08:24,100 --> 00:08:24,980
没关系

192
00:08:24,980 --> 00:08:25,570
太

193
00:08:25,570 --> 00:08:27,950
同时还有用户评论数据

194
00:08:27,950 --> 00:08:30,440
从互联网上抓取的网站数据

195
00:08:30,440 --> 00:08:32,960
需要整合成一个数据集

196
00:08:32,960 --> 00:08:34,890
便于后续分析

197
00:08:34,890 --> 00:08:36,250
为了进行分析

198
00:08:36,250 --> 00:08:38,950
需要构建知识图谱连接所有数据

199
00:08:38,950 --> 00:08:42,770
这就是目标数据模型的左侧视图

200
00:08:42,770 --> 00:08:44,350
大致呈米色方框

201
00:08:44,350 --> 00:08:46,830
在那边你可以看到可用的CSV文件

202
00:08:46,830 --> 00:08:49,690
每个都会转化为图中的节点

203
00:08:49,690 --> 00:08:51,250
或者图中的关系

204
00:08:52,330 --> 00:08:55,250
这就是我们所说的领域图

205
00:08:55,250 --> 00:08:56,610
在右侧

206
00:08:56,610 --> 00:09:00,840
底部还有一些米色方框代表Markdown文件

207
00:09:00,840 --> 00:09:03,000
这些Markdown文件将会被分块处理

208
00:09:03,000 --> 00:09:05,750
它们也会在图中创建文档

209
00:09:05,750 --> 00:09:07,830
然后所有内容都将相互连接

210
00:09:07,830 --> 00:09:12,390
在实际描述代理时我们会详细讲解

211
00:09:12,390 --> 00:09:17,430
但我要重点指出的是这些部分高度互联

212
00:09:17,430 --> 00:09:19,490
同时又是图中非常独立的部分

213
00:09:19,490 --> 00:09:20,990
我们有数据源

214
00:09:20,990 --> 00:09:23,110
一侧是结构化数据

215
00:09:23,110 --> 00:09:26,370
那里将形成我们所说的领域图

216
00:09:26,370 --> 00:09:29,470
这就是我们可以查询的结构化数据

217
00:09:29,470 --> 00:09:31,560
另一侧是模式匹配

218
00:09:31,560 --> 00:09:35,020
非结构化数据源不会以相同方式查询

219
00:09:35,020 --> 00:09:37,670
也不会以相同方式导入

220
00:09:37,670 --> 00:09:40,410
它们将形成我们所说的词汇图

221
00:09:40,410 --> 00:09:42,670
代表原始文本数据

222
00:09:42,670 --> 00:09:47,210
同时连接文本数据的结构以关联两者

223
00:09:47,210 --> 00:09:51,210
非结构化数据与结构化数据之间

224
00:09:51,210 --> 00:09:53,270
中间部分称为主题图

225
00:09:53,270 --> 00:09:57,430
主题图包含从分块中提取的主题或实体

226
00:09:57,430 --> 00:09:59,119
分块将包含一些文本

227
00:09:59,119 --> 00:10:00,339
可能讨论产品

228
00:10:00,339 --> 00:10:02,579
可能提到用户名等

229
00:10:02,579 --> 00:10:04,500
这些都是可能的实体

230
00:10:04,500 --> 00:10:06,840
我们将识别这些并称为主题

231
00:10:06,840 --> 00:10:09,140
这些主题将连接到对象

232
00:10:09,140 --> 00:10:10,700
主题会描述某些内容

233
00:10:10,700 --> 00:10:12,419
例如某个用户

234
00:10:12,419 --> 00:10:13,459
假设是本人

235
00:10:13,459 --> 00:10:16,470
用户abk喜爱这张表格

236
00:10:16,470 --> 00:10:20,690
主题图中会出现主题谓词对象结构

237
00:10:20,690 --> 00:10:23,270
描述abk喜爱某张表格

238
00:10:23,270 --> 00:10:26,310
因为abk喜爱某张表格

239
00:10:26,310 --> 00:10:30,410
该表格可对应结构化数据中的产品

240
00:10:30,410 --> 00:10:32,190
如果abk提到一张表格

241
00:10:32,190 --> 00:10:35,090
而该表格是结构化数据中的产品

242
00:10:35,090 --> 00:10:39,330
我们可以将从文本中提取的实体连接起来

243
00:10:39,330 --> 00:10:42,030
一直连接到CSV文件中的结构化数据

244
00:10:42,030 --> 00:10:43,670
来自CSV文件

245
00:10:43,930 --> 00:10:44,750
不用担心

246
00:10:44,750 --> 00:10:47,630
我们将逐步在高层次进行讲解

247
00:10:47,630 --> 00:10:51,410
最终你会得到一个包含子图的图

248
00:10:51,410 --> 00:10:52,410
领域图

249
00:10:52,410 --> 00:10:55,080
主题图和词汇图

