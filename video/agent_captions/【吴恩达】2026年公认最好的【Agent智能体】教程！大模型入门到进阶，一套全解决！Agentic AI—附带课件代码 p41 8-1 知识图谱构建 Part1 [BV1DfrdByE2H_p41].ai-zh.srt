1
00:00:00,140 --> 00:00:04,420
现在你拥有了构建知识图谱的完整规范

2
00:00:04,580 --> 00:00:06,280
让我们进入这最后一课

3
00:00:06,280 --> 00:00:09,520
在这里你将定义执行构建计划的工具

4
00:00:09,520 --> 00:00:17,120
按照代理工作流中已有的图谱构建计划和知识抽取计划

5
00:00:17,120 --> 00:00:19,260
你现在已准备好构建图谱

6
00:00:19,260 --> 00:00:20,650
在本课中

7
00:00:20,650 --> 00:00:24,810
你将深入探讨知识图谱构建工具的细节

8
00:00:24,810 --> 00:00:26,570
如果你慷慨大方

9
00:00:26,570 --> 00:00:29,670
可以称其为神经符号代理

10
00:00:29,670 --> 00:00:33,030
语言模型与基于规则系统的混合体

11
00:00:33,030 --> 00:00:37,410
让我们暂时后退一步看看这些计划将产生什么

12
00:00:37,410 --> 00:00:39,270
图谱构建计划

13
00:00:39,270 --> 00:00:43,190
将加载CSV文件生成领域图

14
00:00:43,190 --> 00:00:47,430
几乎每个CSV文件都对应一个节点类型

15
00:00:47,430 --> 00:00:50,400
通过额外映射创建关系

16
00:00:50,400 --> 00:00:55,550
你可以让拥有大上下文窗口的LLM执行此任务

17
00:00:55,550 --> 00:01:01,150
但这是一个非常直接的机械过程你已转化为代码

18
00:01:01,150 --> 00:01:04,190
这项工作将由你定义的单一工具完成

19
00:01:04,190 --> 00:01:06,789
称为构建领域图

20
00:01:06,789 --> 00:01:09,429
该工具将包含大量辅助函数

21
00:01:09,429 --> 00:01:11,569
用于图构建的不同部分

22
00:01:11,569 --> 00:01:14,720
我们将逐一讲解这些工具

23
00:01:14,720 --> 00:01:15,540
一如既往

24
00:01:15,540 --> 00:01:16,800
我们导入一些库

25
00:01:18,840 --> 00:01:21,080
检查OpenAI是否运行

26
00:01:22,000 --> 00:01:26,320
同时确保四j仍存在完美现在

27
00:01:26,320 --> 00:01:30,279
开始构建领域图的工具

28
00:01:30,279 --> 00:01:32,119
我们可以创建一系列工具

29
00:01:32,119 --> 00:01:34,920
每个工具职责明确

30
00:01:34,920 --> 00:01:38,580
首先为数据库创建唯一性约束

31
00:01:38,580 --> 00:01:39,680
现在我们从

32
00:01:39,680 --> 00:01:41,020
仅思考数据文件

33
00:01:41,020 --> 00:01:45,030
必须准备数据库以应对即将进行的数据导入

34
00:01:46,270 --> 00:01:50,650
数据库准备的第一步是确保唯一性约束

35
00:01:50,650 --> 00:01:52,250
在最终的数据库中

36
00:01:52,250 --> 00:01:55,610
对于具有特定标签的节点

37
00:01:55,610 --> 00:01:58,030
当该标签出现时

38
00:01:58,030 --> 00:02:02,289
某个标签属性需要唯一

39
00:02:02,289 --> 00:02:05,929
这与具有唯一列的CSV文件完全对应

40
00:02:05,929 --> 00:02:06,529
ID

41
00:02:06,529 --> 00:02:09,579
将成为每个的唯一约束

42
00:02:09,579 --> 00:02:12,459
此实用函数将处理此事

43
00:02:12,459 --> 00:02:16,710
只需传入标签和唯一属性键

44
00:02:16,710 --> 00:02:20,070
将自动在四j创建约束

45
00:02:20,070 --> 00:02:21,850
下方的Cypher查询

46
00:02:21,850 --> 00:02:24,560
可以看到创建约束

47
00:02:24,560 --> 00:02:28,930
传入的约束名称仅在不存在时创建

48
00:02:28,930 --> 00:02:31,670
为特定标签创建

49
00:02:31,670 --> 00:02:37,520
在该标签下要求此唯一属性键唯一

50
00:02:37,520 --> 00:02:39,720
在此之前我们大量使用查询参数

51
00:02:40,720 --> 00:02:43,620
当我们设置这样的约束时，而不是新的四j

52
00:02:43,620 --> 00:02:46,440
无法为此传递查询参数

53
00:02:46,440 --> 00:02:49,220
我们将在这里进行一些不安全的操作

54
00:02:49,220 --> 00:02:51,550
通过实际进行字符串拼接

55
00:02:51,550 --> 00:02:54,250
我们知道这不是推荐的做法

56
00:02:54,250 --> 00:02:57,700
我们应该在此处有一个净化函数以确保安全

57
00:02:57,700 --> 00:02:57,980
这就是

58
00:02:57,980 --> 00:02:58,980
你知道这是不好的

59
00:02:58,980 --> 00:03:01,580
但暂时这样就可以了

60
00:03:02,080 --> 00:03:03,460
所以下一个函数你想要

61
00:03:03,460 --> 00:03:07,089
如果你有能力为节点创建唯一性约束

62
00:03:07,089 --> 00:03:10,269
我们接下来需要能够从CSV文件加载节点

63
00:03:10,269 --> 00:03:13,040
你可以为此定义一个函数

64
00:03:13,160 --> 00:03:17,880
这里就是加载节点的CSV函数，它接受源文件

65
00:03:17,880 --> 00:03:19,840
该源文件的标签

66
00:03:19,840 --> 00:03:23,490
CSV文件中哪个列是唯一的

67
00:03:23,490 --> 00:03:28,290
然后还需要一个包含所有应从源文件创建的属性列表

68
00:03:28,590 --> 00:03:30,850
现在看下面生成的密码

69
00:03:30,850 --> 00:03:33,190
有专门的语法用于从CSV文件加载

70
00:03:33,190 --> 00:03:36,000
位于导入目录中的CSV文件

71
00:03:36,000 --> 00:03:39,700
这就是为什么我们处理的都是相对路径

72
00:03:39,700 --> 00:03:44,210
当我们使用load cas fee在u四j中时，此文件URL

73
00:03:44,210 --> 00:03:48,280
这里的路径将相对于新四j的导入目录

74
00:03:48,280 --> 00:03:51,640
我们将从该目录加载带标题的CSV文件

75
00:03:51,640 --> 00:03:55,370
然后对于该文件中的每一行

76
00:03:55,370 --> 00:03:57,230
我们将在此调用子查询

77
00:03:57,230 --> 00:03:58,590
在子查询中

78
00:03:58,590 --> 00:04:02,410
它将执行这些行的合并操作

79
00:04:02,410 --> 00:04:06,360
当然会先检查节点是否存在

80
00:04:06,360 --> 00:04:07,120
如果不存在

81
00:04:07,120 --> 00:04:11,520
将根据传入的唯一列创建该节点

82
00:04:11,520 --> 00:04:13,880
接下来的这行代码

83
00:04:13,880 --> 00:04:14,240
四

84
00:04:14,240 --> 00:04:20,100
each是一种利用传入属性列表的独特方式

85
00:04:20,100 --> 00:04:21,660
它只是某些属性的名称

86
00:04:21,660 --> 00:04:24,480
我们最终会遍历每个属性

87
00:04:24,480 --> 00:04:26,620
对于每个属性名称

88
00:04:26,620 --> 00:04:32,950
我们将为刚创建的节点设置属性值

89
00:04:32,950 --> 00:04:35,539
来自CSV文件的行值

90
00:04:35,539 --> 00:04:37,859
实际上我们将遍历所有名称并继续

91
00:04:37,859 --> 00:04:40,990
逐步设置这些值

92
00:04:40,990 --> 00:04:42,530
通过在子查询中使用此方法

93
00:04:42,530 --> 00:04:45,470
我们能够批量处理

94
00:04:45,470 --> 00:04:47,770
因此我们将分批次处理，每次一千行

95
00:04:47,770 --> 00:04:50,210
无论CSV文件多大

96
00:04:50,210 --> 00:04:53,039
我们将分批处理，每次一千行

97
00:04:53,039 --> 00:04:55,879
你可以看到我们将调用的新四j

98
00:04:55,879 --> 00:04:56,879
传入查询

99
00:04:56,879 --> 00:04:58,419
我们将传递该查询

100
00:04:58,419 --> 00:05:01,779
并附带大量查询参数以供使用

101
00:05:02,860 --> 00:05:04,780
现在对于你拥有的每个CSV文件

102
00:05:04,780 --> 00:05:07,600
你实际上需要执行我们刚刚定义的两个函数

103
00:05:07,600 --> 00:05:09,060
我们首先要调用这两个函数

104
00:05:09,060 --> 00:05:11,209
调用创建唯一性约束的功能

105
00:05:11,209 --> 00:05:14,210
以确保每个节点都有唯一值

106
00:05:14,210 --> 00:05:15,750
这样ID才能被正确识别

107
00:05:15,750 --> 00:05:19,510
然后在为每个CSV文件创建唯一性约束后

108
00:05:19,510 --> 00:05:21,790
我们将继续执行实际的数据导入

109
00:05:21,790 --> 00:05:26,060
使用我们刚才看到的从CSV加载节点工具

110
00:05:26,060 --> 00:05:27,240
这就是当前发生的情况

111
00:05:27,240 --> 00:05:28,520
在导入节点过程中

112
00:05:28,520 --> 00:05:30,740
只是应用构建规则

113
00:05:30,740 --> 00:05:33,160
然后基于构建规则中的值

114
00:05:33,160 --> 00:05:37,330
将调用创建唯一性约束工具

115
00:05:37,330 --> 00:05:39,170
如果没有错误发生

116
00:05:39,170 --> 00:05:42,659
将继续从CSV文件导入节点

117
00:05:42,659 --> 00:05:45,779
这里只是从构建规则中提取

118
00:05:45,779 --> 00:05:49,139
需要传递给函数的不同值

119
00:05:50,370 --> 00:05:53,250
现在可以更简单地导入关系

120
00:05:53,250 --> 00:05:57,210
在关系中不需要为它们应用唯一性约束

121
00:05:57,210 --> 00:05:59,850
因为它们本身没有独立标识

122
00:05:59,850 --> 00:06:03,400
它们将直接连接到两侧的节点

123
00:06:03,400 --> 00:06:05,100
无论是来源节点还是目标节点

124
00:06:05,100 --> 00:06:06,560
这些节点应该是唯一的

125
00:06:06,560 --> 00:06:08,560
但关系本身也会是唯一的

126
00:06:08,560 --> 00:06:11,530
因为每行只有一个对应关系

127
00:06:11,530 --> 00:06:13,600
在导入的文件中

128
00:06:13,600 --> 00:06:17,260
这特别适用于我们当前的数据文件

129
00:06:17,260 --> 00:06:19,320
如果需要的话需要更加谨慎

130
00:06:19,320 --> 00:06:19,680
你知道的

131
00:06:19,680 --> 00:06:22,450
数据文件可能设置得更复杂

132
00:06:22,450 --> 00:06:24,850
但对于本例中的数据文件

133
00:06:24,850 --> 00:06:28,020
这种方法无法正确完成导入

134
00:06:28,020 --> 00:06:30,000
如同节点加载一样

135
00:06:30,000 --> 00:06:34,260
我们将使用导入目录中的带标题的LOAD CSV

136
00:06:34,260 --> 00:06:36,070
并将所有内容作为行加载

137
00:06:36,070 --> 00:06:37,310
然后对于每一行

138
00:06:37,310 --> 00:06:41,169
我们需要在子查询中进行更多处理

139
00:06:41,169 --> 00:06:45,509
首先找到之前加载的现有节点

140
00:06:45,509 --> 00:06:48,800
找到来源节点和目标节点

141
00:06:48,800 --> 00:06:51,520
在使用MATCH子句找到这些节点后

142
00:06:51,520 --> 00:06:55,700
将使用MERGE子句创建关系

143
00:06:55,700 --> 00:06:57,980
从来源节点到目标节点

144
00:06:57,980 --> 00:07:02,870
这样只会为每对来源和目标创建一个关系

145
00:07:02,870 --> 00:07:06,039
以及特定类型的关系

146
00:07:06,039 --> 00:07:09,419
例如如果有两个ABK喜欢咖啡的关系

147
00:07:09,419 --> 00:07:11,790
玫瑰咖啡的情况只会出现一次

148
00:07:11,790 --> 00:07:16,620
即使CSV文件中有重复数据

149
00:07:16,620 --> 00:07:18,940
MERGE会检查节点

150
00:07:18,940 --> 00:07:21,000
两侧的节点已经是唯一的

151
00:07:21,000 --> 00:07:23,460
并且该关系已有abk的点赞

152
00:07:23,460 --> 00:07:24,900
所以点赞已经存在了

153
00:07:24,900 --> 00:07:27,140
不会创建另一个关系

154
00:07:27,140 --> 00:07:29,049
节点的情况也是如此

155
00:07:29,049 --> 00:07:31,649
我们将在关系上设置属性

156
00:07:31,649 --> 00:07:33,429
如果存在可用属性

157
00:07:33,429 --> 00:07:36,600
我们将使用这里的每个循环结构遍历它们

158
00:07:36,600 --> 00:07:38,400
并将所有可用值设置好

159
00:07:39,520 --> 00:07:40,960
然后继续调用查询

160
00:07:40,960 --> 00:07:47,200
并将所有查询参数直接从构造规则传入

161
00:07:47,800 --> 00:07:50,220
所有这些函数都完成了大部分实际工作

162
00:07:50,220 --> 00:07:52,520
然后构建主图本身

163
00:07:52,520 --> 00:07:56,080
实际上只需接收一个参数

164
00:07:56,080 --> 00:07:57,860
完整的构造计划

165
00:07:57,860 --> 00:08:01,300
然后按顺序先构建所有节点

166
00:08:01,300 --> 00:08:03,120
现在节点已存在

167
00:08:03,120 --> 00:08:08,560
然后可以使用已定义的主图创建关系

168
00:08:08,560 --> 00:08:11,040
我们现在可以尝试运行此代码

169
00:08:11,040 --> 00:08:14,600
当然我们需要完整的构造计划

170
00:08:14,600 --> 00:08:17,150
这里是完整的构造计划

171
00:08:17,150 --> 00:08:19,250
这将与之前的课程不同

172
00:08:19,250 --> 00:08:21,790
取决于lm的决定

173
00:08:21,790 --> 00:08:23,250
当此笔记本创建时

174
00:08:23,250 --> 00:08:25,799
这里是有效的构造计划

175
00:08:26,799 --> 00:08:28,019
你可以查看其中内容

176
00:08:28,019 --> 00:08:29,899
这有点预期中的结果

177
00:08:29,899 --> 00:08:32,308
我认为这里需要重点关注

178
00:08:32,308 --> 00:08:35,649
稍后检查创建的关系

179
00:08:35,649 --> 00:08:37,349
存在一个包含关系

180
00:08:37,349 --> 00:08:39,450
从产品出发

181
00:08:39,450 --> 00:08:41,669
包含一个装配组件，听起来合理

182
00:08:41,669 --> 00:08:45,479
这是一个部分关系，从零件出发

183
00:08:45,479 --> 00:08:47,319
零件属于一个装配组件

184
00:08:47,319 --> 00:08:47,679
好的

185
00:08:47,679 --> 00:08:49,039
这有点冗长

186
00:08:49,039 --> 00:08:50,430
但这是正确的

187
00:08:50,430 --> 00:08:54,670
这里的源节点是零件，由供应商提供

188
00:08:54,670 --> 00:08:57,070
看起来完全合理

189
00:08:57,210 --> 00:09:01,310
这将成为我们主图函数的输入

190
00:09:01,310 --> 00:09:03,629
现在运行该函数

191
00:09:03,629 --> 00:09:04,609
当函数执行完毕

192
00:09:04,609 --> 00:09:06,300
没有输出结果

193
00:09:06,300 --> 00:09:09,040
可以添加打印语句提示完成

194
00:09:09,040 --> 00:09:09,380
好的

195
00:09:09,380 --> 00:09:10,940
已完成所有工作

196
00:09:10,940 --> 00:09:13,640
接下来我们将实际操作图数据

197
00:09:13,640 --> 00:09:16,230
就像仍在进行查询一样

198
00:09:16,230 --> 00:09:21,450
让我们用更复杂的查询语句检查领域图

199
00:09:21,450 --> 00:09:27,660
我们将首先查找构造计划中的所有关系规则

200
00:09:27,660 --> 00:09:30,160
我们使用列表来实现

201
00:09:30,160 --> 00:09:32,480
Python中的表达式理解

202
00:09:32,480 --> 00:09:35,780
我们现在只需遍历所有构造计划值

203
00:09:35,780 --> 00:09:38,060
每当构造类型是关系时

204
00:09:38,060 --> 00:09:39,680
就会被放入这个列表

205
00:09:39,680 --> 00:09:42,500
这里是我们之前看到的所有构造

206
00:09:42,500 --> 00:09:44,569
但不包括节点构造

207
00:09:44,569 --> 00:09:48,640
然后我们在这里进行一点密码学魔法

208
00:09:48,640 --> 00:09:50,780
所以我将逐步解释这个过程

209
00:09:50,780 --> 00:09:52,480
在这复杂的Cypher查询中

210
00:09:52,480 --> 00:09:56,300
我们的目标是大致对图进行采样

211
00:09:56,300 --> 00:09:58,790
所以我们不会获取整个图来查看

212
00:09:58,790 --> 00:10:00,890
但我们要做的是我们期望

213
00:10:00,890 --> 00:10:04,079
对于这里所有的关系构造规则

214
00:10:04,079 --> 00:10:09,099
结果图中至少应存在该关系类型

215
00:10:09,099 --> 00:10:12,810
如果我们收集所有不同的关系类型

216
00:10:12,810 --> 00:10:14,730
并对它们进行模式匹配

217
00:10:14,730 --> 00:10:16,610
然后查看输出结果

218
00:10:16,610 --> 00:10:21,480
应该能看到所有预期创建的内容都已创建

219
00:10:21,480 --> 00:10:23,320
我不确定我是否表达正确

220
00:10:23,320 --> 00:10:26,420
但让我们实际走一遍看看计划如何

221
00:10:26,420 --> 00:10:30,869
第一步我们将传入这个构造规则列表

222
00:10:30,869 --> 00:10:31,909
在Cypher中

223
00:10:31,909 --> 00:10:37,579
你可以将列表展开为多行数据

224
00:10:37,579 --> 00:10:40,359
原本是一个包含规则的列表

225
00:10:40,359 --> 00:10:42,279
我们将其转换为多行

226
00:10:42,279 --> 00:10:47,600
每行包含单个规则元素

227
00:10:47,600 --> 00:10:52,900
这样关系构造列表将被拆分为多行

228
00:10:52,900 --> 00:10:57,540
每行包含单个构造值

229
00:10:57,780 --> 00:11:01,900
接下来我们要对构造规则

230
00:11:01,900 --> 00:11:06,660
进行从某个节点的模式匹配且无条件

231
00:11:06,660 --> 00:11:06,980
这里

232
00:11:11,460 --> 00:11:15,380
关系类型来自构造规则

233
00:11:15,380 --> 00:11:18,580
提取构造规则的关系类型值

234
00:11:18,580 --> 00:11:19,710
在这里

235
00:11:19,710 --> 00:11:22,570
美元符号引用查询参数

236
00:11:22,570 --> 00:11:26,270
我们将提取该值到此关系类型

237
00:11:26,270 --> 00:11:28,830
如果这里

238
00:11:28,830 --> 00:11:32,030
你会看到有'supplied by'关系类型

239
00:11:32,030 --> 00:11:35,170
该值将由查询参数替换

240
00:11:35,170 --> 00:11:39,819
从某个节点通过'supplied by'连接另一节点

241
00:11:39,819 --> 00:11:43,239
我们将返回来源节点的标签

242
00:11:43,239 --> 00:11:44,839
以及目标节点的标签

243
00:11:44,839 --> 00:11:47,319
以及关系本身的类型

244
00:11:47,319 --> 00:11:50,319
最终应得到一个三元组

245
00:11:50,319 --> 00:11:54,910
仅包含关系标签和两侧节点标签

246
00:11:54,910 --> 00:11:56,350
我们限制为仅一条结果

247
00:11:56,350 --> 00:11:57,790
因为我们不需要查看整个图

248
00:11:57,790 --> 00:12:00,140
只需验证存在性

249
00:12:00,140 --> 00:12:02,100
我们将将其放入子查询中

250
00:12:02,100 --> 00:12:05,519
这样我们只需在此处应用一次匹配

251
00:12:05,519 --> 00:12:08,019
对之前展开的每个元素进行操作

252
00:12:08,019 --> 00:12:09,239
这就是这里发生的情况

253
00:12:09,239 --> 00:12:11,470
在这一部分我们将调用子查询

254
00:12:11,470 --> 00:12:15,740
并将刚刚定义的匹配路径放入其中

255
00:12:15,740 --> 00:12:20,069
然后在完全组装的密码中展开列表

256
00:12:20,069 --> 00:12:22,469
在子查询内执行匹配

257
00:12:22,469 --> 00:12:27,930
然后从所有结果中返回源节点关系和两个节点的三元组

258
00:12:27,930 --> 00:12:29,390
这将是标签

259
00:12:29,390 --> 00:12:30,150
它们的类型

260
00:12:30,150 --> 00:12:32,819
以及两个节点上的标签

261
00:12:32,819 --> 00:12:33,339
好的

262
00:12:33,339 --> 00:12:36,360
你可以看到这将打印出值

263
00:12:36,360 --> 00:12:38,900
你可以看到运行前的密码结构

264
00:12:38,900 --> 00:12:41,940
然后我们将最终运行密码

265
00:12:42,260 --> 00:12:44,860
这里是完整的密码语句

266
00:12:46,109 --> 00:12:50,389
这里是我们从plotter找到的关系

267
00:12:50,389 --> 00:12:51,710
包含组装

268
00:12:51,710 --> 00:12:55,319
零件属于组装部件

269
00:12:55,319 --> 00:12:57,579
零件由供应商提供

270
00:12:57,579 --> 00:13:01,139
完美，这与之前构造池中的结果一致

271
00:13:01,139 --> 00:13:04,439
看来这个图以良好的方式构建完成

