1
00:00:00,060 --> 00:00:01,620
在构建基因工作流时

2
00:00:01,620 --> 00:00:05,920
我通常会建议团队专注于获取高质量输出

3
00:00:05,920 --> 00:00:08,160
并优化成本和延迟

4
00:00:08,160 --> 00:00:11,699
但后来发现延迟成本并不那么重要

5
00:00:11,699 --> 00:00:18,230
但我认为提升性能或输出质量通常是最难的部分

6
00:00:18,230 --> 00:00:20,370
直到它真正运行起来

7
00:00:20,370 --> 00:00:22,620
那时或许可以关注其他方面

8
00:00:22,620 --> 00:00:26,760
我曾多次遇到团队构建了一个基因工作流

9
00:00:26,760 --> 00:00:28,250
并将其交付给用户使用

10
00:00:28,250 --> 00:00:31,710
幸运的是有大量用户使用它

11
00:00:31,710 --> 00:00:33,550
导致成本实际成为问题

12
00:00:33,550 --> 00:00:34,610
然后我们不得不

13
00:00:34,610 --> 00:00:35,150
你知道的

14
00:00:35,150 --> 00:00:37,410
匆忙降低成本

15
00:00:37,410 --> 00:00:38,950
但这也是个好问题

16
00:00:38,950 --> 00:00:39,110
所以

17
00:00:39,110 --> 00:00:42,030
我通常会把成本放在次要位置

18
00:00:42,030 --> 00:00:44,500
嗯，不是完全忽视

19
00:00:44,500 --> 00:00:47,220
只是优先级较低需要关注

20
00:00:47,220 --> 00:00:51,440
直到用户量庞大到需要降低人均成本

21
00:00:51,440 --> 00:00:55,280
而延迟问题我会稍加关注

22
00:00:55,280 --> 00:00:55,780
但同样

23
00:00:55,780 --> 00:00:59,370
不如确保输出质量重要

24
00:00:59,370 --> 00:01:00,710
但当你达到目标时

25
00:01:00,710 --> 00:01:04,269
优化延迟和成本的工具会很有用

26
00:01:04,269 --> 00:01:06,810
让我们看看如何实现这些优化

27
00:01:06,810 --> 00:01:11,190
若要优化基因工作流的延迟

28
00:01:11,190 --> 00:01:16,780
我通常会先进行基准测试或计时

29
00:01:16,780 --> 00:01:20,420
在这个研究代理中包含多个步骤

30
00:01:20,420 --> 00:01:22,140
如果我要计时

31
00:01:22,140 --> 00:01:22,960
每个步骤

32
00:01:22,960 --> 00:01:26,100
生成搜索可能需要七秒

33
00:01:26,100 --> 00:01:27,880
网络搜索耗时五秒

34
00:01:27,880 --> 00:01:28,920
这一步三秒

35
00:01:28,920 --> 00:01:30,060
这一步十一秒

36
00:01:30,060 --> 00:01:33,340
最后撰写论文平均十八秒

37
00:01:33,340 --> 00:01:36,280
通过观察整体时间线

38
00:01:36,280 --> 00:01:43,630
可以判断哪些组件有优化空间

39
00:01:43,630 --> 00:01:44,590
在此例中

40
00:01:44,590 --> 00:01:46,670
可能有多种改进方案

41
00:01:46,670 --> 00:01:49,270
如果尚未利用并行处理

42
00:01:49,270 --> 00:01:49,870
对于某些步骤

43
00:01:49,870 --> 00:01:51,810
比如数据获取

44
00:01:51,810 --> 00:01:56,780
或许可以尝试部分操作并行化

45
00:01:56,780 --> 00:02:00,080
或发现某些步骤耗时过长

46
00:02:00,080 --> 00:02:02,080
如果第一步耗时七秒

47
00:02:02,080 --> 00:02:04,320
最后一步十八秒

48
00:02:04,320 --> 00:02:06,980
我可能考虑使用更小的模型

49
00:02:06,980 --> 00:02:11,080
尝试稍低智能的模型看是否仍有效

50
00:02:11,080 --> 00:02:13,580
或寻找更快的语言模型提供商

51
00:02:13,580 --> 00:02:16,840
API的损失在线不同接口

52
00:02:16,840 --> 00:02:22,380
有些公司有专用硬件以实现更快处理特定元素

53
00:02:22,380 --> 00:02:29,000
因此有时尝试不同服务商以找到最快返回令牌的更值得

54
00:02:29,000 --> 00:02:29,640
但至少

55
00:02:29,640 --> 00:02:34,320
进行此类时间分析可帮助确定需重点优化的组件

56
00:02:34,320 --> 00:02:36,920
在降低延迟方面

57
00:02:36,920 --> 00:02:39,090
在优化成本方面

58
00:02:39,090 --> 00:02:42,530
类似的计算需评估每一步的成本

59
00:02:42,530 --> 00:02:45,930
也能帮助基准测试并确定需优化的步骤

60
00:02:45,930 --> 00:02:48,670
许多服务商按令牌计费

61
00:02:48,670 --> 00:02:50,230
基于输入和输出长度

62
00:02:50,230 --> 00:02:53,310
许多API服务商按调用次数计费

63
00:02:53,310 --> 00:02:58,490
计算步骤成本可能因服务器容量付费方式不同而异

64
00:02:58,490 --> 00:02:59,990
以及服务费用

65
00:02:59,990 --> 00:03:02,240
对于此类流程

66
00:03:02,240 --> 00:03:08,680
在此例中可能决定该步骤平均每个令牌成本为零点零

67
00:03:08,680 --> 00:03:09,420
四美分

68
00:03:09,420 --> 00:03:10,320
每次网络搜索

69
00:03:10,320 --> 00:03:12,220
API可能成本一点

70
00:03:12,220 --> 00:03:14,060
六美分令牌成本如此

71
00:03:14,060 --> 00:03:15,440
API调用成本如此

72
00:03:15,440 --> 00:03:17,020
PDF转文本成本如此

73
00:03:17,020 --> 00:03:19,420
最终论文生成令牌成本如此

74
00:03:19,420 --> 00:03:21,540
这将再次帮助您了解

75
00:03:21,540 --> 00:03:23,500
是否存在更便宜的组件可用

76
00:03:23,500 --> 00:03:28,810
或寻找成本优化最大机会所在

77
00:03:28,810 --> 00:03:32,590
我发现这些基准测试非常清晰

78
00:03:32,590 --> 00:03:37,300
有时会明确告知某些组件无需过多关注

79
00:03:37,300 --> 00:03:38,840
因为它们影响不大

80
00:03:38,840 --> 00:03:42,209
并非成本或延迟的主要因素

81
00:03:42,209 --> 00:03:46,049
所以当成本或延迟成为问题时

82
00:03:46,049 --> 00:03:50,170
只需测量每一步的成本或延迟

83
00:03:50,170 --> 00:03:56,589
通常能为您提供优化组件的依据

84
00:03:56,789 --> 00:03:59,309
我们即将结束本模块

85
00:03:59,309 --> 00:04:00,469
我知道我们已涵盖很多内容

86
00:04:00,469 --> 00:04:01,949
感谢您的坚持

87
00:04:01,949 --> 00:04:05,500
让我们继续本模块最后一节收尾

