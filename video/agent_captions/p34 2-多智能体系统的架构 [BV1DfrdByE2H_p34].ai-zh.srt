1
00:00:00,220 --> 00:00:03,860
现在你已经了解了要构建的知识图谱的目标

2
00:00:03,860 --> 00:00:06,560
接下来让我们详细探讨多智能体系统的设计

3
00:00:06,560 --> 00:00:09,120
你将首先设计图模型

4
00:00:09,120 --> 00:00:12,950
然后为大量定义构建图结构

5
00:00:12,950 --> 00:00:14,030
这是我的定义

6
00:00:14,030 --> 00:00:16,670
我喜欢从工程角度思考智能体

7
00:00:16,670 --> 00:00:20,110
对我来说这就像一种新型的控制流操作符

8
00:00:20,110 --> 00:00:22,630
基本上你有一个循环结构

9
00:00:22,630 --> 00:00:26,770
循环内部会调用LLM来确定下一步行动

10
00:00:26,770 --> 00:00:28,730
然后根据确定的行动目标

11
00:00:28,730 --> 00:00:31,790
将结果返回到计算机端

12
00:00:31,790 --> 00:00:32,970
传回客户端

13
00:00:32,970 --> 00:00:36,730
真正执行到一个开关语句处理潜在操作

14
00:00:37,730 --> 00:00:40,910
在这个循环中这就是真正的智能行为

15
00:00:40,910 --> 00:00:42,930
这一切都得益于LLM的调用

16
00:00:42,930 --> 00:00:47,000
但智能行为的执行仍通过代码完成

17
00:00:47,120 --> 00:00:48,440
这种架构的优势

18
00:00:48,440 --> 00:00:50,240
当然在于智能体非常强大

19
00:00:50,240 --> 00:00:53,980
因为LLM能进行推理并调用各种工具

20
00:00:53,980 --> 00:00:54,680
可以执行任何代码操作

21
00:00:54,680 --> 00:00:55,870
并且具备灵活性

22
00:00:55,870 --> 00:00:56,870
因为LLM拥有记忆功能

23
00:00:56,870 --> 00:00:58,410
能够学习已发生事件

24
00:00:58,410 --> 00:01:00,040
无论是通过对话还是存储的重要信息

25
00:01:00,040 --> 00:01:03,400
这些信息对决定未来结果至关重要

26
00:01:03,400 --> 00:01:06,840
并且非常容易上手

27
00:01:06,840 --> 00:01:08,540
因为你只需用自然语言描述

28
00:01:08,540 --> 00:01:10,760
通过提示定义智能体的任务

29
00:01:10,760 --> 00:01:13,400
但这种强大与便捷也存在缺点

30
00:01:13,400 --> 00:01:16,900
使用智能体可能会很缓慢

31
00:01:16,900 --> 00:01:19,000
因为需要远程调用

32
00:01:19,000 --> 00:01:20,340
LLM的调用既昂贵又耗时

33
00:01:20,340 --> 00:01:22,470
这也是非确定性的

34
00:01:22,470 --> 00:01:23,930
因为LLM本身具有不确定性

35
00:01:23,930 --> 00:01:26,789
长期来看

36
00:01:26,789 --> 00:01:27,589
每次调用的token成本会累积很高

37
00:01:27,589 --> 00:01:30,629
如果在生产环境中持续运行智能体

38
00:01:30,629 --> 00:01:35,680
处理成千上万次调用

39
00:01:35,680 --> 00:01:39,000
token成本会迅速飙升

40
00:01:39,000 --> 00:01:41,760
这就是采用多智能体系统的优势之一

41
00:01:41,760 --> 00:01:45,280
可以改善这些缺点

42
00:01:45,280 --> 00:01:47,580
那么什么是多智能体系统

43
00:01:47,580 --> 00:01:52,390
本质上是多个智能体协作完成单一目标的系统

44
00:01:52,390 --> 00:01:55,590
智能体通常按层级结构组织

45
00:01:55,590 --> 00:01:58,330
顶层智能体负责整体流程管理

46
00:01:58,330 --> 00:02:01,370
然后可以添加任意数量的子级智能体

47
00:02:01,370 --> 00:02:05,940
负责不同工作阶段或特定任务

48
00:02:05,940 --> 00:02:08,699
智能体通过多种方式交互

49
00:02:08,699 --> 00:02:12,399
存在主要的对话线程与用户交互

50
00:02:12,399 --> 00:02:15,900
用户可能发起启动工作的消息

51
00:02:15,900 --> 00:02:17,880
然后每个代理都可以决定

52
00:02:17,880 --> 00:02:21,240
这是我可以做的工作还是应该由别人来做

53
00:02:21,240 --> 00:02:23,970
所以我可以将这项任务委派给其他代理

54
00:02:23,970 --> 00:02:25,610
你可以在这张示意图中看到

55
00:02:25,610 --> 00:02:30,260
根代理能够内部委派给代理A或代理B

56
00:02:30,260 --> 00:02:34,040
代理A和代理B可以使用分配给它们的工具执行任务

57
00:02:34,040 --> 00:02:36,240
代理B中的一个工具是独特的

58
00:02:36,240 --> 00:02:37,600
这里的P代理

59
00:02:37,600 --> 00:02:41,540
这个P函数实际上会成为另一个代理

60
00:02:41,540 --> 00:02:43,690
但被调用时像工具一样使用

61
00:02:43,690 --> 00:02:45,570
工具之间有两种交互方式

62
00:02:45,570 --> 00:02:47,310
要么代理之间互相委派任务

63
00:02:47,310 --> 00:02:51,490
或者作为工具的代理被另一个代理调用

64
00:02:51,490 --> 00:02:55,150
过程中还会有与用户的特定检查点

65
00:02:55,150 --> 00:02:57,760
每当发生这些转换时

66
00:02:57,920 --> 00:03:00,620
你构建的多代理系统是什么

67
00:03:00,620 --> 00:03:03,240
你将构建知识图谱代理的部分

68
00:03:03,240 --> 00:03:07,280
专注于执行知识图谱构建的子代理

69
00:03:07,280 --> 00:03:10,620
你将学习使用谷歌ADK构建代理的基础

70
00:03:10,620 --> 00:03:14,780
你将了解记忆是什么以及如何记录关键信息

71
00:03:14,780 --> 00:03:16,020
你将找到一些工具

72
00:03:16,020 --> 00:03:21,080
当然这一切都将从开放式对话转化为可执行代码

73
00:03:21,080 --> 00:03:26,740
这张精美的示意图展示了所有代理及其交互流程

74
00:03:26,740 --> 00:03:30,580
我们逐步解析这个整体结构

75
00:03:30,580 --> 00:03:35,820
这是管理用户整体介绍的代理

76
00:03:35,820 --> 00:03:38,030
代理的责任是什么

77
00:03:38,030 --> 00:03:40,270
并帮助用户理解

78
00:03:40,270 --> 00:03:42,310
这里可能的工作流程是什么

79
00:03:42,310 --> 00:03:43,930
从知识图谱构建

80
00:03:43,930 --> 00:03:45,860
一直到图检索

81
00:03:45,860 --> 00:03:49,520
这实际上是一个不会执行任务的对话代理

82
00:03:49,520 --> 00:03:53,880
但它会引导用户完成各个工作阶段

83
00:03:53,880 --> 00:03:58,630
真正管理具体工作流程的是下一层代理

84
00:03:58,630 --> 00:04:00,610
这里有三个主要工作流

85
00:04:00,610 --> 00:04:01,710
在左侧

86
00:04:01,710 --> 00:04:03,290
我们有两个工作流

87
00:04:03,290 --> 00:04:06,470
结构化数据代理和非结构化数据代理

88
00:04:06,470 --> 00:04:09,950
它们负责引导用户从想法到构建图谱

89
00:04:09,950 --> 00:04:13,070
比如他们可能想要完成的目标到构建图谱

90
00:04:13,070 --> 00:04:15,260
如果这些工作完成

91
00:04:15,260 --> 00:04:16,160
第三个代理

92
00:04:16,160 --> 00:04:18,140
右侧的图RAG代理

93
00:04:18,140 --> 00:04:22,450
负责帮助用户利用该图回答问题

94
00:04:22,450 --> 00:04:27,010
但结构化和非结构化数据代理是工作流代理

95
00:04:27,010 --> 00:04:29,740
它们通过与用户互动完成工作

96
00:04:29,740 --> 00:04:32,300
并协助用户完成所需步骤

97
00:04:32,300 --> 00:04:36,010
从用户目标到描述图谱

98
00:04:36,010 --> 00:04:40,620
它们通过委派专门处理各阶段的子代理来实现

99
00:04:40,620 --> 00:04:42,220
这里会有一些重复

100
00:04:42,220 --> 00:04:46,520
结构化和非结构化数据共享一些共同代理

101
00:04:46,520 --> 00:04:49,669
然后在深入一级时我会提到这些

102
00:04:49,789 --> 00:04:50,189
好的

103
00:04:50,189 --> 00:04:54,030
这些子代理实际上正在处理结构化数据的工作流程

104
00:04:54,030 --> 00:04:55,930
我们逐个分析这些内容

105
00:04:55,930 --> 00:04:57,750
需要特别注意的是

106
00:04:57,750 --> 00:05:01,010
这是这些亚洲团队实际工作的输出结果

107
00:05:01,010 --> 00:05:03,770
如果你把自己想象成数据工程师

108
00:05:03,770 --> 00:05:06,650
被赋予执行这项工作的任务

109
00:05:06,650 --> 00:05:09,390
每个代理都相当于你自己会做的事情

110
00:05:09,390 --> 00:05:11,320
你正在参与这项工作

111
00:05:11,320 --> 00:05:12,240
第一个代理

112
00:05:12,240 --> 00:05:13,560
用户意图代理

113
00:05:13,560 --> 00:05:17,750
当你被要求执行数据分析任务时会做的事

114
00:05:17,750 --> 00:05:21,210
并需要向提问者回应

115
00:05:21,210 --> 00:05:21,670
嘿

116
00:05:21,670 --> 00:05:23,770
你能澄清我需要做什么吗

117
00:05:23,770 --> 00:05:24,550
给我

118
00:05:24,550 --> 00:05:24,970
你知道的

119
00:05:24,970 --> 00:05:26,050
你追求的目标是什么

120
00:05:26,050 --> 00:05:28,300
你希望我进行哪种分析

121
00:05:28,300 --> 00:05:30,440
必须尽早明确这一点

122
00:05:30,440 --> 00:05:34,919
这是任务的整体要求或方向

123
00:05:34,919 --> 00:05:36,559
因此用户意图代理

124
00:05:36,559 --> 00:05:39,730
尽管是协作且对话式的

125
00:05:39,730 --> 00:05:41,410
这个输出非常重要

126
00:05:41,410 --> 00:05:43,210
我们正在捕捉用户的最终目标

127
00:05:43,210 --> 00:05:46,940
基于用户目标，他们希望通过这项工作得到什么

128
00:05:46,940 --> 00:05:50,230
接下来是文件建议代理

129
00:05:50,230 --> 00:05:54,390
将综合用户意图代理确定的方向和目标

130
00:05:54,390 --> 00:05:57,480
作为工作的方向和目标

131
00:05:57,480 --> 00:05:59,660
然后查看可用的数据文件

132
00:05:59,660 --> 00:06:04,350
从这些文件中找出对实现目标有用的

133
00:06:04,350 --> 00:06:05,950
可能还有更多可用文件

134
00:06:05,950 --> 00:06:09,230
甚至可能存在多个数据源

135
00:06:09,230 --> 00:06:13,610
我们简化为仅建议磁盘上的可用文件

136
00:06:13,610 --> 00:06:18,580
输出是用户批准的建议文件列表

137
00:06:18,580 --> 00:06:21,500
然后输入到下一个代理

138
00:06:21,500 --> 00:06:23,820
即模式提案代理

139
00:06:23,820 --> 00:06:28,000
模式提案代理实际上是采用批评模式的双代理组合

140
00:06:28,000 --> 00:06:32,800
其中一个代理负责提出可能的模式方案

141
00:06:32,800 --> 00:06:34,400
下一个代理则作为批评者

142
00:06:34,400 --> 00:06:35,080
比如

143
00:06:35,080 --> 00:06:37,720
或许这样修改不太合适

144
00:06:37,720 --> 00:06:41,080
或者我们可以稍后再讨论细节

145
00:06:41,080 --> 00:06:47,150
核心思想是这些代理会内部循环评估

146
00:06:47,150 --> 00:06:48,390
自我批评

147
00:06:48,390 --> 00:06:50,750
最终产出良好的图模式

148
00:06:50,750 --> 00:06:53,730
使用前代理批准的文件

149
00:06:53,730 --> 00:06:57,310
并符合首个代理设定的用户目标

150
00:06:57,310 --> 00:07:01,570
生成能回答用户问题的图模式

151
00:07:01,570 --> 00:07:05,310
因此，所有这些输出我们称之为图构建计划

152
00:07:05,310 --> 00:07:07,010
它本身并不是一个图

153
00:07:07,010 --> 00:07:10,150
但它是关于如何构建该图的描述

154
00:07:10,150 --> 00:07:11,730
中间的第二个工作流程

155
00:07:11,730 --> 00:07:16,460
该工作流程的前两部分与结构化数据工作流程完全相同

156
00:07:16,460 --> 00:07:18,980
在这里我们处理的是非结构化数据

157
00:07:18,980 --> 00:07:23,750
但仍需首先理解用户引入非结构化数据的意图

158
00:07:23,750 --> 00:07:25,770
这里的数据是markdown文件

159
00:07:25,770 --> 00:07:26,750
然后好吧

160
00:07:26,750 --> 00:07:29,890
如果你理解用户为何要引入某些markdown文件

161
00:07:29,890 --> 00:07:33,130
可以再次识别相关文件

162
00:07:33,130 --> 00:07:37,440
文件建议代理会执行与结构化数据相似的行为

163
00:07:37,440 --> 00:07:40,780
但第三步在此有所不同

164
00:07:40,780 --> 00:07:44,280
不再基于csv文件设计模式

165
00:07:44,280 --> 00:07:46,260
你只有纯文本

166
00:07:46,260 --> 00:07:47,300
从文本中

167
00:07:47,300 --> 00:07:48,560
如何创建一个图

168
00:07:48,560 --> 00:07:49,000
嗯

169
00:07:49,000 --> 00:07:53,319
此处的方法是使用两个专门的代理分析文本

170
00:07:53,319 --> 00:07:55,219
并识别所谓的实体

171
00:07:55,219 --> 00:07:55,859
如人物

172
00:07:55,859 --> 00:07:58,780
文本中出现的地点和事物

173
00:07:58,780 --> 00:08:03,320
同时为这些实体识别描述性事实

174
00:08:03,320 --> 00:08:05,200
文本中关于这些实体的事实

175
00:08:05,200 --> 00:08:07,300
例如文本中提到

176
00:08:07,300 --> 00:08:08,460
我知道我在文本中

177
00:08:08,460 --> 00:08:11,150
我有一些本地咖啡店的评论

178
00:08:11,150 --> 00:08:12,870
可能会发现

179
00:08:12,870 --> 00:08:15,890
阿布克非常喜爱飞利浦咖啡

180
00:08:15,890 --> 00:08:17,510
因为谁不喜欢呢

181
00:08:17,510 --> 00:08:17,990
所以

182
00:08:17,990 --> 00:08:20,380
这些可能是从文本中提取的事实

183
00:08:20,380 --> 00:08:24,400
该代理的目标是确定可提取的事实类型

184
00:08:24,400 --> 00:08:26,020
而不是实际提取

185
00:08:26,020 --> 00:08:28,390
只是描述可能性

186
00:08:28,390 --> 00:08:31,830
因此我们将称之为知识提取计划

187
00:08:31,830 --> 00:08:36,860
知识提取计划与结构化数据的图构建计划结合

188
00:08:36,860 --> 00:08:38,440
提供所需的所有规则

189
00:08:38,440 --> 00:08:41,590
通过图构建计划和知识提取计划

190
00:08:41,590 --> 00:08:43,090
角落的红色方框

191
00:08:43,090 --> 00:08:46,600
只是一个包含多个工具的单一工具

192
00:08:46,600 --> 00:08:51,520
能够执行这些计划并完成提取与构建

193
00:08:51,520 --> 00:08:53,660
遍历所有构建规则

194
00:08:53,660 --> 00:08:55,290
生成领域图

195
00:08:55,290 --> 00:08:57,110
遍历所有markdown文件

196
00:08:57,110 --> 00:08:58,150
进行分块处理

197
00:08:58,150 --> 00:08:59,890
对内容进行向量嵌入

198
00:08:59,890 --> 00:09:02,760
同时提取实体和事实

199
00:09:02,760 --> 00:09:05,890
并将它们连接到结构化数据

200
00:09:05,890 --> 00:09:07,350
在第四至第八课中

201
00:09:07,350 --> 00:09:10,230
你将完整体验结构化数据的工作流程

202
00:09:10,230 --> 00:09:14,480
从用户意图文件建议到模式提案

203
00:09:14,480 --> 00:09:17,300
接下来我们将转向非结构化数据

204
00:09:17,300 --> 00:09:19,980
仅进行实体事实类型提案

205
00:09:19,980 --> 00:09:22,960
最后我们将查看第八课中的特定工具

206
00:09:22,960 --> 00:09:24,700
该工具负责执行图结构构建

207
00:09:24,700 --> 00:09:25,920
它完成了所有繁重工作

208
00:09:25,920 --> 00:09:31,500
之前代理已在此课中完成对后续工作的推理

209
00:09:31,500 --> 00:09:33,320
我们将实际进行编码实践

210
00:09:33,320 --> 00:09:34,300
构建你的第一个代理

211
00:09:34,300 --> 00:09:36,530
我们将使用谷歌的ADK

212
00:09:36,530 --> 00:09:38,610
如果你已熟悉谷歌ADK

213
00:09:38,610 --> 00:09:42,600
可以跳过该课直接构建多代理系统

214
00:09:42,600 --> 00:09:44,560
但我认为这是一个很好的概述

215
00:09:44,560 --> 00:09:46,940
同时帮助你理解我的思考方式

216
00:09:46,940 --> 00:09:50,620
以及我在该多代理系统中的实现方法

217
00:09:50,620 --> 00:09:52,000
因此值得逐步讲解

218
00:09:52,000 --> 00:09:53,420
我们那时见

