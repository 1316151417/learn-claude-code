1
00:00:00,100 --> 00:00:03,220
现在你已经定义了目标并指定了文件

2
00:00:03,220 --> 00:00:07,300
下一步是确定结构化数据的图模型

3
00:00:07,300 --> 00:00:12,010
即确定构成领域图的节点和边的类型

4
00:00:12,010 --> 00:00:15,370
你将设置一个子代理循环来优化模型

5
00:00:15,370 --> 00:00:17,060
让我们深入探讨

6
00:00:17,060 --> 00:00:19,400
你正在使用结构化数据代理

7
00:00:19,400 --> 00:00:22,439
通过从用户意图开始的工作流程

8
00:00:22,439 --> 00:00:23,959
然后是文件建议

9
00:00:23,959 --> 00:00:28,490
现在我们准备好提出图模式的可能方案

10
00:00:28,490 --> 00:00:30,150
这就是这个代理的任务

11
00:00:30,150 --> 00:00:34,879
这个代理在代理组合方式上引入了一些新思路

12
00:00:34,879 --> 00:00:38,290
这个代理实际上包含多个内部代理

13
00:00:38,290 --> 00:00:42,170
其中有一个代理负责提出方案

14
00:00:42,170 --> 00:00:45,180
这里显示我建议构建的图模型

15
00:00:45,180 --> 00:00:48,420
另一个代理会检查并批评该方案

16
00:00:48,420 --> 00:00:52,960
这是一种在多代理系统中常见的批评模式

17
00:00:52,960 --> 00:00:54,700
在顶层协调器中

18
00:00:54,700 --> 00:00:57,340
这里只使用了少数几个工具

19
00:00:57,340 --> 00:01:00,910
有一个我们称为细化循环的工具

20
00:01:00,910 --> 00:01:04,250
还有两个常规工具：获取建议构建计划

21
00:01:04,250 --> 00:01:06,930
以及批准建议构建计划

22
00:01:06,930 --> 00:01:11,780
这些与之前看到的文件建议和批准工具类似

23
00:01:11,780 --> 00:01:14,460
但这个细化循环非常有趣

24
00:01:14,460 --> 00:01:19,180
实际上是一个包含多个协作组件的代理

25
00:01:19,180 --> 00:01:21,020
让我们看看内部结构

26
00:01:21,020 --> 00:01:25,380
细化循环是一个协调子代理的代理

27
00:01:25,380 --> 00:01:28,809
该循环代理包含三个子代理

28
00:01:28,809 --> 00:01:30,369
模式提案代理

29
00:01:30,369 --> 00:01:31,829
模式批评代理

30
00:01:31,829 --> 00:01:34,069
以及状态检查模块

31
00:01:34,069 --> 00:01:35,840
升级代理

32
00:01:35,840 --> 00:01:39,160
这些代理会持续循环运行

33
00:01:39,160 --> 00:01:41,259
直到得到最终结果

34
00:01:41,259 --> 00:01:43,859
模式提案代理生成提案

35
00:01:43,859 --> 00:01:46,200
模式批评代理进行批评

36
00:01:46,200 --> 00:01:51,320
状态检查和升级代理负责分析批评结果

37
00:01:51,320 --> 00:01:53,240
判断批评是否满意

38
00:01:53,240 --> 00:01:54,830
或是否需要重新尝试

39
00:01:54,830 --> 00:01:56,450
如果批评满意

40
00:01:56,450 --> 00:01:59,390
正是这个代理触发最终确认

41
00:01:59,390 --> 00:02:02,300
从而终止循环代理

42
00:02:02,300 --> 00:02:03,440
这个过程可能无限循环

43
00:02:03,440 --> 00:02:05,220
当你调用循环代理时

44
00:02:05,220 --> 00:02:08,870
我们可以设置循环迭代次数限制

45
00:02:08,870 --> 00:02:11,290
若无法达成共识

46
00:02:11,290 --> 00:02:12,910
将返回用户请求

47
00:02:12,910 --> 00:02:13,350
说

48
00:02:13,350 --> 00:02:14,790
我们对此不确定

49
00:02:14,790 --> 00:02:19,750
顶层协调器将负责获取更多用户输入

50
00:02:19,750 --> 00:02:22,260
你将从常规导入开始

51
00:02:22,260 --> 00:02:23,580
当这些准备就绪

52
00:02:23,580 --> 00:02:28,690
你可以定义我们将要使用的llm并查看它

53
00:02:29,250 --> 00:02:30,430
所有准备就绪，太好了

54
00:02:30,430 --> 00:02:32,290
我们现在可以开始工具定义

55
00:02:33,330 --> 00:02:36,400
现在可以开始编写代理的指令

56
00:02:36,400 --> 00:02:39,000
我们将重点研究的代理

57
00:02:39,000 --> 00:02:40,520
或者模式提案代理

58
00:02:40,520 --> 00:02:41,760
然后是批评者

59
00:02:41,760 --> 00:02:44,900
让我们看看我们将提供给它们的指令

60
00:02:45,220 --> 00:02:48,760
对于提案代理在其角色和目标

61
00:02:48,760 --> 00:02:51,100
我们将告诉它擅长图数据建模

62
00:02:51,100 --> 00:02:53,440
使用属性图建模

63
00:02:53,440 --> 00:02:57,020
你可以在这里查看详细描述

64
00:02:57,020 --> 00:02:58,680
但这里的新颖部分

65
00:02:58,680 --> 00:03:02,660
在这段提示中真正关键的是我们将注入

66
00:03:02,660 --> 00:03:06,020
现在反馈初始为空

67
00:03:06,020 --> 00:03:10,790
因此我们告诉代理仅在反馈可用时考虑

68
00:03:10,790 --> 00:03:12,270
但由于可能为空

69
00:03:12,270 --> 00:03:16,380
我们不希望混淆其余提示成为反馈部分

70
00:03:16,380 --> 00:03:18,560
因此我们在此处用xml包裹

71
00:03:18,560 --> 00:03:21,460
使用伪xml表示此处的反馈

72
00:03:21,460 --> 00:03:22,980
然后是反馈结束标记

73
00:03:22,980 --> 00:03:26,880
因为大多数llm能很好地理解这种分隔符

74
00:03:26,880 --> 00:03:28,670
所以我们在此处使用分隔符

75
00:03:28,670 --> 00:03:34,470
这些花括号反馈成为模板变量

76
00:03:34,470 --> 00:03:37,400
由google eighty k google edk注入

77
00:03:37,400 --> 00:03:38,140
在组装时

78
00:03:38,140 --> 00:03:38,760
提示内容

79
00:03:38,760 --> 00:03:43,700
会查找这些文本部分并替换为上下文

80
00:03:44,700 --> 00:03:45,660
一个上下文变量

81
00:03:45,660 --> 00:03:47,660
如果在工具上下文状态

82
00:03:47,660 --> 00:03:51,180
如果状态中定义了反馈变量

83
00:03:51,180 --> 00:03:53,600
该变量的值将被注入此处

84
00:03:53,600 --> 00:03:56,140
如果上下文中有反馈

85
00:03:56,140 --> 00:03:59,300
将传递到此提示部分

86
00:03:59,660 --> 00:04:00,340
好的

87
00:04:00,340 --> 00:04:03,960
你已为目标代理设定了目标和角色

88
00:04:03,960 --> 00:04:07,630
现在我们将提供执行任务的提示

89
00:04:07,630 --> 00:04:11,470
这里的提示比之前更长

90
00:04:11,470 --> 00:04:16,260
原因在于大多数llm包括GPT

91
00:04:16,260 --> 00:04:19,300
在图数据建模方面表现良好

92
00:04:19,300 --> 00:04:21,589
但并非特别擅长

93
00:04:21,589 --> 00:04:24,810
我们将提供额外的思考指导

94
00:04:24,810 --> 00:04:27,230
如何处理可用的数据文件

95
00:04:27,230 --> 00:04:30,150
以及这些数据文件可能呈现的图结构

96
00:04:30,150 --> 00:04:31,790
你可以查看所有指导内容

97
00:04:31,790 --> 00:04:35,650
并注意到我们包含了知识图谱构建的最佳实践

98
00:04:35,650 --> 00:04:38,159
这些最佳实践已编码在提示中

99
00:04:38,159 --> 00:04:43,710
因此所有批准文件列表中的文件都应成为图的一部分

100
00:04:43,710 --> 00:04:46,850
在这些文件中这些是csv文件

101
00:04:46,850 --> 00:04:48,760
通常你会看到唯一的标识符

102
00:04:48,760 --> 00:04:51,400
我们让它去查找这些唯一标识符

103
00:04:51,400 --> 00:04:54,120
尝试识别这些标识符是什么

104
00:04:54,120 --> 00:04:59,660
并利用它们来理解该文件在构建图中的作用

105
00:04:59,660 --> 00:05:01,460
然后我们提供一些指导

106
00:05:01,460 --> 00:05:07,100
基本是一些设计规则，用于思考某个文件是否可能代表节点

107
00:05:07,100 --> 00:05:08,800
或可能代表关系

108
00:05:08,800 --> 00:05:10,620
你可以查看具体细节

109
00:05:10,620 --> 00:05:14,620
但文件本身的命名通常包含语义提示

110
00:05:14,620 --> 00:05:16,850
出现的标识符数量

111
00:05:16,850 --> 00:05:19,630
这些标识符是否真正唯一属于该文件

112
00:05:19,630 --> 00:05:21,950
或是否唯一属于其他文件

113
00:05:21,950 --> 00:05:25,070
所有这些都需要我们或我来做

114
00:05:25,070 --> 00:05:27,050
当我们作为数据工程师工作时

115
00:05:27,050 --> 00:05:29,140
当我们收到一堆数据文件时

116
00:05:29,140 --> 00:05:31,560
我们基本上用grep和cat处理

117
00:05:31,560 --> 00:05:34,400
也许我们会将其导入编辑器查看文件

118
00:05:34,400 --> 00:05:37,110
这就是我们现在要做的

119
00:05:37,110 --> 00:05:39,310
这些内容在提示中明确表述

120
00:05:39,310 --> 00:05:43,410
帮助代理理解如何进行相同的数据建模

121
00:05:43,410 --> 00:05:46,060
这是我们已知的，将其分解

122
00:05:46,060 --> 00:05:48,680
是节点还是关系特定

123
00:05:48,680 --> 00:05:49,220
你知道的

124
00:05:49,220 --> 00:05:50,640
节点的设计规则

125
00:05:50,640 --> 00:05:52,920
节点通常有单个标识符

126
00:05:52,920 --> 00:05:54,180
而非多个标识符

127
00:05:54,180 --> 00:05:56,910
但如果文件包含多个标识符

128
00:05:56,910 --> 00:06:00,039
X光标识符可能是引用关系

129
00:06:00,039 --> 00:06:02,779
这在关系数据库中会发生

130
00:06:02,779 --> 00:06:05,519
图中可能会有外键关系

131
00:06:05,519 --> 00:06:07,770
这些将转化为关系

132
00:06:07,930 --> 00:06:09,800
如果关系本身

133
00:06:09,800 --> 00:06:11,860
它们有两种表现方式

134
00:06:11,860 --> 00:06:13,360
这里我们称之为

135
00:06:13,360 --> 00:06:17,169
完整关系和引用关系

136
00:06:17,169 --> 00:06:18,989
然后进一步分解

137
00:06:18,989 --> 00:06:21,069
我们向LLM描述

138
00:06:21,069 --> 00:06:22,929
什么是完整关系

139
00:06:22,929 --> 00:06:25,780
什么是引用关系

140
00:06:25,780 --> 00:06:27,020
这里有两个组成部分

141
00:06:27,020 --> 00:06:29,580
我们解释如何识别它们

142
00:06:29,580 --> 00:06:31,660
但在识别后

143
00:06:31,660 --> 00:06:34,150
如何将它们转化为图

144
00:06:34,310 --> 00:06:37,450
最后在提供所有设计指导后

145
00:06:37,450 --> 00:06:42,060
建议生成的模式应为完整连接的图

146
00:06:42,060 --> 00:06:46,810
这很重要，因为显然可能导入大量数据

147
00:06:46,810 --> 00:06:48,150
却无法连接

148
00:06:48,150 --> 00:06:49,670
就不是真正的图

149
00:06:49,670 --> 00:06:51,310
此时几乎无用

150
00:06:51,310 --> 00:06:53,290
因此必须完全连接

151
00:06:53,290 --> 00:06:54,930
如果存在任何孤立组件

152
00:06:54,930 --> 00:06:58,460
这很可能是一个问题，需要考虑

153
00:06:58,540 --> 00:07:01,420
然后可以给代理一些思维链指导方向

154
00:07:01,420 --> 00:07:04,420
这也是比之前更复杂的步骤

155
00:07:04,420 --> 00:07:06,860
可以逐步查看这个过程

156
00:07:06,860 --> 00:07:10,820
首先让代理为即将进行的任务做准备

157
00:07:10,820 --> 00:07:16,480
我们知道该任务基于已建立的用户目标和批准文件列表

158
00:07:16,480 --> 00:07:21,240
同时还要检查是否有批准的施工计划或现行施工计划

159
00:07:21,240 --> 00:07:22,920
即使提出这个建议

160
00:07:22,920 --> 00:07:27,960
这可能不是该代理首次提出施工计划

161
00:07:27,960 --> 00:07:29,360
如果已有现有计划

162
00:07:29,360 --> 00:07:32,420
可以获取当前施工计划

163
00:07:32,420 --> 00:07:35,539
并决定是否需要修改

164
00:07:35,539 --> 00:07:38,379
思维链过程与常规相同

165
00:07:38,379 --> 00:07:43,019
鼓励其仔细思考，分步使用可用工具

166
00:07:43,019 --> 00:07:46,830
对于任何操作需逐个检查批准文件

167
00:07:46,830 --> 00:07:49,050
判断是否为节点或关系

168
00:07:49,050 --> 00:07:51,669
这呼应了我们之前的架构指导

169
00:07:51,669 --> 00:07:54,149
每次发现标识符时

170
00:07:54,149 --> 00:07:56,609
或认为发现了标识符时

171
00:07:56,609 --> 00:08:01,040
应使用工具验证是否找到唯一标识符

172
00:08:01,040 --> 00:08:02,420
使用名为搜索文件工具

173
00:08:02,420 --> 00:08:05,190
这相当于基于Python的grep工具

174
00:08:05,190 --> 00:08:07,330
对于刚发现的标识符

175
00:08:07,330 --> 00:08:09,470
可尝试验证其是否唯一

176
00:08:09,470 --> 00:08:14,020
通过检查同一文件中的重复出现

177
00:08:14,369 --> 00:08:17,889
我们鼓励其考虑我们之前提供的指导

178
00:08:17,889 --> 00:08:21,210
以判断是否为节点或关系

179
00:08:21,210 --> 00:08:22,790
对于节点文件

180
00:08:22,790 --> 00:08:27,550
有专门工具用于提出如何处理该节点文件

181
00:08:27,550 --> 00:08:28,970
我们称之为施工操作

182
00:08:28,970 --> 00:08:33,000
有特殊工具可记录特定文件的处理方式

183
00:08:33,000 --> 00:08:37,289
如何将该文件转化为图中的节点

184
00:08:37,289 --> 00:08:40,229
同样如果认为发现关系

185
00:08:40,229 --> 00:08:44,610
可调用名为提议关系构建工具

186
00:08:44,610 --> 00:08:47,610
用于提议关系构建

187
00:08:47,610 --> 00:08:49,349
使用这两个工具

188
00:08:49,349 --> 00:08:50,889
将遍历所有文件

189
00:08:50,889 --> 00:08:52,749
无论是节点还是关系

190
00:08:52,749 --> 00:08:55,709
调用相应工具生成构建规则

191
00:08:55,709 --> 00:08:58,210
将文件转化为图的一部分

192
00:08:58,210 --> 00:09:01,290
如有必要还可移除构建规则

193
00:09:02,330 --> 00:09:03,490
完成后

194
00:09:03,490 --> 00:09:08,270
使用获取提议施工计划工具向用户展示最终方案

195
00:09:08,270 --> 00:09:15,190
获取提议施工计划工具将包含所有构建规则的完整列表

196
00:09:15,470 --> 00:09:19,870
可将所有内容整合为最终指令

197
00:09:25,500 --> 00:09:27,420
现在可以开始定义工具

198
00:09:28,420 --> 00:09:31,240
我们已在之前的笔记本中定义了许多常用工具

199
00:09:31,240 --> 00:09:35,889
因此直接导入这些工具，如获取批准用户目标、批准文件等

200
00:09:35,889 --> 00:09:37,889
以及示例文件工具

201
00:09:38,969 --> 00:09:42,640
代理的指令还提到了一个搜索文件工具

202
00:09:42,640 --> 00:09:47,380
这个搜索文件工具本质上是一个类似grep的功能，可以读取文件

203
00:09:47,380 --> 00:09:51,020
浏览文件的几行内容并查找特定模式

204
00:09:51,020 --> 00:09:52,540
这不是一个非常复杂的查询

205
00:09:52,540 --> 00:09:53,430
就像grep的工作方式

206
00:09:53,430 --> 00:09:56,750
但足以让LLM实际查找可能出现的内容

207
00:09:56,750 --> 00:09:57,330
例如

208
00:09:57,330 --> 00:09:59,490
用于唯一标识符

209
00:09:59,490 --> 00:10:01,620
可以将这个常量传入此处

210
00:10:01,620 --> 00:10:04,369
然后在文件中查找该常量是否存在

211
00:10:04,369 --> 00:10:10,809
该工具的结果将包含行数以及包含该内容的行

212
00:10:13,760 --> 00:10:17,750
接下来要定义的工具是提议的节点构建

213
00:10:17,750 --> 00:10:21,390
现在这描述了如何从源数据文件

214
00:10:21,390 --> 00:10:23,150
所以我们传入一个改进后的文件

215
00:10:23,150 --> 00:10:24,500
文件路径

216
00:10:24,500 --> 00:10:26,120
然后基于该文件路径

217
00:10:26,120 --> 00:10:28,340
我们需要在图中创建一个节点

218
00:10:29,340 --> 00:10:32,619
我们描述节点应具备的特征

219
00:10:32,899 --> 00:10:35,699
通过几个不同方面来描述节点

220
00:10:35,699 --> 00:10:38,059
首先是应应用的标签是什么

221
00:10:38,059 --> 00:10:43,010
节点标签通常用于描述节点类型，如是否为人物

222
00:10:43,010 --> 00:10:43,470
地点

223
00:10:43,470 --> 00:10:47,130
或事物，描述节点代表的类型

224
00:10:47,130 --> 00:10:50,750
此外还需确定唯一列名称

225
00:10:50,750 --> 00:10:52,970
因此在导入的CSV文件中

226
00:10:52,970 --> 00:10:55,110
某一列应为唯一列

227
00:10:55,110 --> 00:10:57,880
如果我们识别出该列并传入此处

228
00:10:57,880 --> 00:11:03,740
最后可能不会接受所有列作为有效构建节点的属性

229
00:11:03,740 --> 00:11:07,620
提议的属性实际描述了CSV文件

230
00:11:07,620 --> 00:11:12,980
哪些列需要导入并作为节点属性创建

231
00:11:13,510 --> 00:11:16,870
查看该函数的实际实现非常直接

232
00:11:16,870 --> 00:11:19,380
会进行常规的合理性检查

233
00:11:19,380 --> 00:11:21,480
如果我们通过了合理性检查

234
00:11:21,480 --> 00:11:27,700
接下来将描述或构建构造规则

235
00:11:27,700 --> 00:11:32,580
这实际上是一个描述数据对象的工厂函数

236
00:11:32,580 --> 00:11:37,870
此处的数据对象是一个构造规则，类型为节点

237
00:11:37,870 --> 00:11:41,120
基于已传入的源文件生成

238
00:11:41,120 --> 00:11:42,460
赋予一个标签

239
00:11:42,460 --> 00:11:44,040
具有唯一列名称

240
00:11:44,040 --> 00:11:47,550
并创建一组属性

241
00:11:47,550 --> 00:11:51,660
将其添加到现有构造规则列表中

242
00:11:51,660 --> 00:11:52,620
为明确说明

243
00:11:52,620 --> 00:11:57,400
我们之前已从内存中获取当前构造计划

244
00:11:57,400 --> 00:11:58,780
如果不存在

245
00:11:58,780 --> 00:12:01,250
这将是一个空字典

246
00:12:01,250 --> 00:12:04,010
但若存在时添加

247
00:12:04,010 --> 00:12:05,890
我们将使用标签进行添加

248
00:12:05,890 --> 00:12:07,640
因为所有标签应唯一

249
00:12:07,640 --> 00:12:09,120
使用标签作为键

250
00:12:09,120 --> 00:12:11,200
我们将添加该构造规则

251
00:12:11,200 --> 00:12:15,210
因此，整体构建计划将是一组唯一键

252
00:12:15,210 --> 00:12:19,230
其中每个键都是一条规则，要么是节点构建，要么是关系构建

253
00:12:19,230 --> 00:12:21,370
包含所需信息

254
00:12:21,829 --> 00:12:27,370
现在你可以定义一个用于创建关系构建规则的类似工具

255
00:12:27,370 --> 00:12:30,150
如果你查看传入的参数

256
00:12:30,150 --> 00:12:33,350
这些参数与节点类似，是关系特有的

257
00:12:33,350 --> 00:12:38,550
它以文件名开头，表示关系将从中提取的位置

258
00:12:38,550 --> 00:12:39,510
而不是使用标签

259
00:12:39,510 --> 00:12:40,540
它们使用类型

260
00:12:40,540 --> 00:12:43,420
将传入建议的关系类型

261
00:12:43,420 --> 00:12:46,730
由于关系连接其他节点

262
00:12:46,730 --> 00:12:51,130
你需要知道该关系可能来自的节点标签是什么

263
00:12:51,130 --> 00:12:52,930
以及它连接到什么

264
00:12:52,930 --> 00:12:57,410
因此你会得到来源节点和目标节点的标签

265
00:12:57,410 --> 00:12:59,830
然后对于来源节点和目标节点

266
00:12:59,830 --> 00:13:01,890
你也需要知道其唯一标识

267
00:13:01,890 --> 00:13:07,700
在用于创建关系构建的CSV文件中

268
00:13:07,700 --> 00:13:10,910
应有一个列标识来源节点

269
00:13:10,910 --> 00:13:13,090
该节点的唯一标识是什么

270
00:13:13,090 --> 00:13:14,270
来源节点列

271
00:13:14,270 --> 00:13:15,890
还有一个目标节点列

272
00:13:15,890 --> 00:13:18,389
应包含节点的唯一标识

273
00:13:18,389 --> 00:13:21,749
关系连接的目标节点及其相关信息

274
00:13:21,749 --> 00:13:27,230
然后你可以像节点实现一样构建关系

275
00:13:27,230 --> 00:13:29,910
如果来源和目标节点都存在

276
00:13:29,910 --> 00:13:32,770
那么我们可以继续创建构建规则本身

277
00:13:32,770 --> 00:13:35,760
该构建将再次是一个字典

278
00:13:35,760 --> 00:13:38,480
字典类型表明它是关系

279
00:13:38,480 --> 00:13:40,760
因此这是一个关系构建规则

280
00:13:40,760 --> 00:13:45,030
它包含源文件、关系类型、来源节点、目标节点

281
00:13:45,030 --> 00:13:48,800
以及可能应用于关系本身的属性集合

282
00:13:48,800 --> 00:13:52,180
所有内容也添加到关系构建计划中

283
00:13:52,180 --> 00:13:54,300
根据关系类型

284
00:13:54,300 --> 00:13:55,620
如同节点标签

285
00:13:55,620 --> 00:13:59,690
在数据导入过程中，我们期望关系类型唯一

286
00:13:59,690 --> 00:14:03,290
因为该代理将在精炼循环中运行

287
00:14:03,290 --> 00:14:08,500
可能需要移除之前创建的构建规则

288
00:14:08,500 --> 00:14:10,540
因此我们将提供移除工具

289
00:14:10,540 --> 00:14:13,820
适用于节点构建和关系构建

290
00:14:13,820 --> 00:14:16,430
这是节点版本

291
00:14:16,710 --> 00:14:20,690
你也可以定义移除关系构建的类似工具

292
00:14:20,690 --> 00:14:22,910
基于关系类型

293
00:14:22,910 --> 00:14:25,050
而非节点标签

294
00:14:25,170 --> 00:14:29,370
代理与这些工具交互以提议构建规则的结果

295
00:14:29,370 --> 00:14:31,319
然后移除这些构建规则

296
00:14:31,319 --> 00:14:36,259
形成完整的构建计划，将CSV数据文件转换为知识图谱

297
00:14:36,259 --> 00:14:38,319
因此，通过让LM了解其构建的整体计划

298
00:14:38,319 --> 00:14:42,659
我们将创建知识图谱

299
00:14:42,659 --> 00:14:44,479
我们也为此提供工具

300
00:14:44,479 --> 00:14:46,920
获取提议的构建计划工具

301
00:14:46,920 --> 00:14:50,560
我们将从这里获取当前的施工计划

302
00:14:50,560 --> 00:14:52,600
它将继续使用之前使用的同一密钥

303
00:14:52,600 --> 00:14:54,420
用于之前施工计划的构建

304
00:14:54,420 --> 00:14:58,020
如果没有进行任何操作，默认值为空

305
00:14:58,020 --> 00:15:00,220
但当前的施工计划可能已经

306
00:15:00,220 --> 00:15:01,980
没有计划

307
00:15:03,010 --> 00:15:04,170
就像你之前做的那样

308
00:15:04,170 --> 00:15:08,600
结合用户意图和文件建议生成架构提案

309
00:15:08,600 --> 00:15:15,329
你还有一个专门处理基于施工计划提出的或建议的架构方案的工具

310
00:15:15,329 --> 00:15:16,489
然后批准该方案

311
00:15:19,209 --> 00:15:21,420
然后将所有这些工具添加到列表中

312
00:15:21,420 --> 00:15:22,720
这就是你要使用的列表

313
00:15:22,720 --> 00:15:26,200
在定义实际提供所有工具的代理时使用

314
00:15:26,200 --> 00:15:30,650
你可以看到工具集合随着时间推移在这里逐渐增加

315
00:15:30,650 --> 00:15:34,230
因为它结合了我们之前达成的共识

316
00:15:34,230 --> 00:15:36,250
在工作流程的前期阶段

317
00:15:36,250 --> 00:15:40,750
与当前代理在当前工作阶段的任务相结合

318
00:15:40,750 --> 00:15:41,410
其意图

319
00:15:41,410 --> 00:15:41,870
当然

320
00:15:41,870 --> 00:15:43,830
是创建图结构模式

321
00:15:45,030 --> 00:15:47,110
你现在可以定义代理本身

322
00:15:47,110 --> 00:15:49,510
负责执行架构提案

323
00:15:49,940 --> 00:15:53,100
你将在此处添加一个新的实用函数

324
00:15:53,100 --> 00:15:54,300
在创建代理时使用

325
00:15:55,340 --> 00:15:58,620
该实用函数仅记录代理被调用的情况

326
00:15:58,620 --> 00:16:03,000
并打印代理名称到屏幕

327
00:16:03,000 --> 00:16:06,200
这里处理当前对话的内容

328
00:16:06,200 --> 00:16:09,920
稍后创建代理时你会看到添加位置

329
00:16:10,880 --> 00:16:13,320
现在可以定义架构提案代理

330
00:16:13,320 --> 00:16:14,240
如果你直接说

331
00:16:14,240 --> 00:16:15,089
代理在这里

332
00:16:15,089 --> 00:16:17,129
这是一个语言模型代理

333
00:16:17,129 --> 00:16:18,509
即推理代理

334
00:16:18,509 --> 00:16:22,840
能够基于现有工具做出决策

335
00:16:22,840 --> 00:16:25,180
和之前一样，我们需要为其命名

336
00:16:25,180 --> 00:16:26,200
为其添加描述

337
00:16:26,200 --> 00:16:28,339
我们将传入指令

338
00:16:28,339 --> 00:16:33,639
但这次调用的独特之处在于代理实际被调用前

339
00:16:33,639 --> 00:16:34,939
有一个回调函数

340
00:16:34,939 --> 00:16:36,090
在调用前

341
00:16:36,090 --> 00:16:40,870
并希望回调指向我们刚刚定义的日志代理函数

342
00:16:40,870 --> 00:16:42,910
这将让我们看到

343
00:16:42,910 --> 00:16:47,470
当代理被调用时的下一步操作

344
00:16:47,470 --> 00:16:51,210
你需要继续使用我们的老朋友

345
00:16:51,210 --> 00:16:53,130
创建代理调用器

346
00:16:53,370 --> 00:16:56,430
如同工作流程的前期部分

347
00:16:56,430 --> 00:16:59,070
需要设置代理的初始状态

348
00:16:59,070 --> 00:17:02,120
如同前期工作流程已完成

349
00:17:02,120 --> 00:17:04,319
因此需要获取已批准的用户目标

350
00:17:04,319 --> 00:17:06,040
还需要获取已批准的文件

351
00:17:06,040 --> 00:17:09,760
因为这个代理将在反馈循环中运行

352
00:17:09,760 --> 00:17:11,359
我们将初始化反馈机制

353
00:17:11,359 --> 00:17:12,848
同时保持为空白

354
00:17:12,848 --> 00:17:16,359
这能让代理顺利运行而无任何问题

355
00:17:16,520 --> 00:17:18,180
现在可以调用这个代理

356
00:17:18,180 --> 00:17:24,569
通过用户消息提示如何将这些文件导入构建知识图谱

357
00:17:24,569 --> 00:17:25,930
我们将查看会话内容

358
00:17:25,930 --> 00:17:27,890
完成后打印会话状态

359
00:17:29,210 --> 00:17:32,170
预期看到提出的构建计划

360
00:17:32,640 --> 00:17:34,080
这里已经给出

361
00:17:34,080 --> 00:17:35,880
最终结果再次呈现

362
00:17:35,880 --> 00:17:38,460
我们获得了最终状态为真的事件

363
00:17:38,460 --> 00:17:39,860
让我们看看

364
00:17:39,860 --> 00:17:43,719
它决定创建组装相关的节点

365
00:17:43,719 --> 00:17:44,599
基于组装数据

366
00:17:44,599 --> 00:17:44,959
Csv文件

367
00:17:44,959 --> 00:17:47,319
为零件创建节点

368
00:17:47,319 --> 00:17:48,539
为产品创建节点

369
00:17:48,539 --> 00:17:50,190
为供应商创建节点

370
00:17:50,190 --> 00:17:51,150
非常直接

371
00:17:51,150 --> 00:17:52,930
它在这方面做得很好

372
00:17:52,930 --> 00:17:55,510
现在它开始建立关系

373
00:17:55,510 --> 00:17:57,430
让我们看看它的决策

374
00:17:57,430 --> 00:17:59,670
它认为从组装

375
00:17:59,670 --> 00:18:03,420
Csv文件中存在从组装到产品的关联

376
00:18:03,420 --> 00:18:07,100
可以说明组装包含在某个产品中

377
00:18:07,100 --> 00:18:10,460
将创建从组装到产品的关联

378
00:18:10,460 --> 00:18:11,820
两个产品

379
00:18:11,820 --> 00:18:14,540
并称这些关系为'包含'

380
00:18:14,540 --> 00:18:17,060
属性将包括组装名称

381
00:18:17,060 --> 00:18:18,740
以及数量

382
00:18:18,740 --> 00:18:21,080
当前处理的产品是家具

383
00:18:21,080 --> 00:18:22,600
例如桌腿

384
00:18:22,600 --> 00:18:24,380
这可能是一个组装组件

385
00:18:24,380 --> 00:18:25,400
可能存在四个这样的组件

386
00:18:25,400 --> 00:18:27,730
这样数量看起来合理

387
00:18:28,810 --> 00:18:30,990
它对零件也做了类似决策

388
00:18:30,990 --> 00:18:34,520
零件Csv似乎指向组装

389
00:18:34,520 --> 00:18:38,160
因此零件属于某个组装

390
00:18:38,160 --> 00:18:41,320
包含零件名称和合理数量

391
00:18:41,320 --> 00:18:45,040
还完成了供应商映射

392
00:18:45,040 --> 00:18:46,860
现在注意这些关系

393
00:18:46,860 --> 00:18:49,700
这里有两种不同类型的关系

394
00:18:49,700 --> 00:18:54,530
前两个是定义节点的源文件

395
00:18:54,530 --> 00:18:57,070
但由于节点存在外键关联

396
00:18:57,070 --> 00:19:00,410
得益于我们的精准提示

397
00:19:00,410 --> 00:19:02,210
然后它决定一切顺利

398
00:19:02,210 --> 00:19:04,810
我将定义创建关系的规则

399
00:19:04,810 --> 00:19:08,030
其中'supplied by'稍有不同

400
00:19:08,030 --> 00:19:11,990
因为零件供应商映射Csv只是简单映射

401
00:19:11,990 --> 00:19:14,270
从零件到供应商

402
00:19:14,270 --> 00:19:17,620
这就像关系型数据库中的联合表

403
00:19:17,620 --> 00:19:20,560
零件表和供应商表

404
00:19:20,560 --> 00:19:25,990
而这里的零件供应商是连接这两张表的关联表，形成关系

405
00:19:25,990 --> 00:19:27,350
而不是关联表

406
00:19:27,350 --> 00:19:28,910
这非常完美

407
00:19:29,370 --> 00:19:31,990
它还解释了所有这些内容

408
00:19:31,990 --> 00:19:33,770
并且显得非常满意

409
00:19:33,770 --> 00:19:35,080
所以这很好

410
00:19:35,080 --> 00:19:36,720
会话状态相当复杂

411
00:19:36,720 --> 00:19:37,680
你可以查看其中内容

412
00:19:37,680 --> 00:19:39,560
如果你想查看所有细节

413
00:19:39,560 --> 00:19:44,800
但代理生成的markdown输出已很好地表达了这些信息

414
00:19:45,750 --> 00:19:46,550
好的

415
00:19:46,550 --> 00:19:50,870
一个提出模式的代理已完成

416
00:19:51,510 --> 00:19:53,310
现在我们将转向批评者

417
00:19:53,310 --> 00:19:55,830
这是优化循环的第二部分

418
00:19:55,830 --> 00:19:58,710
模式批评者与提案代理类似

419
00:19:58,710 --> 00:20:01,510
作为知识图谱建模专家

420
00:20:01,510 --> 00:20:03,530
但它的任务不是创建模型

421
00:20:03,530 --> 00:20:05,910
而是批评已创建的模型

422
00:20:05,910 --> 00:20:08,850
因此批评者有特殊角色和目标

423
00:20:08,850 --> 00:20:10,890
当然它就是个批评者

424
00:20:10,890 --> 00:20:12,370
我们将定义其角色为

425
00:20:12,370 --> 00:20:15,770
同样精通属性图知识图谱建模

426
00:20:15,770 --> 00:20:18,050
就像提案代理一样

427
00:20:18,050 --> 00:20:23,070
但它的任务是批评已提出的方案

428
00:20:23,070 --> 00:20:27,290
因此这是它的目标：批评提议的模式

429
00:20:27,290 --> 00:20:31,710
确保其与用户目标及可用文件相关

430
00:20:32,329 --> 00:20:35,869
还会为该代理提供执行任务的提示

431
00:20:35,869 --> 00:20:38,469
在批评提议的模式时

432
00:20:38,469 --> 00:20:40,630
需要检查哪些内容

433
00:20:40,630 --> 00:20:42,950
这实际上是关于

434
00:20:42,950 --> 00:20:45,460
如何进行良好的知识图谱建模

435
00:20:45,460 --> 00:20:47,920
但现在从批评他人模型的角度

436
00:20:47,920 --> 00:20:49,780
如果你要批评他人的模型

437
00:20:49,780 --> 00:20:50,840
会提出哪些意见

438
00:20:50,840 --> 00:20:52,370
需要关注哪些方面

439
00:20:52,370 --> 00:20:54,960
唯一标识符是否真正唯一

440
00:20:54,960 --> 00:20:58,100
可以使用搜索工具验证这一点

441
00:20:58,100 --> 00:21:01,240
已定义的节点是否可能为关系

442
00:21:01,240 --> 00:21:03,650
需再次确认这一点

443
00:21:03,650 --> 00:21:05,710
如果这是一个连通图

444
00:21:05,710 --> 00:21:10,200
应能手动从源数据追溯到构建的图

445
00:21:10,200 --> 00:21:13,820
确保所有源CSV文件都映射到图中

446
00:21:13,820 --> 00:21:16,179
并保证图本身完全连通

447
00:21:16,179 --> 00:21:17,419
还有一些其他提示

448
00:21:17,419 --> 00:21:20,720
当然还包括层级容器关系是否存在

449
00:21:20,720 --> 00:21:23,360
是否存在冗余关系

450
00:21:23,360 --> 00:21:29,190
方案提案可能过于激进，创建了不必要的关系

451
00:21:29,190 --> 00:21:32,550
或者那些在实际实现结果时逻辑上必需的部分

452
00:21:32,550 --> 00:21:34,870
这也需要检查一下

453
00:21:35,860 --> 00:21:38,880
提示的下一部分是思维链方向

454
00:21:38,880 --> 00:21:42,440
和之前一样，我们要向批评者解释如何准备任务

455
00:21:42,440 --> 00:21:43,100
它拥有

456
00:21:43,100 --> 00:21:46,670
它使用哪些工具来实际准备执行任务

457
00:21:46,670 --> 00:21:48,610
然后应该如何执行任务

458
00:21:48,610 --> 00:21:50,230
一如既往，它应该仔细思考

459
00:21:50,230 --> 00:21:52,800
并使用工具执行操作

460
00:21:52,800 --> 00:21:56,140
首先你应该检查每个构造规则

461
00:21:56,140 --> 00:21:59,500
包括节点构造规则和关系构造规则

462
00:21:59,500 --> 00:22:04,540
然后使用工具验证构造规则是否相关且正确

463
00:22:04,540 --> 00:22:07,620
如果所有检查都通过且一切正常

464
00:22:07,620 --> 00:22:11,050
只需回复单个词valid

465
00:22:11,050 --> 00:22:13,090
如果架构存在任何问题

466
00:22:13,090 --> 00:22:16,570
回复retry并提供反馈

467
00:22:16,570 --> 00:22:20,360
这里的反馈要求简洁的项目符号列表

468
00:22:20,360 --> 00:22:23,580
如果批评者对提案有任何疑虑

469
00:22:23,580 --> 00:22:24,960
我们应该看到这个清晰的项目符号列表

470
00:22:24,960 --> 00:22:27,310
说明需要做出哪些修改

471
00:22:27,310 --> 00:22:30,460
这些反馈将最终进入循环

472
00:22:30,460 --> 00:22:34,020
并返回给提案代理以调整其操作

473
00:22:34,020 --> 00:22:37,060
并尝试考虑任何反馈意见

474
00:22:38,040 --> 00:22:41,800
接下来可以将所有提示部分合并为单一提示

475
00:22:41,800 --> 00:22:42,940
这就是批评者代理

476
00:22:42,940 --> 00:22:46,480
稍后我们将用此定义代理的指令

477
00:22:48,440 --> 00:22:51,020
现在架构批评者也需要工具

478
00:22:51,020 --> 00:22:53,960
但架构批评者没有新工具

479
00:22:53,960 --> 00:22:56,990
它可以使用提案代理相同的工具

480
00:22:56,990 --> 00:22:59,330
我们只需将其包含在此列表中

481
00:22:59,330 --> 00:23:00,910
获取已批准的用户目标

482
00:23:00,910 --> 00:23:01,950
已批准的文件

483
00:23:01,950 --> 00:23:06,190
然后是采样文件或搜索文件等实用工具

484
00:23:08,120 --> 00:23:10,640
你已具备批评者代理所需的所有组件

485
00:23:10,640 --> 00:23:12,440
现在可以创建该代理

486
00:23:12,440 --> 00:23:14,280
它将是一个LLM代理

487
00:23:14,280 --> 00:23:16,380
其名称为架构批评者代理

488
00:23:16,380 --> 00:23:17,070
版本一

489
00:23:17,350 --> 00:23:21,670
这个代理有一个之前未见过的新特性

490
00:23:21,670 --> 00:23:23,950
与其他只需完成工作的代理不同

491
00:23:23,950 --> 00:23:25,090
然后使用工具进行

492
00:23:25,090 --> 00:23:25,470
你知道的

493
00:23:25,470 --> 00:23:26,810
产生某些输出

494
00:23:26,810 --> 00:23:30,450
这个代理只需返回文本

495
00:23:30,450 --> 00:23:35,170
该文本将通过此输出键存入状态

496
00:23:35,170 --> 00:23:40,050
因此此输出键我们称为反馈

497
00:23:40,050 --> 00:23:42,560
当此代理完成时

498
00:23:42,560 --> 00:23:47,380
当收到此代理的最终消息时

499
00:23:47,380 --> 00:23:49,980
最终消息将使用反馈键存入状态

500
00:23:49,980 --> 00:23:52,920
将包含由批评者生成的值

501
00:23:52,920 --> 00:23:54,700
因为这会在之后出现

502
00:23:54,700 --> 00:23:56,909
如果你回到提案者那里

503
00:23:56,909 --> 00:24:00,869
提案将能够从状态中获取该信息

504
00:24:01,650 --> 00:24:03,690
你需要定义两个关键组件

505
00:24:03,690 --> 00:24:07,330
这是此细化循环中的两个关键子代理

506
00:24:07,330 --> 00:24:10,000
现在我们必须定义细化循环本身

507
00:24:10,000 --> 00:24:11,360
在我们这样做之前

508
00:24:11,360 --> 00:24:12,600
还会有最后一个代理

509
00:24:12,600 --> 00:24:14,890
这将是我们自定义的代理

510
00:24:14,890 --> 00:24:16,990
如果我们回到架构图

511
00:24:16,990 --> 00:24:18,350
我们有提案代理

512
00:24:18,350 --> 00:24:19,450
批评代理

513
00:24:19,450 --> 00:24:23,080
现在我们要添加这个检查状态和升级代理

514
00:24:23,080 --> 00:24:24,700
这个代理只有一个任务

515
00:24:24,700 --> 00:24:28,070
它的任务是决定循环是否完成

516
00:24:28,430 --> 00:24:30,470
让我们看看它是如何工作的

517
00:24:30,470 --> 00:24:34,650
这是一个名为base agent的基础类，我们将继承它

518
00:24:34,650 --> 00:24:37,800
我们将其命名为检查状态和升级类

519
00:24:37,800 --> 00:24:41,940
这将是一个自定义代理，带有自定义运行函数

520
00:24:41,940 --> 00:24:43,860
运行函数将被调用

521
00:24:43,860 --> 00:24:46,900
它会获取被调用时的当前上下文

522
00:24:46,900 --> 00:24:49,420
我们不必过多关注这一点

523
00:24:49,420 --> 00:24:51,760
除了查看当前会话状态

524
00:24:51,760 --> 00:24:54,440
因此从该上下文中查找当前会话

525
00:24:54,440 --> 00:24:55,460
查看状态

526
00:24:55,460 --> 00:24:57,240
并获取反馈

527
00:24:57,240 --> 00:24:58,810
如果有任何反馈

528
00:24:58,810 --> 00:25:01,590
如果没有则假设反馈有效

529
00:25:01,590 --> 00:25:03,550
如果批评代理没有反馈

530
00:25:03,550 --> 00:25:05,139
我们将假设其有效

531
00:25:05,139 --> 00:25:07,239
或者代理已声明有效

532
00:25:07,239 --> 00:25:11,139
结果将是反馈有效，因此应停止

533
00:25:11,139 --> 00:25:12,699
标志将根据

534
00:25:12,699 --> 00:25:15,709
反馈是否包含有效内容

535
00:25:15,709 --> 00:25:16,789
这是一个非常简单的检查

536
00:25:16,789 --> 00:25:18,409
我们可以对此更复杂

537
00:25:18,409 --> 00:25:19,169
但这样已经可行

538
00:25:19,169 --> 00:25:21,100
对于大多数代理来说已经足够

539
00:25:21,100 --> 00:25:22,580
如果所有条件成立

540
00:25:22,580 --> 00:25:24,900
我们将生成一个由

541
00:25:24,900 --> 00:25:27,590
当然这是我们构建的特殊代理

542
00:25:27,590 --> 00:25:29,930
它将执行一个非常具体的操作

543
00:25:29,930 --> 00:25:33,230
我们将在事件中添加一个名为升级的动作

544
00:25:33,230 --> 00:25:36,280
升级的值将基于

545
00:25:36,280 --> 00:25:37,160
是否应停止

546
00:25:37,160 --> 00:25:38,830
所以应停止为真

547
00:25:38,830 --> 00:25:41,310
如果当前反馈有效或为空

548
00:25:41,310 --> 00:25:42,590
如果非空

549
00:25:42,590 --> 00:25:44,170
则升级为假

550
00:25:44,170 --> 00:25:46,440
这意味着我们仍会发出此事件

551
00:25:46,440 --> 00:25:50,140
但升级不会发生，因为我们设置了升级为假

552
00:25:50,140 --> 00:25:54,780
这足以跳出循环或继续循环

553
00:25:55,260 --> 00:25:57,440
你现在可以创建循环代理了

554
00:25:57,440 --> 00:26:02,200
循环代理是一个特殊的工作流代理，这里接收子代理列表

555
00:26:02,200 --> 00:26:03,020
提案代理

556
00:26:03,020 --> 00:26:03,820
评审代理

557
00:26:03,820 --> 00:26:06,730
以及自定义检查状态和升级代理

558
00:26:06,730 --> 00:26:08,409
并将它们放入循环中

559
00:26:08,409 --> 00:26:10,569
这个过程完全不需要推理

560
00:26:10,569 --> 00:26:13,620
它只是协调这些其他代理的执行

561
00:26:13,620 --> 00:26:15,740
你可以看到这里有一个有趣的地方

562
00:26:15,740 --> 00:26:18,180
它有一个新参数叫最大迭代次数

563
00:26:18,180 --> 00:26:19,620
我们将其设为两

564
00:26:19,620 --> 00:26:22,190
这意味着循环最多执行两次

565
00:26:22,190 --> 00:26:24,230
因此要么我们已达成共识

566
00:26:24,230 --> 00:26:27,190
评审代理同意提案有效

567
00:26:27,190 --> 00:26:29,550
或若未达成则退出循环

568
00:26:29,550 --> 00:26:30,790
我们不会无限循环

569
00:26:30,790 --> 00:26:31,970
当执行完成后

570
00:26:31,970 --> 00:26:35,470
结果将是确认的架构方案

571
00:26:35,470 --> 00:26:41,110
或若未确认可能需要用户提供更多关于如何处理架构的输入

572
00:26:41,110 --> 00:26:44,340
你可以创建这个代理二

573
00:26:44,900 --> 00:26:47,880
现在可以为该代理创建执行环境

574
00:26:47,880 --> 00:26:50,580
然后调用它并传入用户消息

575
00:26:50,580 --> 00:26:53,880
这些文件现在如何导入与之前相同

576
00:26:53,880 --> 00:26:55,960
当我们创建执行环境时

577
00:26:55,960 --> 00:26:58,080
将初始化状态包含一些反馈

578
00:26:58,080 --> 00:26:58,940
即为空

579
00:26:58,940 --> 00:27:01,520
用户目标和已批准的文件

580
00:27:01,680 --> 00:27:03,500
这里要运行的代理

581
00:27:03,500 --> 00:27:03,740
不过

582
00:27:03,740 --> 00:27:06,810
是将细化方案纳入细化循环

583
00:27:06,810 --> 00:27:07,170
调用者

584
00:27:07,170 --> 00:27:08,470
我们将传入用户消息

585
00:27:08,470 --> 00:27:09,990
等待其执行完成

586
00:27:09,990 --> 00:27:13,360
获取会话状态并查看

587
00:27:13,960 --> 00:27:15,800
你可以看到这需要一些时间

588
00:27:15,800 --> 00:27:19,389
因为我们实际会在最多两次迭代中循环

589
00:27:19,389 --> 00:27:21,929
同时为了进行评估

590
00:27:21,929 --> 00:27:24,349
有两个代理会检查这些文件

591
00:27:24,349 --> 00:27:24,989
首先是

592
00:27:24,989 --> 00:27:25,369
当然

593
00:27:25,369 --> 00:27:28,100
提案代理会分析每个文件

594
00:27:28,100 --> 00:27:30,860
并决定如何构建知识图谱

595
00:27:30,860 --> 00:27:34,550
然后评审代理会查看相同文件集

596
00:27:34,550 --> 00:27:37,590
判断提案是否有效

597
00:27:37,590 --> 00:27:40,050
你可以看到我们从细化循环开始

598
00:27:40,050 --> 00:27:42,520
进入提案代理v一

599
00:27:42,520 --> 00:27:47,720
评审代理最终回到提案代理

600
00:27:47,720 --> 00:27:49,940
再次回到评审代理

601
00:27:49,940 --> 00:27:50,620
啊

602
00:27:50,620 --> 00:27:53,220
这位评论家在这里仍不满意

603
00:27:53,220 --> 00:27:55,580
最终回复是评论家表示反对

604
00:27:55,580 --> 00:27:56,600
你必须重试

605
00:27:56,600 --> 00:28:00,630
它对提案内容的某些方面感到不满

606
00:28:00,630 --> 00:28:03,470
它认为存在关系重叠问题

607
00:28:03,470 --> 00:28:05,670
数据可能不完整

608
00:28:05,670 --> 00:28:07,750
我不打算全部阅读这些反馈

609
00:28:07,750 --> 00:28:11,490
但这些反馈正是应回传给提案代理的

610
00:28:11,490 --> 00:28:13,699
以真正提升结果

611
00:28:13,939 --> 00:28:15,319
所以在此次调用中

612
00:28:15,319 --> 00:28:16,979
尽管我们进行了两次迭代

613
00:28:16,979 --> 00:28:18,479
通过优化循环

614
00:28:18,479 --> 00:28:20,570
评论家仍未满意

615
00:28:20,570 --> 00:28:25,469
这在整体架构中意味着循环终止

616
00:28:25,469 --> 00:28:30,639
整体控制流程将返回给模式提案协调者

617
00:28:30,639 --> 00:28:30,999
现在

618
00:28:30,999 --> 00:28:33,259
这是需要人类参与的代理

619
00:28:33,259 --> 00:28:36,499
因此协调者可以对人类说

620
00:28:36,499 --> 00:28:38,900
不确定该生成什么模式

621
00:28:38,900 --> 00:28:40,080
这是我目前的成果

622
00:28:40,080 --> 00:28:41,520
你觉得我们下一步该怎么做

623
00:28:41,520 --> 00:28:42,340
是否继续尝试

624
00:28:42,340 --> 00:28:45,449
或者你有无需人类介入的建议吗

625
00:28:45,449 --> 00:28:46,789
你可以再次运行此流程

626
00:28:46,789 --> 00:28:48,460
你可以进入笔记本

627
00:28:48,460 --> 00:28:50,860
重置这些单元格并重新运行

628
00:28:50,860 --> 00:28:54,510
你可以尝试调整此处传递的信息

629
00:28:54,510 --> 00:28:57,650
这些是你直接操作时会做的事

630
00:28:57,650 --> 00:28:59,470
将有一个可选版本

631
00:28:59,470 --> 00:29:00,410
你将直接进行

632
00:29:00,410 --> 00:29:04,370
并整合这个顶层协调器供你交互

633
00:29:04,370 --> 00:29:08,210
并实际看到通过单次优化或多轮优化

634
00:29:08,210 --> 00:29:09,830
或你的建议

635
00:29:09,830 --> 00:29:13,830
如何达成评论家和你都认可的模式提案

636
00:29:13,830 --> 00:29:17,000
从而推进构建知识图谱

