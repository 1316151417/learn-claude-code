1
00:00:00,120 --> 00:00:04,120
我们通过组合构建模块来创建工作流程

2
00:00:04,120 --> 00:00:08,480
在本视频中我们将这些复杂工作流程进行序列化处理

3
00:00:08,480 --> 00:00:11,360
我想与大家分享几个关键设计模式

4
00:00:11,360 --> 00:00:18,000
这些是关于如何将构建模块组合成更复杂工作流程的思考模式

5
00:00:18,000 --> 00:00:18,900
让我们先看看

6
00:00:18,900 --> 00:00:23,140
我认为构建通用工作流程的四大关键设计模式是反射

7
00:00:23,140 --> 00:00:26,290
使用规划和多协作

8
00:00:26,290 --> 00:00:28,590
让我简要解释它们的含义

9
00:00:28,590 --> 00:00:33,389
然后我们将深入探讨这些模式的详细内容

10
00:00:33,389 --> 00:00:37,430
主要设计模式之一是反射

11
00:00:37,430 --> 00:00:40,970
所以我可能会向语言模型代理请求编写代码

12
00:00:40,970 --> 00:00:44,930
结果语言模型可能生成如下代码

13
00:00:44,930 --> 00:00:47,950
这里定义了一个用于特定任务的Python函数

14
00:00:47,950 --> 00:00:50,450
我随后可以构建如下提示

15
00:00:50,450 --> 00:00:53,250
这里提供了一段用于特定任务的代码

16
00:00:53,250 --> 00:00:54,410
然后复制粘贴

17
00:00:54,410 --> 00:00:56,960
将语言模型刚刚输出的内容放入此处

18
00:00:56,960 --> 00:00:57,980
然后我要求它

19
00:00:57,980 --> 00:00:59,500
仔细检查代码是否正确

20
00:00:59,500 --> 00:01:01,720
注重效率并给出建设性批评

21
00:01:01,720 --> 00:01:04,789
结果采用这种方式提示的语言模型

22
00:01:04,789 --> 00:01:07,709
可能能指出代码中的问题

23
00:01:07,709 --> 00:01:12,600
如果我将这些反馈重新输入模型

24
00:01:12,600 --> 00:01:14,450
说看起来存在一个错误

25
00:01:14,450 --> 00:01:16,150
能否修改代码修复它

26
00:01:16,150 --> 00:01:22,850
它可能会提供改进后的代码预览

27
00:01:22,850 --> 00:01:26,670
如果你能运行代码并查看执行结果

28
00:01:26,670 --> 00:01:29,600
将反馈输入语言模型

29
00:01:29,600 --> 00:01:33,840
也能使其迭代生成更优版本

30
00:01:33,840 --> 00:01:36,259
例如生成v3版本的代码

31
00:01:36,259 --> 00:01:38,519
因此反射是一种常见设计模式

32
00:01:38,519 --> 00:01:41,499
可让语言模型审查自身输出

33
00:01:41,499 --> 00:01:45,039
或引入外部信息源

34
00:01:45,039 --> 00:01:48,470
例如运行代码查看是否报错

35
00:01:48,470 --> 00:01:51,350
并将其作为反馈进行迭代

36
00:01:51,350 --> 00:01:53,950
从而生成更优的输出版本

37
00:01:53,950 --> 00:01:56,090
这种设计模式并非万能

38
00:01:56,090 --> 00:01:59,699
并不能保证百分之百成功

39
00:01:59,699 --> 00:02:03,419
但有时能显著提升系统性能

40
00:02:03,419 --> 00:02:04,519
现在我画出这个示意图

41
00:02:04,519 --> 00:02:07,410
显示为单一语言模型被调用

42
00:02:07,410 --> 00:02:10,430
但为预示多代理工作流程

43
00:02:10,430 --> 00:02:14,760
也可以想象让不同模型互相 critique

44
00:02:14,760 --> 00:02:16,880
可以设想使用专门的批评代理

45
00:02:16,880 --> 00:02:20,690
它只是被提示指令的组件

46
00:02:20,690 --> 00:02:22,650
例如你的角色是代码审查

47
00:02:22,650 --> 00:02:24,270
这里提供任务目标代码

48
00:02:24,270 --> 00:02:25,720
仔细检查代码并如此类推

49
00:02:25,720 --> 00:02:29,840
第二个批评代理可能指出错误或运行单元测试

50
00:02:29,840 --> 00:02:33,160
通过让两个模拟代理协作

51
00:02:33,160 --> 00:02:36,860
每个代理只是一个被提示扮演特定角色的语言模型

52
00:02:36,860 --> 00:02:41,210
你需要让他们来回迭代以获得更好的输出

53
00:02:41,210 --> 00:02:43,170
除了反思模式之外

54
00:02:43,170 --> 00:02:46,370
第二个重要的设计模式是使用

55
00:02:46,370 --> 00:02:52,670
今天可以赋予它们可以调用的功能来完成任务

56
00:02:52,670 --> 00:02:53,410
例如

57
00:02:53,410 --> 00:02:54,050
如果你询问

58
00:02:54,050 --> 00:02:54,430
你知道的

59
00:02:54,430 --> 00:02:55,770
什么是最好的咖啡机

60
00:02:55,770 --> 00:02:56,730
根据评测者

61
00:02:56,730 --> 00:02:58,290
并提供网络搜索功能

62
00:02:58,290 --> 00:03:02,260
然后它可以真正搜索互联网找到更优答案

63
00:03:02,260 --> 00:03:03,900
或者代码执行工具

64
00:03:03,900 --> 00:03:05,240
如果你问一个数学问题

65
00:03:05,240 --> 00:03:06,860
比如我投资一百美元

66
00:03:06,860 --> 00:03:07,880
复利计算

67
00:03:07,880 --> 00:03:08,680
无论你结束

68
00:03:08,680 --> 00:03:12,380
然后它可以编写并执行代码计算答案

69
00:03:12,380 --> 00:03:12,900
今天

70
00:03:12,900 --> 00:03:18,560
不同开发者为数学或数据分析提供了多种工具

71
00:03:18,560 --> 00:03:19,700
收集信息

72
00:03:19,700 --> 00:03:21,100
通过从网页获取内容

73
00:03:21,100 --> 00:03:22,420
或各种数据库

74
00:03:22,420 --> 00:03:24,880
与邮件等生产力应用交互

75
00:03:24,880 --> 00:03:26,060
日历等等

76
00:03:26,060 --> 00:03:28,400
以及处理图像

77
00:03:28,400 --> 00:03:29,340
等等更多

78
00:03:29,340 --> 00:03:33,400
语言模型决定使用哪些工具的能力

79
00:03:33,400 --> 00:03:33,740
即

80
00:03:33,740 --> 00:03:37,800
调用哪些函数让模型能完成更多任务

81
00:03:37,800 --> 00:03:41,280
第四种设计模式是规划

82
00:03:41,280 --> 00:03:45,320
这是来自《Hugging GPT》论文的例子

83
00:03:45,320 --> 00:03:49,220
当要求系统

84
00:03:49,220 --> 00:03:51,420
请生成一张女孩读书的图像

85
00:03:51,420 --> 00:03:53,240
图像中的男孩姿势相似

86
00:03:53,240 --> 00:03:55,320
然后请用你的声音描述新图像

87
00:03:55,320 --> 00:03:59,370
模型可以自动决定执行此任务

88
00:03:59,370 --> 00:04:04,500
首先需要找到姿势检测模型确定男孩姿势

89
00:04:04,500 --> 00:04:07,040
然后调整图像生成女孩画面

90
00:04:07,040 --> 00:04:07,680
并生成图像

91
00:04:07,680 --> 00:04:08,120
文本描述

92
00:04:08,120 --> 00:04:09,890
最后文本转语音

93
00:04:09,890 --> 00:04:15,910
因此在规划中，语言模型决定所需行动序列

94
00:04:15,910 --> 00:04:19,640
在此为API调用序列

95
00:04:19,640 --> 00:04:23,840
从而按正确顺序执行步骤

96
00:04:23,840 --> 00:04:26,150
完成任务

97
00:04:26,150 --> 00:04:30,190
而非开发者预先硬编码步骤

98
00:04:30,190 --> 00:04:35,660
这允许模型决定代理规划的步骤

99
00:04:35,660 --> 00:04:38,620
虽然更难控制且更具实验性

100
00:04:38,620 --> 00:04:41,380
但有时能产生惊艳结果

101
00:04:41,380 --> 00:04:44,280
然后最后是多智能体工作流

102
00:04:44,280 --> 00:04:49,920
就像人类经理可能会雇佣多人协作完成复杂项目

103
00:04:49,920 --> 00:04:54,420
在某些情况下，雇佣多个智能体可能更合理

104
00:04:54,420 --> 00:04:57,300
每个可能专注于不同领域

105
00:04:57,300 --> 00:05:00,940
并共同完成复杂任务

106
00:05:00,940 --> 00:05:05,220
你看到的这张图来自名为Chat Dev的项目

107
00:05:05,220 --> 00:05:10,640
这是陈倩及其合作者开发的软件框架Chat Dev

108
00:05:10,640 --> 00:05:14,330
具有不同角色的多个智能体，如首席执行官

109
00:05:14,330 --> 00:05:15,210
程序员

110
00:05:15,210 --> 00:05:15,870
测试员

111
00:05:15,870 --> 00:05:18,350
设计师等协同合作

112
00:05:18,350 --> 00:05:26,330
如同虚拟软件公司般协作完成各类软件开发任务

113
00:05:26,330 --> 00:05:27,970
让我们考虑另一个例子

114
00:05:27,970 --> 00:05:30,430
如果你想撰写营销手册

115
00:05:30,430 --> 00:05:33,660
或许会组建三人团队

116
00:05:33,660 --> 00:05:36,580
比如研究员进行网络调研

117
00:05:36,580 --> 00:05:38,640
营销人员撰写文案

118
00:05:38,640 --> 00:05:42,610
最后由编辑润色文本

119
00:05:42,610 --> 00:05:44,390
类似地

120
00:05:44,390 --> 00:05:48,000
你可以考虑构建多智能体工作流

121
00:05:48,000 --> 00:05:50,360
其中包含模拟研究智能体

122
00:05:50,360 --> 00:05:52,280
模拟营销智能体

123
00:05:52,280 --> 00:05:58,410
以及模拟编辑智能体共同执行任务

124
00:05:58,410 --> 00:06:01,870
多智能体工作流更难控制

125
00:06:01,870 --> 00:06:05,330
因为你无法提前预知智能体的具体行为

126
00:06:05,330 --> 00:06:10,560
但研究表明它们能为许多复杂任务带来更好结果

127
00:06:10,560 --> 00:06:15,300
包括撰写传记或决定国际象棋走法等

128
00:06:15,300 --> 00:06:19,990
课程后续还会深入讲解多智能体工作流

129
00:06:19,990 --> 00:06:23,770
希望你已了解智能体工作流的能力

130
00:06:23,770 --> 00:06:28,830
以及构建模块和整合的关键挑战

131
00:06:28,830 --> 00:06:33,730
或许通过这些设计模式实现智能体工作流

132
00:06:33,730 --> 00:06:35,930
当然还包括开发评估系统

133
00:06:35,930 --> 00:06:40,310
以便观察系统表现并持续优化

134
00:06:40,310 --> 00:06:42,270
在下一模块

135
00:06:42,270 --> 00:06:47,360
我将与你深入探讨首个设计模式

136
00:06:47,360 --> 00:06:49,040
即反射机制

137
00:06:49,040 --> 00:06:53,940
你会发现这可能是实现起来相对简单的技术

138
00:06:53,940 --> 00:06:58,600
有时能显著提升系统性能

139
00:06:58,600 --> 00:07:04,200
让我们进入下一模块学习反射设计模式

