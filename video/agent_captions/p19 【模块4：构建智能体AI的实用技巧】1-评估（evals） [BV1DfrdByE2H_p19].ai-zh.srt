1
00:00:00,080 --> 00:00:00,860
在本模块中

2
00:00:00,860 --> 00:00:04,840
我想分享几个构建高效AI工作流的实用技巧

3
00:00:04,840 --> 00:00:08,450
我希望这些技巧能让你在构建这类系统时效率大幅提升

4
00:00:08,450 --> 00:00:13,250
相比普通开发者更具优势

5
00:00:13,340 --> 00:00:16,219
我发现开发AI系统时

6
00:00:16,219 --> 00:00:18,180
很难预先知道

7
00:00:18,180 --> 00:00:21,060
哪些地方会有效哪些地方效果不佳

8
00:00:21,060 --> 00:00:23,900
这才是你应该重点投入的地方

9
00:00:23,900 --> 00:00:29,710
非常常见的建议是尝试构建一个快速简易的系统作为起点

10
00:00:29,710 --> 00:00:32,470
这样你就可以实际测试并观察

11
00:00:32,470 --> 00:00:35,600
看看哪些部分尚未达到预期效果

12
00:00:35,600 --> 00:00:40,900
以便后续能更有针对性地进行深入开发

13
00:00:40,900 --> 00:00:41,640
相比之下

14
00:00:41,640 --> 00:00:44,320
我发现有时

15
00:00:44,320 --> 00:00:44,740
你知道的

16
00:00:44,740 --> 00:00:46,340
不要花太多周时间

17
00:00:46,340 --> 00:00:48,400
空谈假设

18
00:00:48,400 --> 00:00:49,180
如何构建

19
00:00:49,180 --> 00:00:53,790
通常更好的做法是用安全合理的方式快速构建系统

20
00:00:53,790 --> 00:00:54,470
以合理的方式

21
00:00:54,470 --> 00:00:55,530
处理泄漏数据

22
00:00:55,530 --> 00:00:57,740
以负责任的方式

23
00:00:57,740 --> 00:00:59,320
但只需快速构建

24
00:00:59,320 --> 00:01:00,340
这样你就可以查看

25
00:01:00,340 --> 00:01:05,340
然后利用这个初始原型来优先级排序并推动进一步开发

26
00:01:05,340 --> 00:01:10,170
让我们从构建原型后的示例开始

27
00:01:10,170 --> 00:01:12,190
我想用第一个例子

28
00:01:12,190 --> 00:01:16,120
之前展示过的发票处理工作流

29
00:01:16,120 --> 00:01:18,200
包含提取四个必填字段的任务

30
00:01:18,200 --> 00:01:21,230
然后保存到数据库记录

31
00:01:21,230 --> 00:01:23,650
在构建此类系统后

32
00:01:23,650 --> 00:01:26,690
你可以找到十几张或二十张发票

33
00:01:26,690 --> 00:01:28,509
可能十张或二十张发票

34
00:01:28,509 --> 00:01:32,449
逐一查看输出结果并检查哪些部分有效

35
00:01:32,449 --> 00:01:34,380
以及是否存在任何错误

36
00:01:34,380 --> 00:01:36,140
所以让我们查看两张发票

37
00:01:36,140 --> 00:01:38,040
发现第一张发票正常

38
00:01:38,040 --> 00:01:40,260
第二张发票的输出看起来正确

39
00:01:40,260 --> 00:01:42,690
可能混淆了发票日期

40
00:01:42,690 --> 00:01:45,970
即发票的开具日期和到期日期

41
00:01:45,970 --> 00:01:48,670
在这个任务中我们需要提取到期日期

42
00:01:48,670 --> 00:01:50,570
以便后续按时付款

43
00:01:50,570 --> 00:01:52,970
因此我可能在文档或表格中记录

44
00:01:52,970 --> 00:01:54,930
或在电子表格中注明对于第二张发票

45
00:01:54,930 --> 00:01:56,240
日期存在混淆

46
00:01:56,240 --> 00:01:57,580
第三张发票正常

47
00:01:57,580 --> 00:01:59,380
第四张发票正常等等

48
00:01:59,380 --> 00:02:01,040
但当我继续这个示例时

49
00:02:01,040 --> 00:02:05,550
发现有很多类似日期混淆的例子

50
00:02:05,550 --> 00:02:09,270
这正是通过此类示例进行分析的基础

51
00:02:09,270 --> 00:02:09,770
这

52
00:02:09,770 --> 00:02:16,720
在这种情况下，你可能会得出一个常见错误模式，即系统在处理日期时存在困难

53
00:02:16,720 --> 00:02:17,680
在这种情况下

54
00:02:17,680 --> 00:02:20,340
你可以考虑的一个方法是

55
00:02:20,340 --> 00:02:22,760
当然，首先要弄清楚如何改进你的系统

56
00:02:22,760 --> 00:02:25,020
使其更好地提取到期日期

57
00:02:25,020 --> 00:02:28,660
同时可能需要编写评估指标来衡量提取准确性

58
00:02:28,660 --> 00:02:32,040
与实际提取的到期日期进行对比

59
00:02:32,040 --> 00:02:36,660
如果你发现系统错误提取了账单地址

60
00:02:36,660 --> 00:02:40,100
谁知道也许你有发音奇特的账单名称

61
00:02:40,100 --> 00:02:41,820
因此系统可能在处理账单时遇到困难

62
00:02:41,820 --> 00:02:46,900
尤其是当国际账单方名称可能包含非英文字母时

63
00:02:46,900 --> 00:02:50,940
这时你可能需要专注于构建账单地址的评估系统

64
00:02:50,940 --> 00:02:54,100
之所以快速构建简易系统

65
00:02:54,100 --> 00:02:55,940
并检查输出结果非常有帮助

66
00:02:55,940 --> 00:03:02,460
因为它能帮助你决定当前应优先评估哪些环节

67
00:03:02,460 --> 00:03:07,960
如果你决定修改系统以提高准确性

68
00:03:07,960 --> 00:03:10,560
在提取发票到期日期时的准确性

69
00:03:10,560 --> 00:03:12,260
那么要推进下一步

70
00:03:12,260 --> 00:03:16,100
创建评估指标可能是个好主意

71
00:03:16,100 --> 00:03:19,170
以衡量数据提取的准确性

72
00:03:19,170 --> 00:03:21,470
可能有多种方法可以实现

73
00:03:21,470 --> 00:03:22,650
但让我分享

74
00:03:22,650 --> 00:03:24,410
我是如何操作的

75
00:03:24,410 --> 00:03:27,010
创建测试集或评估集

76
00:03:27,010 --> 00:03:31,880
我可能会找到10到20张发票并手动记录

77
00:03:31,880 --> 00:03:32,840
正确的到期日期是什么

78
00:03:32,840 --> 00:03:35,240
例如某张发票的到期日期是八月

79
00:03:35,240 --> 00:03:36,600
2025年20日

80
00:03:36,600 --> 00:03:40,810
并以标准年月日格式记录

81
00:03:40,810 --> 00:03:44,590
以便后续代码评估更方便

82
00:03:44,590 --> 00:03:48,200
我会编写提示语让语言模型始终按

83
00:03:48,200 --> 00:03:50,960
年月日格式输出到期日期

84
00:03:50,960 --> 00:03:56,020
然后编写代码提取模型输出中的日期部分

85
00:03:56,020 --> 00:03:56,880
这就是我们需要关注的到期日期

86
00:03:56,880 --> 00:03:58,340
因此只需关注这个日期

87
00:03:58,340 --> 00:04:01,020
这需要正则表达式模式匹配

88
00:04:01,020 --> 00:04:01,460
你知道的

89
00:04:01,460 --> 00:04:02,620
四位数字表示年份

90
00:04:02,620 --> 00:04:03,340
两位数字表示月份

91
00:04:03,340 --> 00:04:03,980
两位数字表示日期

92
00:04:03,980 --> 00:04:05,220
然后提取这部分内容

93
00:04:05,220 --> 00:04:07,960
接着编写代码进行测试

94
00:04:07,960 --> 00:04:11,040
判断提取日期是否等于实际日期

95
00:04:11,040 --> 00:04:14,449
即我手动标注的真实日期

96
00:04:14,449 --> 00:04:16,329
因此使用包含

97
00:04:16,329 --> 00:04:17,928
约20张发票的评估集

98
00:04:17,928 --> 00:04:23,550
通过修改系统观察正确提取日期的比例

99
00:04:23,550 --> 00:04:25,090
是否有所提升

100
00:04:25,090 --> 00:04:28,210
随着我调整提示或系统其他部分

101
00:04:28,210 --> 00:04:30,710
所以总结一下我们到目前为止看到的内容

102
00:04:30,710 --> 00:04:32,000
我们构建了一个系统

103
00:04:32,000 --> 00:04:32,900
然后分析输出结果

104
00:04:32,900 --> 00:04:36,760
以发现系统可能存在的不足之处

105
00:04:36,760 --> 00:04:38,440
例如截止日期错误

106
00:04:38,440 --> 00:04:41,420
然后针对这个重要输出进行改进

107
00:04:41,420 --> 00:04:42,000
实施

108
00:04:42,000 --> 00:04:46,030
一个小规模评估只需两个示例来帮助我们跟踪进展

109
00:04:46,030 --> 00:04:48,350
这让我可以回到两个优点

110
00:04:48,350 --> 00:04:53,700
尝试不同算法等以提升截止日期准确性这一指标

111
00:04:53,700 --> 00:04:58,160
这就是改进整个工作流程通常的感觉

112
00:04:58,160 --> 00:04:58,840
查看输出结果

113
00:04:58,840 --> 00:04:59,720
发现问题所在

114
00:04:59,720 --> 00:05:00,960
如果你知道如何修复

115
00:05:00,960 --> 00:05:01,520
直接进行修正

116
00:05:01,520 --> 00:05:03,720
但如果需要更长的改进过程

117
00:05:03,720 --> 00:05:06,720
则建立评估并以此驱动进一步开发

118
00:05:06,720 --> 00:05:10,100
另一个需要考虑的是工作一段时间后

119
00:05:10,100 --> 00:05:13,420
如果最初两个示例不够理想

120
00:05:13,420 --> 00:05:15,480
可能无法覆盖所有需求场景

121
00:05:15,480 --> 00:05:17,340
或者二十个示例数量太少

122
00:05:17,340 --> 00:05:20,860
可以随时扩展评估集以确保更全面

123
00:05:20,860 --> 00:05:27,180
反映系统性能是否达到满意标准的个人判断

124
00:05:27,180 --> 00:05:29,600
这只是第二个示例

125
00:05:29,600 --> 00:05:34,760
让我们构建一个Instagram文案助手

126
00:05:34,760 --> 00:05:36,220
保持内容同步

127
00:05:36,220 --> 00:05:39,300
假设营销团队要求我们生成的文案需

128
00:05:39,300 --> 00:05:40,940
最多十词以内

129
00:05:40,940 --> 00:05:43,480
展示产品图片

130
00:05:43,480 --> 00:05:45,840
比如我们要推广的太阳镜

131
00:05:45,840 --> 00:05:47,860
然后用户查询如

132
00:05:47,860 --> 00:05:50,860
请为这些太阳镜撰写销售文案

133
00:05:50,860 --> 00:05:54,380
然后使用语言模型或大型多模态模型

134
00:05:54,380 --> 00:05:59,280
分析图片和查询生成产品描述

135
00:05:59,280 --> 00:06:03,820
营销文案可能出错的方式有很多

136
00:06:03,820 --> 00:06:05,660
但假设查看输出结果

137
00:06:05,660 --> 00:06:09,280
发现生成的文案大部分听起来正常

138
00:06:09,280 --> 00:06:11,200
但有时可能过长

139
00:06:11,200 --> 00:06:12,620
对于太阳镜输入

140
00:06:12,620 --> 00:06:15,520
生成十七词若咖啡机则无问题

141
00:06:15,520 --> 00:06:16,020
时尚

142
00:06:16,020 --> 00:06:16,420
可以

143
00:06:16,420 --> 00:06:18,140
蓝衬衫十四词

144
00:06:18,140 --> 00:06:19,340
搅拌机十一词

145
00:06:19,340 --> 00:06:20,880
看起来在这个例子中

146
00:06:20,880 --> 00:06:25,570
模型难以遵循长度限制

147
00:06:25,570 --> 00:06:29,530
营销文案助手可能出现很多问题

148
00:06:29,530 --> 00:06:33,290
但若发现输出长度不达标

149
00:06:33,290 --> 00:06:36,030
则可建立评估指标进行跟踪

150
00:06:36,030 --> 00:06:38,010
以便持续改进

151
00:06:38,010 --> 00:06:42,110
确保它在听力长度指南上有所改进

152
00:06:42,110 --> 00:06:44,630
因此创建一个评估来衡量文本长度

153
00:06:44,630 --> 00:06:47,150
你可以创建一组测试任务

154
00:06:47,150 --> 00:06:48,650
所以标记一副太阳镜

155
00:06:48,650 --> 00:06:49,850
一台咖啡机等等

156
00:06:49,850 --> 00:06:52,880
可能创建十个到二十个示例

157
00:06:52,880 --> 00:06:55,720
然后将每个示例输入系统

158
00:06:55,720 --> 00:06:59,580
编写代码测量输出的词数

159
00:06:59,580 --> 00:07:04,010
这是测量文本词数的Python代码

160
00:07:04,010 --> 00:07:10,770
最后比较生成文本与十词目标限制的长度

161
00:07:10,770 --> 00:07:12,530
如果词数等于十

162
00:07:12,530 --> 00:07:14,320
正确计数加一

163
00:07:14,320 --> 00:07:21,280
这与之前的发票处理示例不同之处在于没有每个示例

164
00:07:21,280 --> 00:07:22,160
真实标注

165
00:07:22,160 --> 00:07:25,260
目标对每个示例都相同

166
00:07:25,260 --> 00:07:27,840
相比之下在发票处理示例中

167
00:07:27,840 --> 00:07:30,800
需要生成自定义目标标签

168
00:07:30,800 --> 00:07:33,660
即发票的正确到期日期

169
00:07:33,660 --> 00:07:37,620
并将其与每个示例的真实标注进行对比

170
00:07:37,620 --> 00:07:41,180
我知道我使用了非常简单的流程生成这些标题

171
00:07:41,180 --> 00:07:46,140
但这类方法也可应用于更复杂的生成流程

172
00:07:46,140 --> 00:07:48,080
让我再讲一个最终示例

173
00:07:48,080 --> 00:07:52,430
我们将重新审视之前研究的代理

174
00:07:52,430 --> 00:07:57,350
查看研究代理在不同输入提示下的输出

175
00:07:57,350 --> 00:08:01,670
假设要求它撰写关于黑洞研究的最新突破文章

176
00:08:01,670 --> 00:08:02,789
在黑洞领域

177
00:08:02,789 --> 00:08:07,209
发现它遗漏了新闻报道中的一些重大成果

178
00:08:07,209 --> 00:08:09,089
这是令人不满意的结果

179
00:08:09,089 --> 00:08:10,960
或者当你要求它研究

180
00:08:10,960 --> 00:08:12,640
西雅图租房与购房

181
00:08:12,640 --> 00:08:15,800
或在机器人采摘水果方面表现良好

182
00:08:15,800 --> 00:08:16,240
嗯

183
00:08:16,240 --> 00:08:19,230
未提及领先设备公司

184
00:08:19,230 --> 00:08:21,330
基于此评估

185
00:08:21,330 --> 00:08:28,160
看起来有时会遗漏人类专家会捕捉到的重要点

186
00:08:28,160 --> 00:08:33,740
因此我将创建评估来衡量其捕捉关键点的频率

187
00:08:33,740 --> 00:08:39,030
例如为黑洞、机器人采摘等主题准备多个示例提示

188
00:08:39,030 --> 00:08:40,669
以及相关领域

189
00:08:40,669 --> 00:08:42,250
并对每个示例

190
00:08:42,250 --> 00:08:46,830
为每个主题列出三到五个黄金标准讨论点

191
00:08:46,830 --> 00:08:51,270
注意这里需要每个示例的标注

192
00:08:51,270 --> 00:08:52,870
因为黄金标准讨论点

193
00:08:52,870 --> 00:08:55,100
即最重要的讨论点

194
00:08:55,100 --> 00:08:57,280
每个示例不同

195
00:08:57,280 --> 00:08:59,060
通过这些真实标注

196
00:08:59,060 --> 00:09:05,750
可以使用语言模型统计提及的黄金标准讨论点数量

197
00:09:05,750 --> 00:09:08,530
例如提示可能要求

198
00:09:08,530 --> 00:09:13,150
确定提供的文章中包含多少个五项黄金标准讨论点

199
00:09:13,150 --> 00:09:14,190
你有可选提示

200
00:09:14,190 --> 00:09:14,920
文章

201
00:09:14,920 --> 00:09:16,520
采用标准评分点等

202
00:09:16,520 --> 00:09:18,840
并返回包含两个键的JSON对象

203
00:09:18,840 --> 00:09:19,620
有分数

204
00:09:19,620 --> 00:09:22,380
有多少个0到5的评分点对应分数

205
00:09:22,380 --> 00:09:24,020
以及解释说明

206
00:09:24,020 --> 00:09:31,179
这允许为评估集中的每个提示获取分数

207
00:09:31,179 --> 00:09:36,339
我用om作为评判者统计提到的要点数量

208
00:09:36,339 --> 00:09:40,050
因为这些要点的讨论方式多种多样

209
00:09:40,050 --> 00:09:45,630
因此简单的正则表达式或模式匹配可能效果不佳

210
00:09:45,630 --> 00:09:48,110
这也是为何可能使用a作为评判者

211
00:09:48,110 --> 00:09:52,890
并将其视为更主观的评估标准，例如

212
00:09:52,890 --> 00:09:55,390
事件视界是否被充分提及

213
00:09:55,390 --> 00:09:59,280
这是构建评估指标的第三个示例

214
00:09:59,280 --> 00:10:02,360
在思考如何构建评估系统时

215
00:10:02,360 --> 00:10:03,640
S针对您的应用场景

216
00:10:03,640 --> 00:10:08,190
您构建的评估系统通常需要反映实际需求

217
00:10:08,190 --> 00:10:11,510
或您在应用中可能出现的错误

218
00:10:11,510 --> 00:10:18,550
实际上，评估存在两大维度，顶部维度

219
00:10:18,550 --> 00:10:21,580
是评估输出的方式

220
00:10:21,580 --> 00:10:26,840
有时通过编写代码进行客观评估

221
00:10:26,840 --> 00:10:32,540
有时则使用o作为评判者进行主观评估

222
00:10:32,540 --> 00:10:38,800
S另一维度是是否具有单例真实标签

223
00:10:38,800 --> 00:10:42,250
例如检查发票数据提取

224
00:10:42,250 --> 00:10:45,910
我们编写代码验证是否获取实际日期

225
00:10:45,910 --> 00:10:49,030
这具有单例真实标签

226
00:10:49,030 --> 00:10:51,980
因为每张发票的实际日期不同

227
00:10:51,980 --> 00:10:55,380
但在检查营销文案长度时

228
00:10:55,380 --> 00:11:02,720
每个示例都有10字限制，无需单例真实标签

229
00:11:02,720 --> 00:11:06,160
相比之下，统计标准要点

230
00:11:06,160 --> 00:11:08,400
存在单例真实标签

231
00:11:08,400 --> 00:11:11,660
因为每篇文章的重要要点不同

232
00:11:11,660 --> 00:11:14,280
但我们使用元素作为评判者阅读文章

233
00:11:14,280 --> 00:11:17,089
判断是否充分提及这些主题

234
00:11:17,089 --> 00:11:20,230
因为提及要点的方式多种多样

235
00:11:20,230 --> 00:11:24,270
四个象限的最后一类是消息评判者

236
00:11:24,270 --> 00:11:26,750
无需单例真实标签

237
00:11:26,750 --> 00:11:31,629
例如在按评分标准批改图表时

238
00:11:31,629 --> 00:11:35,220
我们正在可视化咖啡机销售数据

239
00:11:35,220 --> 00:11:38,480
若要求根据评分标准生成图表

240
00:11:38,480 --> 00:11:40,900
如是否标注清晰等

241
00:11:40,900 --> 00:11:43,790
所有图表使用相同的评分标准

242
00:11:43,790 --> 00:11:45,650
这将使用元素作为评判者

243
00:11:45,650 --> 00:11:47,990
但无需单例真实标签

244
00:11:47,990 --> 00:11:49,430
我发现这个二维网格

245
00:11:49,430 --> 00:11:52,400
可能是思考不同评估类型的有效方式

246
00:11:52,400 --> 00:11:54,820
S您可能为应用构建的评估系统

247
00:11:54,820 --> 00:11:58,520
顺便说这些有时也称为端到端评估S

248
00:11:58,520 --> 00:12:01,990
因为一端是输入和用户查询提示

249
00:12:01,990 --> 00:12:04,570
另一端是最终输出

250
00:12:04,570 --> 00:12:10,550
因此这些都是完整端到端系统的评估指标

251
00:12:10,550 --> 00:12:12,210
所以总结一下这个视频

252
00:12:12,210 --> 00:12:15,750
我想分享几个设计端到端评估的最终建议

253
00:12:15,750 --> 00:12:19,110
首先快速粗糙的评估是完全可以起步的

254
00:12:19,110 --> 00:12:23,690
我觉得看到很多团队几乎陷入瘫痪

255
00:12:23,690 --> 00:12:27,370
因为他们认为构建评估是需要数周的巨大工程

256
00:12:27,370 --> 00:12:31,650
因此他们花费了理想时间之外的更久才开始

257
00:12:31,650 --> 00:12:36,360
但正如你迭代优化代理工作流并逐步改进

258
00:12:36,360 --> 00:12:39,260
你也应该计划迭代优化你的评估系统

259
00:12:39,260 --> 00:12:43,010
所以如果你准备十个、十五个或二十个示例

260
00:12:43,010 --> 00:12:45,710
作为你的首个评估测试并编写和编码

261
00:12:45,710 --> 00:12:47,340
或尝试以裁判身份进行提示测试

262
00:12:47,340 --> 00:12:49,780
只需做些事情开始获取指标数据

263
00:12:49,780 --> 00:12:53,540
这可以补充人工观察输出结果

264
00:12:53,540 --> 00:12:56,440
两者结合能驱动你的决策过程

265
00:12:56,440 --> 00:12:58,960
随着评估系统逐渐智能化

266
00:12:58,960 --> 00:13:03,200
你可以逐步将更多信任交给基于指标的评估

267
00:13:03,200 --> 00:13:06,880
而非每次都要查看数百个输出结果

268
00:13:06,880 --> 00:13:08,100
你只需调整某个参数

269
00:13:08,100 --> 00:13:10,160
在这一过程中

270
00:13:10,160 --> 00:13:14,320
你可能会找到持续改进评估的方法

271
00:13:14,320 --> 00:13:17,030
所以如果你最初有二十个示例

272
00:13:17,030 --> 00:13:25,579
可能会遇到评估无法捕捉系统优劣判断的情况

273
00:13:25,579 --> 00:13:28,499
因此你更新系统并观察结果

274
00:13:28,499 --> 00:13:30,639
感觉这应该能显著提升效果

275
00:13:30,639 --> 00:13:34,980
但旧评估未能显示新系统得分更高

276
00:13:34,980 --> 00:13:36,099
如果出现这种情况

277
00:13:36,099 --> 00:13:38,379
这通常是机会

278
00:13:38,379 --> 00:13:40,299
或许扩大评估样本集

279
00:13:40,299 --> 00:13:42,279
或改变评估输出的方式

280
00:13:42,279 --> 00:13:44,920
使其更符合你的判断标准

281
00:13:44,920 --> 00:13:47,480
以准确反映哪个系统更有效

282
00:13:47,480 --> 00:13:49,760
因此你的评估会随时间提升

283
00:13:49,760 --> 00:13:53,350
最后关于利用评估获取灵感

284
00:13:53,350 --> 00:13:54,890
以确定下一步工作方向

285
00:13:54,890 --> 00:14:00,240
许多创新工作流被用于自动化人类可完成的任务

286
00:14:00,240 --> 00:14:02,240
因此对于此类应用

287
00:14:02,240 --> 00:14:04,740
我会寻找性能较差的环节

288
00:14:04,740 --> 00:14:05,840
而作为专家人类

289
00:14:05,840 --> 00:14:09,840
这常为我提供专注方向的灵感

290
00:14:09,840 --> 00:14:11,600
或者哪些类型的示例

291
00:14:11,600 --> 00:14:16,070
可能让我的代理工作流表现更优

292
00:14:16,070 --> 00:14:19,640
所以希望你在搭建快速系统后

293
00:14:19,640 --> 00:14:20,420
思考何时开始

294
00:14:20,420 --> 00:14:22,180
引入评估以跟踪系统潜在问题

295
00:14:22,180 --> 00:14:26,770
这将帮助你推动系统改进

296
00:14:26,770 --> 00:14:30,290
同时帮助你驱动系统优化

297
00:14:30,450 --> 00:14:33,250
此外还有一种评估方法

298
00:14:33,250 --> 00:14:36,170
能帮助你聚焦整个系统核心

299
00:14:36,170 --> 00:14:40,039
哪些组件最值得投入注意力

300
00:14:40,039 --> 00:14:44,239
系统中最值得专注的组件是什么

301
00:14:44,239 --> 00:14:47,360
因为基因系统通常包含许多组件

302
00:14:47,360 --> 00:14:53,220
那么哪个组件将是最具生产力的，值得你投入时间改进

303
00:14:53,220 --> 00:14:57,180
事实证明，能够做好这一点是一项对驾驶至关重要的技能

304
00:14:57,180 --> 00:15:00,780
在下一视频中高效开发enic工作流程

305
00:15:00,780 --> 00:15:02,859
我想深入探讨这一主题

306
00:15:02,859 --> 00:15:05,039
因此让我们进入下一视频

