1
00:00:00,080 --> 00:00:03,820
反射设计模式是我曾在许多应用中使用过的一种模式

2
00:00:03,820 --> 00:00:06,800
而且实现起来意外地简单

3
00:00:06,800 --> 00:00:08,210
让我们看看

4
00:00:08,210 --> 00:00:13,670
就像人类有时会反思自己的输出并找到改进方法

5
00:00:13,670 --> 00:00:14,610
所以可以

6
00:00:14,610 --> 00:00:15,550
例如

7
00:00:15,550 --> 00:00:17,270
我可能会写这样一封邮件

8
00:00:17,270 --> 00:00:18,790
如果我快速打字

9
00:00:18,790 --> 00:00:21,560
可能会得到一个质量不高的初稿

10
00:00:21,560 --> 00:00:23,189
当我通读一遍时

11
00:00:23,189 --> 00:00:27,069
可能会说下个月的日期表述不够清晰

12
00:00:27,069 --> 00:00:28,629
汤米可能有空吃晚餐

13
00:00:28,629 --> 00:00:30,829
这里有一个我打错的单词

14
00:00:30,829 --> 00:00:33,190
还忘记签上我的名字

15
00:00:33,190 --> 00:00:37,430
这将让我修改草稿，使其更明确地表达问候

16
00:00:37,430 --> 00:00:37,710
汤米

17
00:00:37,710 --> 00:00:40,190
你五号到七号有空吃晚饭吗

18
00:00:40,190 --> 00:00:41,250
类似的流程

19
00:00:41,250 --> 00:00:44,190
让我们也让语言模型改进输出

20
00:00:44,190 --> 00:00:49,119
你可以提示它们先写邮件初稿并提供邮件版本

21
00:00:49,119 --> 00:00:50,339
邮件版本一

22
00:00:50,339 --> 00:00:53,160
可以将其传递给同一模型

23
00:00:53,160 --> 00:00:54,580
同一个大型语言模型

24
00:00:54,580 --> 00:00:59,589
但使用不同提示并要求其反思并撰写改进后的第二稿

25
00:00:59,589 --> 00:01:01,509
然后获取最终输出

26
00:01:01,509 --> 00:01:02,989
邮件版本二

27
00:01:02,989 --> 00:01:06,900
我已硬编码了这个提示流程

28
00:01:06,900 --> 00:01:10,460
先提示生成初稿，再提示反思改进

29
00:01:10,460 --> 00:01:12,740
从而得到邮件版本二

30
00:01:12,740 --> 00:01:18,360
类似的流程可用于改进其他类型输出

31
00:01:18,360 --> 00:01:19,220
例如

32
00:01:19,220 --> 00:01:21,680
如果你需要编写代码

33
00:01:21,680 --> 00:01:23,580
可以提示它们编写代码

34
00:01:23,580 --> 00:01:24,740
完成特定任务

35
00:01:24,740 --> 00:01:28,010
可能会得到代码版本一

36
00:01:28,010 --> 00:01:30,780
然后传递给同一语言模型

37
00:01:30,780 --> 00:01:33,880
或不同模型检查漏洞

38
00:01:33,880 --> 00:01:36,520
并撰写改进后的代码第二稿

39
00:01:36,520 --> 00:01:38,810
不同模型各有优势

40
00:01:38,810 --> 00:01:43,150
因此有时我会选择不同模型处理初稿

41
00:01:43,150 --> 00:01:46,430
以及反思改进环节

42
00:01:46,430 --> 00:01:47,010
例如

43
00:01:47,010 --> 00:01:48,610
推理模型

44
00:01:48,610 --> 00:01:50,390
有时也称为思考模型

45
00:01:50,390 --> 00:01:53,340
在发现漏洞方面表现优异

46
00:01:53,340 --> 00:01:57,420
因此我通常先直接生成代码初稿

47
00:01:57,420 --> 00:02:01,000
然后使用推理模型检查漏洞

48
00:02:01,000 --> 00:02:02,660
而不是仅仅生成代码

49
00:02:02,660 --> 00:02:04,140
反思代码逻辑

50
00:02:04,140 --> 00:02:07,980
实际上如果能获取外部反馈

51
00:02:07,980 --> 00:02:10,229
来自外部的新信息

52
00:02:10,229 --> 00:02:15,310
在代码情况下，lm反射能力会变得更强

53
00:02:15,310 --> 00:02:20,230
你可以直接执行代码查看其功能

54
00:02:20,230 --> 00:02:22,050
并通过检查输出结果

55
00:02:22,050 --> 00:02:24,010
包括代码的任何错误信息

56
00:02:24,010 --> 00:02:27,830
这对lm进行反思提供了极其有用的信息

57
00:02:27,830 --> 00:02:29,990
并找到改进代码的方法

58
00:02:29,990 --> 00:02:30,990
在这个例子中

59
00:02:30,990 --> 00:02:33,510
生成了代码的初稿

60
00:02:33,510 --> 00:02:34,350
但当我运行时

61
00:02:34,350 --> 00:02:36,310
生成了语法错误

62
00:02:36,310 --> 00:02:38,970
当传递这段代码输出

63
00:02:38,970 --> 00:02:43,040
错误日志返回给lm并要求其反思反馈

64
00:02:43,040 --> 00:02:44,220
并编写新代码

65
00:02:44,220 --> 00:02:49,050
这为其生成更优版本提供了大量有用信息

66
00:02:49,050 --> 00:02:50,330
两段代码

67
00:02:50,330 --> 00:02:53,070
反思设计模式并非魔法

68
00:02:53,070 --> 00:02:54,550
它并不能保证

69
00:02:54,550 --> 00:02:57,380
我总能百分之百正确

70
00:02:57,380 --> 00:03:01,579
但它可能带来适度的性能提升

71
00:03:01,579 --> 00:03:07,310
需要牢记的设计要点是完美性更具威力

72
00:03:07,310 --> 00:03:10,310
当有新的外部信息补充时

73
00:03:10,310 --> 00:03:13,010
这些信息可以被纳入反思过程

74
00:03:13,010 --> 00:03:14,130
在这个例子中

75
00:03:14,130 --> 00:03:15,810
如果能够运行代码

76
00:03:15,810 --> 00:03:20,829
并将代码输出或错误信息作为反思步骤的额外输入

77
00:03:20,829 --> 00:03:25,149
这能让反思更深入地分析问题所在

78
00:03:25,149 --> 00:03:29,170
发现问题并生成更优的第二版代码

79
00:03:29,170 --> 00:03:32,290
相比没有外部信息输入的情况

80
00:03:32,290 --> 00:03:33,890
需要记住的一点

81
00:03:33,890 --> 00:03:42,099
每当反思有机会获取增强其能力的额外信息时

82
00:03:42,099 --> 00:03:43,799
让我们进入下一视频

83
00:03:43,799 --> 00:03:50,849
我想与大家分享使用反思与直接生成的系统性对比

84
00:03:50,849 --> 00:03:53,269
我们有时称为零样本

85
00:03:53,269 --> 00:03:54,149
提示

86
00:03:54,149 --> 00:03:56,369
让我们进入下一视频

