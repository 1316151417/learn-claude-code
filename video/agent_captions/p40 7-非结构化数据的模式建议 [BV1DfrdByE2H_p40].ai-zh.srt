1
00:00:00,140 --> 00:00:02,480
现在让我们专注于非结构化数据

2
00:00:02,480 --> 00:00:06,100
你将设计两个专家代理来决定图模型

3
00:00:06,100 --> 00:00:08,720
可以从markdown文件中提取的模型

4
00:00:08,720 --> 00:00:10,129
我们开始吧

5
00:00:10,129 --> 00:00:14,489
你已经构建了一个完整的流程来定义施工计划

6
00:00:14,489 --> 00:00:17,670
可以从csv文件构建知识图谱

7
00:00:17,670 --> 00:00:21,190
现在你可以转向非结构化数据流程

8
00:00:21,190 --> 00:00:25,930
这个流程以类似方式开始，包含用户意图和文件建议代理

9
00:00:25,930 --> 00:00:27,900
但现在针对markdown文件

10
00:00:27,900 --> 00:00:30,220
这些代理是完整解决方案所需

11
00:00:30,220 --> 00:00:32,900
但在本课中将模拟它们的输出

12
00:00:32,900 --> 00:00:35,750
你将专注于新概念

13
00:00:35,750 --> 00:00:38,730
实体和事实类型提案代理

14
00:00:38,730 --> 00:00:44,830
实体和事实提案代理本身由两个专用子代理组成

15
00:00:44,830 --> 00:00:51,860
命名实体识别或nr架构代理和事实类型提取代理

16
00:00:51,860 --> 00:00:57,040
请注意这些代理的输出是知识提取的执行计划

17
00:00:57,040 --> 00:00:59,290
并非执行提取本身

18
00:00:59,290 --> 00:01:02,310
架构代理将读取markdown文件

19
00:01:02,310 --> 00:01:04,480
寻找命名实体

20
00:01:04,480 --> 00:01:05,519
这些是人物

21
00:01:05,519 --> 00:01:08,570
文本中突出的事物或地点

22
00:01:08,570 --> 00:01:09,510
在我们的示例中

23
00:01:09,510 --> 00:01:12,919
你应期待与家具和评论相关的内容

24
00:01:12,919 --> 00:01:17,199
事实类型提取代理是文本的二次分析

25
00:01:17,199 --> 00:01:20,870
寻找关于这些事物的陈述类型

26
00:01:20,870 --> 00:01:21,970
例如

27
00:01:21,970 --> 00:01:25,060
某些家具存在共同问题

28
00:01:25,060 --> 00:01:31,510
这些代理将制定支持用户目标的初始信息提取计划

29
00:01:35,289 --> 00:01:36,549
然后它将打开

30
00:01:36,549 --> 00:01:38,689
AI设置并检查是否正常运行

31
00:01:39,929 --> 00:01:41,120
看起来不错

32
00:01:41,120 --> 00:01:43,640
我们也将检查new for是否可用

33
00:01:43,640 --> 00:01:46,130
也准备好了现在

34
00:01:46,130 --> 00:01:50,039
你首先要定义的代理是命名实体识别代理

35
00:01:50,039 --> 00:01:56,020
命名实体识别是常见的自然语言处理操作，存在于许多框架中

36
00:01:56,020 --> 00:01:56,660
事实证明

37
00:01:56,660 --> 00:01:57,000
当然

38
00:01:57,000 --> 00:01:58,720
大语言模型在语言处理方面非常出色

39
00:01:58,720 --> 00:02:00,980
因此也非常擅长此任务

40
00:02:00,980 --> 00:02:02,900
现在命名实体识别

41
00:02:02,900 --> 00:02:03,880
正如所说

42
00:02:03,880 --> 00:02:07,420
是指识别实体并为其命名

43
00:02:07,420 --> 00:02:07,720
确实

44
00:02:07,720 --> 00:02:09,080
这就是正在发生的事情

45
00:02:09,080 --> 00:02:11,280
实体可以是任何人、地点或事物

46
00:02:11,280 --> 00:02:12,500
一个地点或物品

47
00:02:12,500 --> 00:02:15,860
在这里我们将要求llm寻找与

48
00:02:15,860 --> 00:02:19,540
用户目标相关的文本中可发现的内容

49
00:02:19,540 --> 00:02:22,420
你将从定义代理的指令开始

50
00:02:22,420 --> 00:02:23,520
和之前一样

51
00:02:23,520 --> 00:02:26,890
我们将将其拆分为几个不同部分，这些部分随后将组合在一起

52
00:02:26,890 --> 00:02:27,410
首先

53
00:02:27,410 --> 00:02:29,150
定义亚洲的角色和目标

54
00:02:29,150 --> 00:02:32,930
在这里你要描述代理是一个顶级算法

55
00:02:32,930 --> 00:02:35,600
专为进行自然语言处理而设计

56
00:02:35,600 --> 00:02:39,320
其目标是在文本中找到命名实体

57
00:02:39,320 --> 00:02:41,440
但它实际上不会提取这些实体

58
00:02:41,440 --> 00:02:45,280
这里的目的是让其识别可用的实体类型

59
00:02:46,320 --> 00:02:48,400
然后你可以给代理更多提示

60
00:02:48,400 --> 00:02:51,620
让它明确我们在这里寻找的内容，再次

61
00:02:51,620 --> 00:02:53,870
我们将描述什么是实体

62
00:02:53,870 --> 00:02:57,140
然后将其分为两类实体

63
00:02:57,140 --> 00:03:00,360
我们将描述这里所说的知名实体

64
00:03:00,360 --> 00:03:01,660
这些是众所周知的

65
00:03:01,660 --> 00:03:06,040
因为它们存在于我们之前课程中描述的结构化数据中

66
00:03:06,040 --> 00:03:07,740
所以如果该结构化数据

67
00:03:07,740 --> 00:03:10,950
如果其中定义的某些实体出现在文本中

68
00:03:10,950 --> 00:03:13,530
我们希望文本中的这些部分也被提取

69
00:03:13,530 --> 00:03:16,970
此外我们还有所谓的发现实体

70
00:03:16,970 --> 00:03:21,070
这些实体可能不存在于我们描述的图数据中

71
00:03:21,070 --> 00:03:23,390
但可能符合用户的使用目标

72
00:03:23,390 --> 00:03:24,870
如果它们频繁出现

73
00:03:24,870 --> 00:03:26,830
可能就有用处

74
00:03:27,010 --> 00:03:28,770
然后我们提供更多细节关于

75
00:03:28,770 --> 00:03:32,650
了解什么是知名实体的设计规则

76
00:03:32,650 --> 00:03:34,710
以及什么是发现实体

77
00:03:34,710 --> 00:03:41,070
和之前一样通常给出几个例子帮助代理理解目的

78
00:03:42,139 --> 00:03:46,680
最终需要整合的指令部分是思维链方向

79
00:03:46,680 --> 00:03:50,660
这里我们将描述如何准备执行当前任务

80
00:03:50,660 --> 00:03:52,420
即识别这些实体

81
00:03:52,420 --> 00:03:56,340
这里需要使用的工具来确定其职责

82
00:03:56,340 --> 00:03:57,760
提供完整上下文

83
00:03:57,760 --> 00:04:01,440
然后是建议的步骤序列

84
00:04:01,440 --> 00:04:02,920
它知道可用的文件

85
00:04:02,920 --> 00:04:04,640
有一个文件采样工具

86
00:04:04,640 --> 00:04:07,000
先使用该工具查看部分文件

87
00:04:07,000 --> 00:04:10,949
并发现已知实体

88
00:04:10,949 --> 00:04:13,629
同时发现频繁提及的新实体

89
00:04:13,629 --> 00:04:18,149
通过这些整理出所有合适的实体列表

90
00:04:18,149 --> 00:04:21,750
使用建议实体工具获取该列表

91
00:04:21,750 --> 00:04:24,850
和之前一样返回用户确认

92
00:04:24,850 --> 00:04:26,020
这看起来正确吗

93
00:04:26,020 --> 00:04:29,540
然后会调用单独的审批工具

94
00:04:29,540 --> 00:04:32,360
这里称为审批建议实体工具

95
00:04:32,640 --> 00:04:35,260
然后将所有内容组合成单个字符串

96
00:04:35,260 --> 00:04:40,020
这将成为命名实体识别代理的指令

97
00:04:40,100 --> 00:04:41,500
定义完指令后

98
00:04:41,500 --> 00:04:44,380
再提供工具本身的定义

99
00:04:44,380 --> 00:04:46,180
这些将非常直接

100
00:04:46,180 --> 00:04:48,600
这里并没有太多巧妙的操作

101
00:04:48,600 --> 00:04:50,000
我们将要定义的工具

102
00:04:50,000 --> 00:04:52,750
遵循我们之前课程中的相同模式

103
00:04:52,750 --> 00:04:55,650
我们将让代理首先提出一些内容

104
00:04:55,650 --> 00:05:00,530
然后有其他工具将这些提案转化为批准版本

105
00:05:00,530 --> 00:05:01,170
所以在这里

106
00:05:01,170 --> 00:05:05,810
我们提出的事项是首先提案然后批准的实体列表

107
00:05:05,810 --> 00:05:06,890
然后你也可以

108
00:05:06,890 --> 00:05:07,250
当然

109
00:05:07,250 --> 00:05:10,780
获取这些提案或批准结果

110
00:05:11,180 --> 00:05:13,480
下一个需要的工具稍有不同

111
00:05:13,480 --> 00:05:15,549
这将是另一个获取工具

112
00:05:15,549 --> 00:05:20,509
它将从提议的方案中获取已知类型

113
00:05:20,509 --> 00:05:21,820
在之前的课程中

114
00:05:21,820 --> 00:05:23,140
从结构化数据中

115
00:05:23,140 --> 00:05:27,000
因此已知类型最终将成为节点定义的标签

116
00:05:27,000 --> 00:05:29,850
在之前的提议方案中

117
00:05:29,850 --> 00:05:32,150
它们将作为批准标签使用

118
00:05:32,150 --> 00:05:36,750
我们将从建设计划中提取并返回为列表

119
00:05:38,060 --> 00:05:42,330
你可以导入之前课程中定义的预设工具

120
00:05:42,330 --> 00:05:46,270
并将此处的新增工具合并为单个列表

121
00:05:46,270 --> 00:05:48,850
这就是我们在代理定义中使用的内容

122
00:05:49,150 --> 00:05:51,650
现在为了了解代理的工作内容

123
00:05:51,650 --> 00:05:53,830
可以使用样本文件函数

124
00:05:53,830 --> 00:05:58,070
直接调用其中一个可用文件并查看内容

125
00:05:59,070 --> 00:06:00,710
查看这个markdown文件

126
00:06:00,710 --> 00:06:03,910
可以看到这是大量以markdown格式的评论

127
00:06:03,910 --> 00:06:04,930
包含标题

128
00:06:04,930 --> 00:06:06,670
还有一些嵌入在此处的值

129
00:06:06,670 --> 00:06:07,770
比如评分

130
00:06:07,770 --> 00:06:09,230
可以看到有用户名

131
00:06:09,230 --> 00:06:10,030
地点

132
00:06:10,030 --> 00:06:10,450
还有

133
00:06:10,450 --> 00:06:12,450
当然还有评论本身的内容

134
00:06:12,450 --> 00:06:16,040
这里只有少量评论

135
00:06:16,040 --> 00:06:19,340
但足以演示整个流程

136
00:06:21,540 --> 00:06:21,960
好的

137
00:06:21,960 --> 00:06:23,480
你已定义好指令

138
00:06:23,480 --> 00:06:25,620
现在也定义好了工具

139
00:06:25,620 --> 00:06:29,250
现在可以构建代理本身来运行此代理

140
00:06:29,250 --> 00:06:31,140
因为它属于更长的工作流程

141
00:06:31,140 --> 00:06:34,460
它对状态中已积累的内容有假设

142
00:06:34,460 --> 00:06:38,130
因此需要创建初始状态来测试代理

143
00:06:38,130 --> 00:06:43,050
初始状态需要包含批准后的用户目标

144
00:06:43,050 --> 00:06:44,250
此处的批准文件

145
00:06:44,250 --> 00:06:45,310
可以看到markdown文件

146
00:06:45,310 --> 00:06:46,690
它将查看

147
00:06:46,690 --> 00:06:48,690
然后还需要建设计划

148
00:06:48,690 --> 00:06:53,230
建设计划用于已知实体类型

149
00:06:53,230 --> 00:06:55,490
注意我们省略了关系建设部分

150
00:06:55,490 --> 00:06:57,670
仅仅因为这一步不需要那个内容

151
00:06:57,670 --> 00:07:01,310
所以这只是在模拟你现在需要的操作

152
00:07:01,310 --> 00:07:03,190
你已经准备好运行这个代理了

153
00:07:03,190 --> 00:07:06,410
我们将使用helper模块中的make_agent_caller

154
00:07:06,410 --> 00:07:09,690
并发送一个简单请求

155
00:07:09,690 --> 00:07:10,910
我们只需告诉它

156
00:07:10,910 --> 00:07:11,190
你知道的

157
00:07:11,190 --> 00:07:11,550
嘿，代理

158
00:07:11,550 --> 00:07:12,560
你能完成你的工作吗

159
00:07:12,560 --> 00:07:17,760
将产品评论添加到知识图谱中，将产品投诉反馈到制造流程

160
00:07:17,760 --> 00:07:19,440
如果在这里遇到任何问题

161
00:07:19,440 --> 00:07:22,020
当然你可以运行这个替代版本

162
00:07:22,020 --> 00:07:23,340
这是一个非常简短的句子

163
00:07:23,340 --> 00:07:25,640
但这里包含debug逗号true

164
00:07:25,640 --> 00:07:27,130
这会显示所有输出

165
00:07:27,130 --> 00:07:28,210
当代理完成时

166
00:07:28,210 --> 00:07:30,670
大致展示它想要提出的方案

167
00:07:30,670 --> 00:07:31,870
并生成提案

168
00:07:31,870 --> 00:07:35,720
我们将检查会话状态以确认已生成提案

169
00:07:35,720 --> 00:07:36,040
并且

170
00:07:36,040 --> 00:07:38,060
希望它不会自动批准

171
00:07:38,060 --> 00:07:39,440
它应该在等待我们确认

172
00:07:39,440 --> 00:07:39,680
是的

173
00:07:39,680 --> 00:07:41,160
看起来不错

174
00:07:41,340 --> 00:07:43,100
这个过程需要几分钟

175
00:07:43,100 --> 00:07:44,620
因为代理会离开

176
00:07:44,620 --> 00:07:46,929
查看这些不同文件

177
00:07:46,929 --> 00:07:48,549
并尝试推断

178
00:07:48,549 --> 00:07:52,510
认为最适合实体的标签集合

179
00:07:52,510 --> 00:07:53,290
好的

180
00:07:53,290 --> 00:07:54,250
完成得相当不错

181
00:07:54,250 --> 00:07:56,490
它识别出这里有产品

182
00:07:56,490 --> 00:07:58,170
存在报告的问题

183
00:07:58,170 --> 00:08:00,260
对常规体验的投诉

184
00:08:00,500 --> 00:08:01,520
组装说明

185
00:08:01,520 --> 00:08:03,140
以及可能的客户反馈

186
00:08:03,140 --> 00:08:04,500
可能存在一点冗余

187
00:08:04,500 --> 00:08:06,750
但对我来说已经足够好了

188
00:08:06,910 --> 00:08:08,350
这也是重要的

189
00:08:08,350 --> 00:08:09,950
不仅响应良好

190
00:08:09,950 --> 00:08:12,230
还正确更新了会话状态

191
00:08:12,230 --> 00:08:13,570
记忆记录正确

192
00:08:13,570 --> 00:08:15,010
我们有了提议的实体

193
00:08:15,010 --> 00:08:16,570
但我们尚未获得批准

194
00:08:17,650 --> 00:08:19,090
我得到了良好的结果

195
00:08:19,090 --> 00:08:21,610
如果还没运行过请随时再次执行该单元

196
00:08:21,610 --> 00:08:24,510
看看是否能得到更好的实体集合

197
00:08:24,510 --> 00:08:27,970
所有设置均假设在交互式环境中

198
00:08:27,970 --> 00:08:28,710
但如果有效

199
00:08:28,710 --> 00:08:32,630
你可以继续向同一代理发送新消息

200
00:08:32,630 --> 00:08:35,020
我批准这些提议的实体

201
00:08:35,020 --> 00:08:36,280
完成这一步后

202
00:08:36,280 --> 00:08:40,940
我们应该确认能够将提议的实体转换为已批准实体

203
00:08:40,940 --> 00:08:45,280
并在会话状态中完美呈现这一点

204
00:08:45,280 --> 00:08:49,200
已批准实体与之前提议的内容完全匹配

205
00:08:50,300 --> 00:08:52,220
然后可以继续处理第二个代理

206
00:08:53,380 --> 00:08:56,640
这将是我们的事实类型提取子代理

207
00:08:56,640 --> 00:08:57,700
正如名称所示

208
00:08:57,700 --> 00:08:58,140
当然

209
00:08:58,140 --> 00:09:00,140
与前一个代理类似

210
00:09:00,140 --> 00:09:02,520
我们将寻找可提取的事物类型

211
00:09:02,520 --> 00:09:04,900
我们不会实际执行提取操作

212
00:09:04,900 --> 00:09:06,500
可以先从指令开始

213
00:09:06,500 --> 00:09:09,560
因为这是这两个代理最重要的部分

214
00:09:09,560 --> 00:09:10,740
对于这个代理

215
00:09:10,740 --> 00:09:12,320
角色和目标再次说明

216
00:09:12,320 --> 00:09:14,840
我们将称这个代理为顶层算法

217
00:09:14,840 --> 00:09:17,099
它将进行文本分析

218
00:09:17,099 --> 00:09:19,200
但目标略有不同

219
00:09:19,200 --> 00:09:22,360
它将寻找可提取的事实类型

220
00:09:22,360 --> 00:09:24,060
不要实际提取这些事实

221
00:09:24,060 --> 00:09:26,640
只需确定可能的事实类型

222
00:09:27,530 --> 00:09:30,470
以帮助下级代理理解我们讨论的内容

223
00:09:30,470 --> 00:09:30,830
这里

224
00:09:30,830 --> 00:09:32,260
我们将提供一些提示

225
00:09:32,260 --> 00:09:34,340
这里的关键部分是

226
00:09:34,340 --> 00:09:36,820
与之前代理的指令类似

227
00:09:36,820 --> 00:09:40,100
前一个代理不要提出具体事实

228
00:09:40,100 --> 00:09:44,480
而是提出与用户目标相关的一般事实类型

229
00:09:44,480 --> 00:09:47,400
在此处提供示例总是个好主意

230
00:09:47,400 --> 00:09:50,160
我的示例是不要提出abk喜欢咖啡

231
00:09:50,160 --> 00:09:54,090
而是提出一个人喜欢饮料的一般事实类型

232
00:09:54,090 --> 00:09:56,710
这些形成非常简洁的句子

233
00:09:56,710 --> 00:09:58,690
我们将这些句子称为三元组

234
00:09:58,690 --> 00:10:00,090
它们的形式为主语

235
00:10:00,090 --> 00:10:01,320
谓语-宾语

236
00:10:01,320 --> 00:10:04,060
在这里我们将其放在括号中

237
00:10:04,060 --> 00:10:05,560
这是常见做法

238
00:10:05,560 --> 00:10:09,500
我们将观察代理是否采用此格式并返回结果

239
00:10:09,500 --> 00:10:10,810
在响应中

240
00:10:10,810 --> 00:10:14,790
我们提供额外的设计规则以指导思考和查找内容

241
00:10:14,790 --> 00:10:18,820
同时说明如何使用工具与前一个代理不同

242
00:10:18,820 --> 00:10:23,170
前一个代理在此处有一个完整的提议实体列表

243
00:10:23,170 --> 00:10:24,410
针对每个独立事实

244
00:10:24,410 --> 00:10:26,770
我们将逐一添加为独立事实

245
00:10:26,770 --> 00:10:27,650
一次一个

246
00:10:27,650 --> 00:10:32,320
而非提供一组提议的事实集合

247
00:10:32,320 --> 00:10:36,260
关键在于代理的行为方式

248
00:10:36,260 --> 00:10:40,690
以及token成本，更多往返次数

249
00:10:40,690 --> 00:10:42,470
会增加一定费用

250
00:10:42,470 --> 00:10:44,750
但如果结果更好

251
00:10:44,750 --> 00:10:46,870
那或许是个不错的权衡

252
00:10:47,759 --> 00:10:50,979
最后你可以继续添加思维链方向

253
00:10:50,979 --> 00:10:55,700
和之前一样，我们将遵循这些方向的固定模式

254
00:10:55,700 --> 00:10:57,220
这是任务准备方法

255
00:10:57,220 --> 00:11:01,819
这是我们建议的分步执行方案

256
00:11:01,819 --> 00:11:03,399
以这种方式使用工具

257
00:11:03,399 --> 00:11:04,970
抽样部分文件

258
00:11:04,970 --> 00:11:08,130
寻找与文本相关的主体和客体

259
00:11:08,130 --> 00:11:11,660
然后为这些主体和客体添加建议事实

260
00:11:11,660 --> 00:11:15,260
最终你会得到几句话

261
00:11:15,260 --> 00:11:17,579
三词短句

262
00:11:18,219 --> 00:11:21,079
然后将所有内容整合成一个字符串

263
00:11:21,079 --> 00:11:24,210
我们现在准备进入工具定义

264
00:11:24,210 --> 00:11:24,650
现在

265
00:11:24,650 --> 00:11:26,950
我将花更多时间分析工具定义

266
00:11:26,950 --> 00:11:29,670
针对事实类型提取代理

267
00:11:29,670 --> 00:11:33,190
因为它在过程中会做一些合理性检查

268
00:11:33,190 --> 00:11:36,400
这也是将它们分代理的意图之一

269
00:11:36,400 --> 00:11:37,500
在之前的代理中

270
00:11:37,500 --> 00:11:39,580
命名实体识别代理

271
00:11:39,580 --> 00:11:42,180
我们给了它如何查找实体的指导

272
00:11:42,180 --> 00:11:45,610
但并未严格限制其发现内容

273
00:11:45,610 --> 00:11:46,770
我们将非常严格

274
00:11:46,770 --> 00:11:51,710
所提议的事实必须与已有实体类型匹配

275
00:11:51,710 --> 00:11:53,740
由前代理定义的类型

276
00:11:53,740 --> 00:11:54,760
这种拆分方式

277
00:11:54,760 --> 00:11:56,140
能提供更好的保障

278
00:11:56,140 --> 00:11:59,880
确保事实与实体类型一致

279
00:11:59,880 --> 00:12:02,380
正如我们所希望的

280
00:12:02,380 --> 00:12:05,460
查看提议事实的定义时

281
00:12:05,460 --> 00:12:06,500
我们得到的是

282
00:12:06,500 --> 00:12:08,920
甚至通过参数名称

283
00:12:08,920 --> 00:12:11,320
是已批准的主体标签

284
00:12:11,320 --> 00:12:12,840
提议的谓词标签

285
00:12:12,840 --> 00:12:14,740
然后是已批准的客体标签

286
00:12:14,740 --> 00:12:17,790
这再次形成三元组结构

287
00:12:17,790 --> 00:12:21,850
主体和客体应已由前代理生成

288
00:12:21,850 --> 00:12:24,579
我们将在此设置一些限制

289
00:12:24,579 --> 00:12:25,779
我们将进行检查

290
00:12:25,779 --> 00:12:26,539
已批准的实体

291
00:12:26,539 --> 00:12:27,679
从状态中获取

292
00:12:27,679 --> 00:12:31,640
确保传入的主体和客体标签

293
00:12:31,640 --> 00:12:33,380
在列表中存在

294
00:12:33,380 --> 00:12:37,390
若不存在则触发工具调用错误

295
00:12:37,390 --> 00:12:39,410
并提示标签不存在

296
00:12:39,410 --> 00:12:41,040
让它重新尝试

297
00:12:41,040 --> 00:12:43,740
我们分步处理的原因之一

298
00:12:43,740 --> 00:12:45,740
以便逐步调整

299
00:12:45,740 --> 00:12:49,390
逐步修正代理行为

300
00:12:49,390 --> 00:12:50,740
如果这些内容看起来都没问题

301
00:12:50,740 --> 00:12:53,700
然后我们将其重新整理成一个三元组

302
00:12:53,700 --> 00:12:58,569
将其保存到当前谓词列表并生成事实列表

303
00:12:58,729 --> 00:13:01,669
这里的另外两个函数只是遵循常规模式

304
00:13:01,669 --> 00:13:03,409
获取提议的事实列表

305
00:13:03,409 --> 00:13:07,700
然后将提议的事实添加到已批准的事实列表

306
00:13:07,860 --> 00:13:11,620
你可以将这些工具列表整合起来

307
00:13:11,620 --> 00:13:13,320
随时可供事实代理使用

308
00:13:13,320 --> 00:13:15,640
现在我们可以开始构建了

309
00:13:15,920 --> 00:13:16,800
构建代理

310
00:13:16,800 --> 00:13:18,100
既然我们已经完成了所有繁重工作

311
00:13:18,100 --> 00:13:20,380
真正定义事物其实非常直接

312
00:13:20,380 --> 00:13:23,130
现在你可以运行它了

313
00:13:23,450 --> 00:13:28,290
这个代理的初始状态与之前代理相同

314
00:13:28,290 --> 00:13:29,970
我们将利用这一点

315
00:13:29,970 --> 00:13:34,320
直接复制前代理的最终状态作为当前代理

316
00:13:34,320 --> 00:13:36,100
在完整的多代理系统中

317
00:13:36,100 --> 00:13:37,560
这些操作会按顺序执行

318
00:13:37,560 --> 00:13:40,640
它们会共享同一状态

319
00:13:40,640 --> 00:13:42,080
但你也可以单独运行它们

320
00:13:42,080 --> 00:13:43,340
我们将进行复制

321
00:13:43,340 --> 00:13:46,420
然后创建代理的调用者

322
00:13:46,420 --> 00:13:49,370
我们将使用的启动消息

323
00:13:49,370 --> 00:13:52,069
是要求其生成提议

324
00:13:52,069 --> 00:13:53,589
这里输出内容很多

325
00:13:53,589 --> 00:13:56,689
所以我将改用这种方式

326
00:13:56,689 --> 00:13:58,300
去掉末尾的逗号true

327
00:13:58,300 --> 00:14:01,840
这样代理可以正常工作而不显示全部输出

328
00:14:01,840 --> 00:14:03,320
如果遇到问题

329
00:14:03,320 --> 00:14:05,400
使用带有逗号true的版本

330
00:14:05,400 --> 00:14:09,100
当代理完成所有事实提议后

331
00:14:09,100 --> 00:14:11,720
我们将检查会话状态

332
00:14:11,720 --> 00:14:14,260
假设它已生成提议

333
00:14:14,260 --> 00:14:16,060
若未生成则发出警告

334
00:14:16,060 --> 00:14:19,220
同时假设未批准该提议

335
00:14:19,220 --> 00:14:21,230
希望一切顺利

336
00:14:22,560 --> 00:14:23,080
好的

337
00:14:23,080 --> 00:14:25,480
查看它生成的提议

338
00:14:25,480 --> 00:14:26,840
提出的事实

339
00:14:26,840 --> 00:14:31,839
例如产品存在问题及收到客户反馈

340
00:14:31,839 --> 00:14:33,739
产品有组装时间

341
00:14:33,739 --> 00:14:35,500
这很有趣

342
00:14:35,500 --> 00:14:36,880
这里有很多不同内容

343
00:14:36,880 --> 00:14:38,540
看起来是个不错的列表

344
00:14:38,540 --> 00:14:41,770
检查会话状态啊

345
00:14:41,770 --> 00:14:43,430
这里出现了问题

346
00:14:43,430 --> 00:14:45,630
它确实返回了提议

347
00:14:45,630 --> 00:14:48,550
但未将其保存到会话状态

348
00:14:48,550 --> 00:14:50,060
为什么会这样

349
00:14:50,060 --> 00:14:51,660
看看是否有投诉

350
00:14:51,660 --> 00:14:54,490
这确实令人遗憾

351
00:14:54,490 --> 00:14:57,550
因此决定正式提出这个提案并采用纯文本

352
00:14:57,550 --> 00:15:01,510
但它并未真正实现我们预期的工具调用功能

353
00:15:01,510 --> 00:15:01,950
所以

354
00:15:01,950 --> 00:15:02,150
我提议

355
00:15:02,150 --> 00:15:03,370
你继续运行这个流程

356
00:15:03,370 --> 00:15:06,190
当然在完整的智能体系统中

357
00:15:06,390 --> 00:15:08,890
当它提出这种建议时

358
00:15:08,890 --> 00:15:12,270
最终我们发现没有生成事实提案

359
00:15:12,270 --> 00:15:14,960
我们将自动重新尝试

360
00:15:14,960 --> 00:15:17,080
这次重运行应该能顺利执行

361
00:15:17,080 --> 00:15:18,680
因为它会重新初始化状态

362
00:15:18,680 --> 00:15:21,160
然后按相同步骤继续

363
00:15:23,040 --> 00:15:23,760
好的

364
00:15:23,760 --> 00:15:28,360
我们看到效果类型与之前基本一致

365
00:15:28,360 --> 00:15:30,339
符合用户目标

366
00:15:30,339 --> 00:15:32,590
询问我们是否继续

367
00:15:32,590 --> 00:15:34,330
让我们看看是否真的

368
00:15:34,330 --> 00:15:36,430
已正确提出这些事实

369
00:15:36,430 --> 00:15:37,810
但仍在等待批准

370
00:15:37,810 --> 00:15:38,290
好的

371
00:15:38,290 --> 00:15:39,510
智能体干得好

372
00:15:39,510 --> 00:15:40,510
加一分

373
00:15:40,510 --> 00:15:43,290
这次同样

374
00:15:43,290 --> 00:15:44,450
如果这次不成功

375
00:15:44,450 --> 00:15:45,810
只需再次运行

376
00:15:45,810 --> 00:15:47,610
取决于OpenAI的状态

377
00:15:47,610 --> 00:15:48,730
在任何一天

378
00:15:48,730 --> 00:15:50,750
可能第一次或第二次成功

379
00:15:50,750 --> 00:15:52,940
通常不需要三次

380
00:15:52,940 --> 00:15:54,880
我将发送另一条消息

381
00:15:54,880 --> 00:15:55,860
批准该提案

382
00:15:55,860 --> 00:16:00,100
这将直接转为已批准事实

383
00:16:01,230 --> 00:16:02,650
查看会话状态

384
00:16:02,650 --> 00:16:06,230
最终看到已批准的事实类型，完美

385
00:16:06,230 --> 00:16:08,040
这次运行效果很好

