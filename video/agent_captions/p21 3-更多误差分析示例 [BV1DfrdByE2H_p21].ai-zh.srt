1
00:00:00,080 --> 00:00:04,200
我发现对于许多开发者来说，只有通过观察多个示例

2
00:00:04,200 --> 00:00:09,780
你才能进行练习并磨练自己对错误分析的直觉

3
00:00:09,780 --> 00:00:12,060
那么让我们再看看两个更多示例

4
00:00:12,060 --> 00:00:16,329
我们将分析发票处理和回复客户邮件的场景

5
00:00:16,329 --> 00:00:19,489
这是我们设计的发票处理流程

6
00:00:19,489 --> 00:00:25,660
其中包含明确的步骤遵循特征化工作流，识别四个必要字段

7
00:00:25,660 --> 00:00:28,579
然后将数据录入数据库

8
00:00:28,579 --> 00:00:29,479
在示例中

9
00:00:29,479 --> 00:00:31,139
从本模块的第一个视频

10
00:00:31,139 --> 00:00:36,130
我们提到系统经常在发票到期日判断上出错

11
00:00:36,130 --> 00:00:37,950
因此我们可以进行分析

12
00:00:37,950 --> 00:00:41,940
试图确定可能出错的组件

13
00:00:41,940 --> 00:00:42,160
所以

14
00:00:42,160 --> 00:00:42,680
例如

15
00:00:42,680 --> 00:00:44,080
PDF转文本是否出错

16
00:00:44,080 --> 00:00:44,800
或是否出错

17
00:00:44,800 --> 00:00:47,420
语言模型是否提取了错误日期

18
00:00:47,420 --> 00:00:50,929
所有来自PDF转文本组件的输出

19
00:00:50,929 --> 00:00:53,109
传递给卡尔并进行错误分析

20
00:00:53,109 --> 00:00:58,160
我会寻找数据提取错误的多个示例

21
00:00:58,160 --> 00:01:03,560
如同前一视频所示，重点分析表现不佳的案例

22
00:01:03,560 --> 00:01:05,960
试图找出这些案例出错的原因

23
00:01:05,960 --> 00:01:08,060
忽略日期正确的示例

24
00:01:08,060 --> 00:01:11,630
但需收集十到一百份发票

25
00:01:11,630 --> 00:01:12,810
其中日期有误

26
00:01:12,810 --> 00:01:15,650
然后我会逐一检查以确定

27
00:01:15,650 --> 00:01:19,830
问题根源是否是PDF转文本获取日期错误

28
00:01:19,830 --> 00:01:23,880
或是语言模型在处理PDF转文本输出时

29
00:01:23,880 --> 00:01:25,490
提取了错误日期

30
00:01:25,490 --> 00:01:29,650
或许可以制作类似表格并分析两份发票

31
00:01:29,650 --> 00:01:32,780
统计PDF转文本

32
00:01:32,780 --> 00:01:35,400
是否错误提取日期或文本

33
00:01:35,400 --> 00:01:38,160
导致人类也无法辨认到期日

34
00:01:38,160 --> 00:01:40,660
与PDF文本清晰可辨的情况相比

35
00:01:40,660 --> 00:01:44,040
但语言模型却错误提取了日期

36
00:01:44,040 --> 00:01:48,750
比如误将发票日期识别为到期日

37
00:01:48,750 --> 00:01:49,690
在此示例中

38
00:01:49,690 --> 00:01:53,350
数据提取环节导致了更多错误

39
00:01:53,350 --> 00:01:57,760
这表明我应优先优化数据提取组件

40
00:01:57,760 --> 00:01:59,860
而非PDF转文本环节

41
00:01:59,860 --> 00:02:02,800
这一点至关重要，因为若没有错误分析

42
00:02:02,800 --> 00:02:08,280
某些团队可能耗费数周甚至数月调优PDF转文本

43
00:02:08,280 --> 00:02:14,379
最终发现这些努力对系统性能影响微乎其微

44
00:02:14,379 --> 00:02:14,779
哦

45
00:02:14,779 --> 00:02:15,479
顺便说一句

46
00:02:15,479 --> 00:02:19,820
底部的百分比可能不加到100%

47
00:02:19,820 --> 00:02:22,360
因为这些错误并非互斥

48
00:02:22,360 --> 00:02:23,660
最后看一个案例

49
00:02:23,660 --> 00:02:28,780
回到客户邮件回复的工作流

50
00:02:28,780 --> 00:02:31,900
其中语言模型接收客户邮件

51
00:02:31,900 --> 00:02:32,660
像这样

52
00:02:32,660 --> 00:02:33,900
下达指令

53
00:02:33,900 --> 00:02:36,190
调取订单详情

54
00:02:36,190 --> 00:02:38,090
从数据库获取信息

55
00:02:38,090 --> 00:02:40,510
然后草拟供人工审核的回复

56
00:02:40,510 --> 00:02:43,900
所以我又找到了一些例子

57
00:02:43,900 --> 00:02:44,920
无论出于什么原因

58
00:02:44,920 --> 00:02:47,860
最终输出结果令人不满意

59
00:02:47,860 --> 00:02:50,420
然后尝试找出哪里出错了

60
00:02:50,420 --> 00:02:52,340
可能出现的问题包括

61
00:02:52,340 --> 00:02:56,220
可能模型生成了错误的数据库查询

62
00:02:56,220 --> 00:02:58,440
当查询发送到数据库时

63
00:02:58,440 --> 00:03:02,120
未能成功获取客户信息

64
00:03:02,120 --> 00:03:05,020
或者数据库存在数据损坏

65
00:03:05,020 --> 00:03:09,740
即使模型编写了完全合适的SQL查询

66
00:03:09,740 --> 00:03:10,860
查询语言部分

67
00:03:10,860 --> 00:03:13,140
数据库没有正确信息

68
00:03:13,140 --> 00:03:16,020
或者根据客户订单的正确信息

69
00:03:16,020 --> 00:03:20,119
模型编写了邮件内容却有所偏差

70
00:03:20,119 --> 00:03:20,659
再次说明

71
00:03:20,659 --> 00:03:22,619
我会查看几封邮件

72
00:03:22,619 --> 00:03:26,810
最终输出不满意的案例并分析问题

73
00:03:26,810 --> 00:03:28,150
比如一封邮件

74
00:03:28,150 --> 00:03:31,650
发现模型在查询中调用了错误的表

75
00:03:31,650 --> 00:03:35,240
在邮件二中错误查询了数据

76
00:03:35,240 --> 00:03:38,620
可能发现数据库本身存在错误

77
00:03:38,620 --> 00:03:40,540
在给定输入的情况下

78
00:03:40,540 --> 00:03:44,550
模型甚至编写了子邮件等

79
00:03:44,550 --> 00:03:46,050
在这个案例中

80
00:03:46,050 --> 00:03:48,250
经过多封邮件分析后

81
00:03:48,250 --> 00:03:52,210
可能发现最常见的错误在于

82
00:03:52,210 --> 00:03:54,770
模型编写数据库查询的方式

83
00:03:54,770 --> 00:03:55,800
你说SQL查询

84
00:03:55,800 --> 00:03:58,280
为了获取相关数据

85
00:03:58,280 --> 00:04:00,520
而数据库本身基本正确

86
00:04:00,520 --> 00:04:02,460
仅存在少量数据错误

87
00:04:02,460 --> 00:04:05,820
模型生成邮件的方式也有问题

88
00:04:05,820 --> 00:04:07,580
可能表达不够准确

89
00:04:07,580 --> 00:04:08,720
大约30%的时间

90
00:04:08,720 --> 00:04:10,960
这表明改进方向

91
00:04:10,960 --> 00:04:14,480
可能需要优化模型的查询编写方式

92
00:04:14,480 --> 00:04:14,880
其次

93
00:04:14,880 --> 00:04:15,980
最关键的是

94
00:04:15,980 --> 00:04:18,279
可能需优化高阶提示词

95
00:04:18,279 --> 00:04:19,999
撰写最终邮件

96
00:04:19,999 --> 00:04:23,900
此类分析能显示75%的错误

97
00:04:23,900 --> 00:04:25,740
系统多数情况下表现正确

98
00:04:25,740 --> 00:04:27,680
但所有未达标的案例中

99
00:04:27,680 --> 00:04:31,130
75%的问题源于数据库查询

100
00:04:31,130 --> 00:04:35,890
这些信息能精准指导改进方向

101
00:04:35,890 --> 00:04:38,450
我正在开发AI工作流程

102
00:04:38,450 --> 00:04:42,850
我经常会使用这种错误分析来告诉我该将注意力集中在何处

103
00:04:42,850 --> 00:04:45,159
关于接下来该做什么工作

104
00:04:45,159 --> 00:04:46,759
当你做出那个决定时

105
00:04:46,759 --> 00:04:52,690
事实证明，为了补充我们之前在本模块中讨论的端到端元音

106
00:04:52,690 --> 00:04:57,260
评估整个端到端系统往往很有用

107
00:04:57,260 --> 00:04:59,300
但也需要单独分析各个组件

108
00:04:59,300 --> 00:05:02,180
因为这能让你在改进过程中更高效

109
00:05:02,180 --> 00:05:08,680
那个通过错误分析让你决定重点关注的组件

110
00:05:08,680 --> 00:05:13,140
所以让我们进入下一个视频学习组件层面

111
00:05:13,140 --> 00:05:14,260
邪恶的s

